{"meta":{"title":"XYZhi's Study notes","subtitle":"","description":"","author":"xyz","url":"http://sv.pointcut.cc","root":"/"},"pages":[{"title":"categories","date":"2022-02-16T16:33:38.000Z","updated":"2022-03-14T09:09:11.123Z","comments":true,"path":"categories/index.html","permalink":"http://sv.pointcut.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-16T16:50:45.000Z","updated":"2022-03-14T09:09:11.153Z","comments":true,"path":"tags/index.html","permalink":"http://sv.pointcut.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Cloud中openFeign的启动和调用源码","slug":"springcloud/07-Spring Cloud整合Dubbo","date":"2022-03-14T09:09:11.123Z","updated":"2022-03-14T09:09:11.123Z","comments":true,"path":"blog/springcloud/07-Spring Cloud整合Dubbo/","link":"","permalink":"http://sv.pointcut.cc/blog/springcloud/07-Spring%20Cloud%E6%95%B4%E5%90%88Dubbo/","excerpt":"","text":"Spring Cloud整合Dubboprovider端配置12345678910&lt;!-- 不用的版本可能artifactId不同，这时需要去spring-cloud-alibaba-dependencies中看 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213141516171819202122232425262728dubbo: scan: # 指定 Dubbo 服务实现类的扫描基准包 base-packages: com.tuling.mall.user.service # application:# # 这里不用配置，使用spring.application.name就好了 # name: $&#123;spring.application.name&#125; protocol: # dubbo 协议 name: dubbo # dubbo 协议端口（ -1 表示自增端口，从 20880 开始） port: -1# registry:# #挂载到 Spring Cloud 注册中心 高版本可选（就是nacos）# #不建议这样写# address: spring-cloud://127.0.0.1:8848spring: application: name: spring-cloud-dubbo-provider-user main: # Spring Boot2.1及更高的版本需要设定 allow-bean-definition-overriding: true cloud: nacos: # Nacos 服务发现与注册配置 discovery: server-addr: 127.0.0.1:8848 服务实现类上配置@DubboService暴露服务 12345678910111213141516@DubboServicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; list() &#123; return userMapper.list(); &#125; @Override public User getById(Integer id) &#123; return userMapper.getById(id); &#125;&#125; 启动后 重点 不要执行dubbo的注册中心，使用springcloud配置的注册中心。 consumer端配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 不用的版本可能artifactId不同，这时需要去spring-cloud-alibaba-dependencies中看 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213141516171819202122232425262728dubbo: cloud: # 指定需要订阅的服务提供方，默认值*，会订阅所有服务，不建议使用 subscribed-services: spring-cloud-dubbo-provider-user # application: # # 这里不用配置，使用spring.application.name就好了 # name: $&#123;spring.application.name&#125; protocol: # dubbo 协议 name: dubbo # dubbo 协议端口（ -1 表示自增端口，从 20880 开始） port: -1# registry:# #挂载到 Spring Cloud 注册中心 高版本可选（就是nacos）# #不建议这样写# address: spring-cloud://127.0.0.1:8848spring: application: name: spring-cloud-dubbo-consumer-user main: # Spring Boot2.1及更高的版本需要设定 allow-bean-definition-overriding: true cloud: nacos: # Nacos 服务发现与注册配置 discovery: server-addr: 127.0.0.1:8848 服务消费方通过@DubboReference引入服务 12345678910111213141516171819@RestController@RequestMapping(&quot;/user&quot;)public class UserConstroller &#123; @DubboReference private UserService userService; @RequestMapping(&quot;/info/&#123;id&#125;&quot;) public User info(@PathVariable(&quot;id&quot;) Integer id)&#123; return userService.getById(id); &#125; @RequestMapping(&quot;/list&quot;) public List&lt;User&gt; list()&#123; return userService.list(); &#125;&#125; 启动后 重点 不要执行dubbo的注册中心，使用springcloud配置的注册中心。 在dubbo中添加subscribed-services。订阅某个服务。","categories":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/categories/springcloud/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/tags/springcloud/"}]},{"title":"","slug":"springcloud/assets/07-Spring Cloud整合Dubbo","date":"2022-03-14T09:09:11.123Z","updated":"2022-03-14T09:09:11.123Z","comments":true,"path":"blog/springcloud/assets/07-Spring Cloud整合Dubbo/","link":"","permalink":"http://sv.pointcut.cc/blog/springcloud/assets/07-Spring%20Cloud%E6%95%B4%E5%90%88Dubbo/","excerpt":"","text":"Spring Cloud整合Dubboprovider端配置12345678910&lt;!-- 不用的版本可能artifactId不同，这时需要去spring-cloud-alibaba-dependencies中看 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213141516171819202122232425262728dubbo: scan: # 指定 Dubbo 服务实现类的扫描基准包 base-packages: com.tuling.mall.user.service # application:# # 这里不用配置，使用spring.application.name就好了 # name: $&#123;spring.application.name&#125; protocol: # dubbo 协议 name: dubbo # dubbo 协议端口（ -1 表示自增端口，从 20880 开始） port: -1# registry:# #挂载到 Spring Cloud 注册中心 高版本可选（就是nacos）# #不建议这样写# address: spring-cloud://127.0.0.1:8848spring: application: name: spring-cloud-dubbo-provider-user main: # Spring Boot2.1及更高的版本需要设定 allow-bean-definition-overriding: true cloud: nacos: # Nacos 服务发现与注册配置 discovery: server-addr: 127.0.0.1:8848 服务实现类上配置@DubboService暴露服务 12345678910111213141516@DubboServicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; list() &#123; return userMapper.list(); &#125; @Override public User getById(Integer id) &#123; return userMapper.getById(id); &#125;&#125; 启动后 重点 不要执行dubbo的注册中心，使用springcloud配置的注册中心。 consumer端配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 不用的版本可能artifactId不同，这时需要去spring-cloud-alibaba-dependencies中看 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 12345678910111213141516171819202122232425262728dubbo: cloud: # 指定需要订阅的服务提供方，默认值*，会订阅所有服务，不建议使用 subscribed-services: spring-cloud-dubbo-provider-user # application: # # 这里不用配置，使用spring.application.name就好了 # name: $&#123;spring.application.name&#125; protocol: # dubbo 协议 name: dubbo # dubbo 协议端口（ -1 表示自增端口，从 20880 开始） port: -1# registry:# #挂载到 Spring Cloud 注册中心 高版本可选（就是nacos）# #不建议这样写# address: spring-cloud://127.0.0.1:8848spring: application: name: spring-cloud-dubbo-consumer-user main: # Spring Boot2.1及更高的版本需要设定 allow-bean-definition-overriding: true cloud: nacos: # Nacos 服务发现与注册配置 discovery: server-addr: 127.0.0.1:8848 服务消费方通过@DubboReference引入服务 12345678910111213141516171819@RestController@RequestMapping(&quot;/user&quot;)public class UserConstroller &#123; @DubboReference private UserService userService; @RequestMapping(&quot;/info/&#123;id&#125;&quot;) public User info(@PathVariable(&quot;id&quot;) Integer id)&#123; return userService.getById(id); &#125; @RequestMapping(&quot;/list&quot;) public List&lt;User&gt; list()&#123; return userService.list(); &#125;&#125; 启动后 重点 不要执行dubbo的注册中心，使用springcloud配置的注册中心。 在dubbo中添加subscribed-services。订阅某个服务。","categories":[],"tags":[]},{"title":"Spring Cloud中openFeign的启动和调用源码","slug":"springcloud/06-spring cloud中Feign的源码","date":"2022-03-14T09:09:11.123Z","updated":"2022-03-14T09:09:11.123Z","comments":true,"path":"blog/springcloud/06-spring cloud中Feign的源码/","link":"","permalink":"http://sv.pointcut.cc/blog/springcloud/06-spring%20cloud%E4%B8%ADFeign%E7%9A%84%E6%BA%90%E7%A0%81/","excerpt":"","text":"Spring Cloud中openFeign的启动和调用源码启动 LoadBalancer使用的是Ribbon 要使用openFeign，需要引入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 启动的关键就是@EnableFeignClients注解和FeignRibbonClientAutoConfiguration、FeignAutoConfiguration自动配置类。 自动配置类FeignRibbonClientAutoConfigurationFeignRibbonClientAutoConfiguration自动配置类的主要目的有两个： 初始化feign.Client对象LoadBalancerFeignClient 初始化CachingSpringLoadBalancerFactory对象。 FeignAutoConfigurationFeignAutoConfiguration自动配置类的主要目的看下面的代码： 12345678910111213141516171819202122232425262728@Configuration(proxyBeanMethods = false)@ConditionalOnClass(Feign.class)@EnableConfigurationProperties(&#123; FeignClientProperties.class, FeignHttpClientProperties.class &#125;)public class FeignAutoConfiguration &#123; @Autowired(required = false) private List&lt;FeignClientSpecification&gt; configurations = new ArrayList&lt;&gt;(); @Bean public FeignContext feignContext() &#123; FeignContext context = new FeignContext(); context.setConfigurations(this.configurations); return context; &#125; @Configuration(proxyBeanMethods = false) @ConditionalOnMissingClass(&quot;feign.hystrix.HystrixFeign&quot;) protected static class DefaultFeignTargeterConfiguration &#123; @Bean @ConditionalOnMissingBean public Targeter feignTargeter() &#123; return new DefaultTargeter(); &#125; &#125;&#125; 可以总结为3点： 收集FeignClientSpecification的实现，这个FeignClientSpecification类是NamedContextFactory.Specification的实现类。其作用就是保存名字为name的客户端的配置类。这个是NamedContextFactory提供的扩展。 初始化FeignContext对象，它是NamedContextFactory的子类。NamedContextFactory在前面就讲过了，按名字来管理上下文（按名字来隔离配置），到Spring cloud的服务注册和发现中就变成按服务进行配置的隔离和某些配置的共享。FeignContext类的功能其实很明了了，就是管理每个服务的客户端的配置（或者是ApplicationContext）。这个类也是openFeign的核心。而且从FeignContext的初始化中可以知，所有服务客户端的公用配置类为FeignClientsConfiguration. 初始化Targeter对象，这个对象所关注的核心功能生成代理对象。 @EnableFeignClients注解的处理 这个注解就是引入FeignClientsRegistrar类的，下面是FeignClientsRegistrar类的类图： 可以看到，它实现了ImportBeanDefinitionRegistrar接口，所以registerBeanDefinitions方法就是该类的核心 123456@Overridepublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; registerDefaultConfiguration(metadata, registry); registerFeignClients(metadata, registry);&#125; registerDefaultConfiguration源码： 12345678910111213141516171819202122232425262728private void registerDefaultConfiguration(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; Map&lt;String, Object&gt; defaultAttrs = metadata .getAnnotationAttributes(EnableFeignClients.class.getName(), true); if (defaultAttrs != null &amp;&amp; defaultAttrs.containsKey(&quot;defaultConfiguration&quot;)) &#123; String name; if (metadata.hasEnclosingClass()) &#123; name = &quot;default.&quot; + metadata.getEnclosingClassName(); &#125; else &#123; name = &quot;default.&quot; + metadata.getClassName(); &#125; registerClientConfiguration(registry, name, defaultAttrs.get(&quot;defaultConfiguration&quot;)); &#125;&#125;private void registerClientConfiguration(BeanDefinitionRegistry registry, Object name, Object configuration) &#123; BeanDefinitionBuilder builder = BeanDefinitionBuilder .genericBeanDefinition(FeignClientSpecification.class); builder.addConstructorArgValue(name); builder.addConstructorArgValue(configuration); registry.registerBeanDefinition( name + &quot;.&quot; + FeignClientSpecification.class.getSimpleName(), builder.getBeanDefinition());&#125; 就是为了处理EnableFeignClients注解的defaultConfiguration属性，把该属性的值注册成FeignClientSpecification的BeanDefinition，对应的beanName为default.com.tuling.mall.feigndemo.MallUserFeignDemoApplication.FeignClientSpecification。 com.tuling.mall.feigndemo.MallUserFeignDemoApplication是有@EnableFeignClients注解的类的全限定名 FeignClientSpecification是用来保存某个服务的配置类的。这里注册的FeignClientSpecification在自动配置类FeignAutoConfiguration中会收集起来，并把它们保存到FeignContext对象中，而且由于beanName是以default.开头的，所以这里注册的FeignClientSpecification会作为公用配置类，让每一个服务都共享，这个规则是由NamedContextFactory所定义的 NamedContextFactory的createContext方法就定义了一个配置的优先级。不过这个生效的前提就是配置类没有排序相关的注解或接口。 在没有排序等接口时，在解析这些类时是按register的顺序解析的。 registerFeignClients 在该方法中首先创建了一个ClassPathScanningCandidateComponentProvider对象 12345678910111213ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false, this.environment) &#123; @Override protected boolean isCandidateComponent( AnnotatedBeanDefinition beanDefinition) &#123; boolean isCandidate = false; if (beanDefinition.getMetadata().isIndependent()) &#123; if (!beanDefinition.getMetadata().isAnnotation()) &#123; isCandidate = true; &#125; &#125; return isCandidate; &#125;&#125;; 这个对象的作用就是进行包扫描的，接着 12AnnotationTypeFilter annotationTypeFilter = new AnnotationTypeFilter(FeignClient.class);scanner.addIncludeFilter(annotationTypeFilter); 就是限定了能被扫描到的类必须有FeignClient注解。 剩下的代码完成了两个功能 获取需要扫描的包 完成对应的BeanDefinition的注册 先看获取需要扫描的包，这里分两种情况： @EnableFeignClients的clients属性为空 这种情况下走到这段代码 123456789101112131415161718final Set&lt;String&gt; clientClasses = new HashSet&lt;&gt;();basePackages = new HashSet&lt;&gt;();for (Class&lt;?&gt; clazz : clients) &#123; basePackages.add(ClassUtils.getPackageName(clazz)); clientClasses.add(clazz.getCanonicalName());&#125;// 这里多了个限制，就是扫描到的类必须是@EnableFeignClients的`clients`属性所指定的类AbstractClassTestingTypeFilter filter = new AbstractClassTestingTypeFilter() &#123; @Override protected boolean match(ClassMetadata metadata) &#123; String cleaned = metadata.getClassName().replaceAll(&quot;\\\\$&quot;, &quot;.&quot;); return clientClasses.contains(cleaned); &#125;&#125;;// annotationTypeFilter在前边创建了// 而AllTypeFilter的作用其实就是通知执行filter和annotationTypeFilter的match方法scanner.addIncludeFilter( new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter))); 这里段代码的作用其实就是加了限制，就是扫描到的类必须是@EnableFeignClients的clients属性所指定的类。 @EnableFeignClients的clients属性不为空 12345678910111213141516171819202122232425262728scanner.addIncludeFilter(annotationTypeFilter);basePackages = getBasePackages(metadata);protected Set&lt;String&gt; getBasePackages(AnnotationMetadata importingClassMetadata) &#123; Map&lt;String, Object&gt; attributes = importingClassMetadata .getAnnotationAttributes(EnableFeignClients.class.getCanonicalName()); Set&lt;String&gt; basePackages = new HashSet&lt;&gt;(); for (String pkg : (String[]) attributes.get(&quot;value&quot;)) &#123; if (StringUtils.hasText(pkg)) &#123; basePackages.add(pkg); &#125; &#125; for (String pkg : (String[]) attributes.get(&quot;basePackages&quot;)) &#123; if (StringUtils.hasText(pkg)) &#123; basePackages.add(pkg); &#125; &#125; for (Class&lt;?&gt; clazz : (Class[]) attributes.get(&quot;basePackageClasses&quot;)) &#123; basePackages.add(ClassUtils.getPackageName(clazz)); &#125; if (basePackages.isEmpty()) &#123; basePackages.add( ClassUtils.getPackageName(importingClassMetadata.getClassName())); &#125; return basePackages;&#125; 处理@EnableFeignClients剩下的属性，value和basePackages作用都是一样的，传入的值也是包，而basePackageClasses属性传入的Class对象数组，在处理该属性时，只是获取了该Class对象的所在的包，不管其Class对象。 最后，如果没有这些属性，会把@EnableFeignClients注解的类所在的包作为扫描包 获取了需要扫描的包basePackages后，就是进行遍历了，把有FeignClient注解的类扫描出来后会执行下面的代码来 1234Map&lt;String, Object&gt; attributes = annotationMetadata.getAnnotationAttributes(FeignClient.class.getCanonicalName());String name = getClientName(attributes);registerClientConfiguration(registry, name, attributes.get(&quot;configuration&quot;)); 处理FeignClient注解的name和configuration属性，往Spring上下文注解对应服务的FeignClientSpecification。 接着就是要注册一个FeignClientFactoryBean，一些属性从FeignClient注解中获取。而这个FeignClientFactoryBean是FactoryBean接口的实现类。 12345678910111213141516171819202122232425262728293031323334353637383940private void registerFeignClient(BeanDefinitionRegistry registry, AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123; String className = annotationMetadata.getClassName(); BeanDefinitionBuilder definition = BeanDefinitionBuilder .genericBeanDefinition(FeignClientFactoryBean.class); validate(attributes); definition.addPropertyValue(&quot;url&quot;, getUrl(attributes)); definition.addPropertyValue(&quot;path&quot;, getPath(attributes)); String name = getName(attributes); definition.addPropertyValue(&quot;name&quot;, name); // 上边的name是服务的名字，这个contextId属性是服务对应的上下的id，如果在FeignClient没有设置contextId属性，那该值就是name // 如果contextId和name属性都没有，那么在bean的初始化阶段会报错 String contextId = getContextId(attributes); definition.addPropertyValue(&quot;contextId&quot;, contextId); definition.addPropertyValue(&quot;type&quot;, className); definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;)); definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;)); definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;)); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); String alias = contextId + &quot;FeignClient&quot;; AbstractBeanDefinition beanDefinition = definition.getBeanDefinition(); // 这里设置一个属性，用来确定FactoryBean 的 bean 类型 beanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, className); // has a default, won&#x27;t be null boolean primary = (Boolean) attributes.get(&quot;primary&quot;); beanDefinition.setPrimary(primary); // 别名 String qualifier = getQualifier(attributes); if (StringUtils.hasText(qualifier)) &#123; alias = qualifier; &#125; BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className, new String[] &#123; alias &#125;); BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);&#125; 服务代理类的生成——FeignClientFactoryBean通过上边的准备，服务环境的管理类FeignContext已经初始化完成，包含了每一个服务客户端所需的对象。 最终服务客户端的代理类是由FeignClientFactoryBean来完成的，他是一个FactoryBean 12345678910111213141516171819202122232425262728293031323334353637383940public Object getObject() throws Exception &#123; return getTarget();&#125;// 获取动态代理类&lt;T&gt; T getTarget() &#123; FeignContext context = applicationContext.getBean(FeignContext.class); Feign.Builder builder = feign(context); if (!StringUtils.hasText(url)) &#123; // 这是需要均衡负载的情况 if (!name.startsWith(&quot;http&quot;)) &#123; url = &quot;http://&quot; + name; &#125; else &#123; url = name; &#125; url += cleanPath(); return (T) loadBalance(builder, context, new HardCodedTarget&lt;&gt;(type, name, url)); &#125; // 这是不需要均衡负载的情况 if (StringUtils.hasText(url) &amp;&amp; !url.startsWith(&quot;http&quot;)) &#123; url = &quot;http://&quot; + url; &#125; String url = this.url + cleanPath(); Client client = getOptional(context, Client.class); if (client != null) &#123; if (client instanceof LoadBalancerFeignClient) &#123; client = ((LoadBalancerFeignClient) client).getDelegate(); &#125; if (client instanceof FeignBlockingLoadBalancerClient) &#123; client = ((FeignBlockingLoadBalancerClient) client).getDelegate(); &#125; builder.client(client); &#125; Targeter targeter = get(context, Targeter.class); return (T) targeter.target(this, builder, context, new HardCodedTarget&lt;&gt;(type, name, url));&#125; 这里只考虑需要均衡负载的情况 上边的代码就是做了下面的工作 12345678910111213141516171819202122RemoteService service = Feign.builder() .logger(new Slf4jLogger(RemoteService.class)) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) // 支持Spring mvc注解 .contract(new SpringMvcContract()) // 支持Feign原生注解 //.contract(new Contract.Default()) // 超时时间，连接超时10s，读取超时60s .options(new Request.Options(10000, TimeUnit.MILLISECONDS, 60000, TimeUnit.MILLISECONDS, true)) // 设置重试策略 // 这里不是必须的，如果这里不设置，默认采用的就是这个， // 第一个参数是间隔，第二个就是最大的重试间隔，第三个就是最大的重试次数 // 每次的重试间隔的计算如下 // long interval = (long)((double)this.period * Math.pow(1.5D, (double)(this.attempt - 1))); // interval &gt; this.maxPeriod ? this.maxPeriod : interval; // 其实就是 interval = period * 1.5^(重试次数-1) // 在Spring Cloud项目中，默认是不开启重试的，可以根据需要是否使用Retryer.Default，还是自己重写 .retryer(new Retryer.Default(5000, 5000, 3)) // 指明接口和服务 .target(RemoteService.class, &quot;http://localhost:8020/&quot;); 除了上边的代码，有2个方法和一组默认值需要说名下： configureFeign，该方法就是根据配置来修改Feign.Builder对象。 这里定义的yaml配置和注解配置的优先级，看下面的注释就好了： 1234567891011121314151617181920212223242526272829303132333435protected void configureFeign(FeignContext context, Feign.Builder builder) &#123; // 获取feign的yaml配置接收对象 FeignClientProperties properties = applicationContext.getBean(FeignClientProperties.class); // 获取FeignClientConfigurer，该接口的作用就是是否启用feign的yaml配置的功能，默认是启动的 FeignClientConfigurer feignClientConfigurer = getOptional(context, FeignClientConfigurer.class); setInheritParentContext(feignClientConfigurer.inheritParentConfiguration()); if (properties != null &amp;&amp; inheritParentContext) &#123; if (properties.isDefaultToProperties()) &#123; // 如果配置文件有feign.client.defaultToPropertie=true, 就会走到这里，默认是进入到该代码段的 // 下面配置顺序是：自己服务的spring上下--feign.client.default--feign.client.服务名 configureUsingConfiguration(context, builder); configureUsingProperties( properties.getConfig().get(properties.getDefaultConfig()), builder); configureUsingProperties(properties.getConfig().get(contextId), builder); &#125; else &#123; // 如果配置文件有feign.client.defaultToPropertie=false, 就会走到这这里 // 下面配置顺序是feign.client.default--feign.client.服务名--自己服务的spring上下 configureUsingProperties( properties.getConfig().get(properties.getDefaultConfig()), builder); configureUsingProperties(properties.getConfig().get(contextId), builder); configureUsingConfiguration(context, builder); &#125; &#125; else &#123; // 走到这里，意味着初始化了一个FeignClientConfigurer对象，该对象返回了false // 表示不使用配置文件的配置，只使用spring上下的 configureUsingConfiguration(context, builder); &#125;&#125; 上边的配置feign.client.default中的default是能修改的，通过feign.client.defaultConfig修改，看FeignClientProperties就明白了 loadBalance，该方法添加支持均衡负载的feign.Client对象，并得到对应服务客户端的代理对象 123456789101112protected &lt;T&gt; T loadBalance(Feign.Builder builder, FeignContext context, HardCodedTarget&lt;T&gt; target) &#123; Client client = getOptional(context, Client.class); if (client != null) &#123; builder.client(client); Targeter targeter = get(context, Targeter.class); return targeter.target(this, builder, context, target); &#125; throw new IllegalStateException( &quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-netflix-ribbon?&quot;);&#125; 代码很简单，这里要说名的是默认情况下feign.Client就是LoadBalancerFeignClient。这个类就是处理负载均衡和HTTP请求的核心，后面讲 Targeter接口其实目的很简单，就是获取代理对象，使用的是JDK的动态代理。 feign调用时的connectTimeout和readTimeout 这两个值在FeignClientFactoryBean初始化时给了一组默认值 123456private int readTimeoutMillis = new Request.Options().readTimeoutMillis();private int connectTimeoutMillis = new Request.Options().connectTimeoutMillis();public Options() &#123; this(10L, TimeUnit.SECONDS, 60L, TimeUnit.SECONDS, true);&#125; 默认情况下是connectTimeout&#x3D;10s，readTimeout&#x3D;60s。 可以往Spring注入一个Request.Options类来完成全局配置，或者通过feign.client.default配置，还可以通过feign.client.服务名来对服务单独配置 服务调用从上边知道，服务代理类是通过JDK的动态代理生成的，通过Feign.Builder.target就很容易的知道代理对象的InvocationHandler是哪一类。看Feign.Builder.target： 12345678910111213141516171819202122public &lt;T&gt; T target(Target&lt;T&gt; target) &#123; return this.build().newInstance(target);&#125;public Feign build() &#123; Client client = (Client)Capability.enrich(this.client, this.capabilities); Retryer retryer = (Retryer)Capability.enrich(this.retryer, this.capabilities); ..... Options options = (Options)Capability.enrich(this.options, this.capabilities); // 这段代码的作用就是为了执行Capability对象中的 // Encoder enrich(Encoder encoder) &#123; // return encoder; // &#125; // 方法。其他都差不多，看下Capability的定义就能明白了 Encoder encoder = (Encoder)Capability.enrich(this.encoder, this.capabilities); Decoder decoder = (Decoder)Capability.enrich(this.decoder, this.capabilities); // this.invocationHandlerFactory = new feign.InvocationHandlerFactory.Default(); InvocationHandlerFactory invocationHandlerFactory = (InvocationHandlerFactory)Capability.enrich(this.invocationHandlerFactory, this.capabilities); ..... return new ReflectiveFeign(handlersByName, invocationHandlerFactory, queryMapEncoder);&#125; 创建代理类的代码在ReflectiveFeign#newInstance中，这里不看了源码了，说下流程 把接口的default方法封装成DefaultMethodHandler，把接口的抽象方法封装成SynchronousMethodHandler。并把这些保存到集合: 1Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap(); 中，最后把这个Map作为参数传入ReflectiveFeign.FeignInvocationHandler这个InvocationHandler对象中。这个InvocationHandler代码也很简单，整个方法调用的逻辑都在对应的MethodHandler中。DefaultMethodHandler就是直接调用对象的方法，没什么要讲的，而SynchronousMethodHandler就是服务调用的核心。调用流程如下： 而Client又是服务调用的重中之重，通过前面知道了Client的对象为LoadBalancerFeignClient。下面看LoadBalancerFeignClient feign.Client——LoadBalancerFeignClient下面是LoadBalancerFeignClient对象的构造方法 1234567public LoadBalancerFeignClient(Client delegate, CachingSpringLoadBalancerFactory lbClientFactory, SpringClientFactory clientFactory) &#123; this.delegate = delegate; this.lbClientFactory = lbClientFactory; this.clientFactory = clientFactory;&#125; LoadBalancerFeignClient对象就是Feign的服务代理对象处理HTTP请求的Client对象，从它的构造方法可以看出，它其实就是装饰类，最终处理HTTP请求的就是构造时传入的Client对象，类型通过配置决定，默认是Client.Default，它是通过HttpURLConnection完成http请求的 LoadBalancerFeignClient作为装饰类，提供了使用Ribbon实现负载均衡的功能。 123456789101112131415161718192021222324// LoadBalancerFeignClient@Overridepublic Response execute(Request request, Request.Options options) throws IOException &#123; try &#123; URI asUri = URI.create(request.url()); String clientName = asUri.getHost(); URI uriWithoutHost = cleanUrl(request.url(), clientName); FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest( this.delegate, request, uriWithoutHost); // 这里是将Feign配置 IClientConfig requestConfig = getClientConfig(options, clientName); // 这里就实现了负载均衡和处理HTTP return lbClient(clientName) .execueWithLoadBalancer(ribbonRequest, requestConfig).toResponse(); &#125; catch (ClientException e) &#123; IOException io = findIOException(e); if (io != null) &#123; throw io; &#125; throw new RuntimeException(e); &#125;&#125; 而处理HTTP请求的Client，可以通过配置来选择和配置，详细配置看配置类FeignRibbonClientAutoConfiguration和FeignAutoConfiguration即可. 1lbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse(); 其中lbClient方法如下 123private FeignLoadBalancer lbClient(String clientName) &#123; return this.lbClientFactory.create(clientName);&#125; lbClientFactory是CachingSpringLoadBalancerFactory对象，它只做了一件事，就是创建并缓存FeignLoadBalancer对象。CachingSpringLoadBalancerFactory对象会作为参数，传入LoadBalancerFeignClient对象中。上边的LoadBalancerFeignClient#execute方法的最后调用FeignLoadBalancer对象。而FeignLoadBalancer#executeWithLoadBalancer方法的作用就是完成均衡负载和HTTP请求的处理。 FeignLoadBalancerFeignLoadBalancer是符合Ribbon的规范 FeignLoadBalancer对象的类图如下： 其中IClient是ribbon的接口，其作用只是关注的是HTTP请求的处理。而AbstractLoadBalancerAwareClient抽象类作为IClient的抽象实现类，添加了均衡负载的功能。AbstractLoadBalancerAwareClient类中的executeWithLoadBalancer方法完成两件事 先做均衡负载 根据第一步得到的服务实例，完成HTTP请求的处理，也就是调用IClient实现类的对象的execute方法 其源码如下： 123456789101112131415161718192021222324252627282930public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123; LoadBalancerCommand&lt;T&gt; command = buildLoadBalancerCommand(request, requestConfig); try &#123; return command.submit( new ServerOperation&lt;T&gt;() &#123; @Override public Observable&lt;T&gt; call(Server server) &#123; URI finalUri = reconstructURIWithServer(server, request.getUri()); S requestForServer = (S) request.replaceUri(finalUri); try &#123; return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig)); &#125; catch (Exception e) &#123; return Observable.error(e); &#125; &#125; &#125;) .toBlocking() .single(); &#125; catch (Exception e) &#123; Throwable t = e.getCause(); if (t instanceof ClientException) &#123; throw (ClientException) t; &#125; else &#123; throw new ClientException(e); &#125; &#125; &#125; 而FeignLoadBalancer继承了AbstractLoadBalancerAwareClient类，均衡负载的代码已经从AbstractLoadBalancerAwareClient继承了，剩下的只是如何完成HTTP请求的处理，所以看它的execute方法 123456789101112131415@Overridepublic RibbonResponse execute(RibbonRequest request, IClientConfig configOverride) throws IOException &#123; Request.Options options; if (configOverride != null) &#123; RibbonProperties override = RibbonProperties.from(configOverride); options = new Request.Options(override.connectTimeout(this.connectTimeout), override.readTimeout(this.readTimeout)); &#125; else &#123; options = new Request.Options(this.connectTimeout, this.readTimeout); &#125; Response response = request.client().execute(request.toRequest(), options); return new RibbonResponse(request.getUri(), response);&#125; 代码很简单，最后只是调用Client.Default了 总结","categories":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/categories/springcloud/"},{"name":"feign","slug":"springcloud/feign","permalink":"http://sv.pointcut.cc/categories/springcloud/feign/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/tags/springcloud/"}]},{"title":"微服务调用组件Feign","slug":"springcloud/06-微服务调用组件Feign","date":"2022-03-14T09:09:11.123Z","updated":"2022-03-14T09:09:11.123Z","comments":true,"path":"blog/springcloud/06-微服务调用组件Feign/","link":"","permalink":"http://sv.pointcut.cc/blog/springcloud/06-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%BB%84%E4%BB%B6Feign/","excerpt":"","text":"微服务调用组件Feign spring cloud 的openFeign还引入了ribbon的包 JAVA 项目中如何实现接口调用？ Httpclien HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 Http 协议的客户端编程工具包，并且它支持 HTTP 协议最新版本和建议。HttpClient 相比传统 JDK 自带的 URLConnection，提升了易用性和灵活性，使客户端发送 HTTP 请求变得容易，提高了开发的效率 Okhttp 一个处理网络请求的开源项目，是安卓端最火的轻量级框架，由 Square 公司贡献，用于替代 HttpUrlConnection 和 Apache HttpClient。OkHttp 拥有简洁的 API、高效的性能，并支持多种协议（HTTP&#x2F;2 和 SPDY）。 HttpURLConnection HttpURLConnection 是 Java 的标准类，它继承自 URLConnection，可用于向指定网站发送 GET 请求、POST 请求。HttpURLConnection 使用比较复杂，不像 HttpClient 那样容易使用 RestTemplate RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 HTTP 服务的方法，能够大大提高客户端的编写效率。 WebClient WebClient是从Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行Http请求的客户端工具。它的响应式编程的基于Reactor的。WebClient中提供了标准Http请求方式对应的get、post、put、delete等方法，可以用来发起相应的请求。 上面介绍的是最常见的几种调用接口的方法，我们下面要介绍的方法比上面的更简单、方便，它就是 Feign。 什么是FeignFeign是Netflix开发的声明式、模板化的HTTP客户端，其灵感来自Retrofit、JAXRS-2.0以及WebSocket。Feign可帮助我们更加便捷、优雅地调用HTTP API。 Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等 Feign与openfeign的区别Spring Cloud openfeign对Feign进行了增强，使其支持Spring MVC注解，另外还整合了Ribbon和Eureka，从而使得Feign的使用更加方便 Feignd的优势Feign可以做到使用 HTTP 请求远程服务时就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。 Feign的设计架构 Feign的调用方式在上节中讲了 Ribbon，这是一个负载均衡框架，通过 123456789@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125;//调用方式String url = &quot;http://mall-order/order/findOrderByUserId/&quot;+id;R result = restTemplate.getForObject(url,R.class); 这种方式调用的。而Feign关注的点是服务的调用，也就是怎么调用一个服务（可以看成是一个HTTP客户端）。通过RestTemplate的调用方式虽然可以完成服务的调用。但这种方式并不优雅，涉及到了太多调用细节了。而Feign进行微服务调用方式如下（准确来讲，是openFeign）： 服务提供方配置： 12345678spring: application: name: mall-order #微服务名称 #配置nacos注册中心地址 cloud: nacos: discovery: server-addr: 127.0.0.1:8848 服务： 123456789101112131415161718@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @Autowired private OrderService orderService; /** * 根据用户id查询订单信息 * @param userId * @return */ @RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;) public R findOrderByUserId(@PathVariable(&quot;userId&quot;) Integer userId) &#123; log.info(&quot;根据userId:&quot;+userId+&quot;查询订单信息&quot;); List&lt;OrderEntity&gt; orderEntities = orderService.listByUserId(userId); return R.ok().put(&quot;orders&quot;, orderEntities); &#125;&#125; 启动： 12345678910@SpringBootApplication// 完成服务的注册@EnableDiscoveryClientpublic class MallOrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MallOrderApplication.class, args); &#125;&#125; 服务消费方服务定义： 12345678// 在项目中，该接口是作为一个共工包被服务提供者和消费者引入// 对于服务提供者，能知道提供什么服务和服务的uri（实现类的@RequestMapping必须和接口的一致）// 对于服务消费者，@FeignClient的注解就有用了，能在启动接口完成代理类的生成@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)public interface OrderFeignService &#123; @RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;) public R findOrderByUserId(@PathVariable(&quot;userId&quot;) Integer userId);&#125; 项目启动： 123456789@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DruidDataSourceAutoConfigure.class&#125;)@EnableFeignClientspublic class MallUserFeignDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MallUserFeignDemoApplication.class, args); &#125;&#125; 服务调用： 12345// 服务调用@AutowiredOrderFeignService orderFeignService;//feign调用R result = orderFeignService.findOrderByUserId(id); Feign可以做到使用 HTTP 请求远程服务时就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。它像 Dubbo 一样，consumer 直接调用接口方法调用 provider。 Feign单独使用1234567891011&lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-core&lt;/artifactId&gt; &lt;version&gt;8.18.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 编码解码 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-jackson&lt;/artifactId&gt; &lt;version&gt;8.18.0&lt;/version&gt;&lt;/dependency&gt; 编写接口 12345678// 这里定义的是服务接口// 服务提供方不一定要实现这个接口，可以只提供一个对应的http请求即可。参数也不一定要完全一样，只要能被SpringMVC的消息转换器能转换就可以了public interface RemoteService &#123; @Headers(&#123;&quot;Content-Type: application/json&quot;,&quot;Accept: application/json&quot;&#125;) @RequestLine(&quot;GET /order/findOrderByUserId/&#123;userId&#125;&quot;) public R findOrderByUserId(@Param(&quot;userId&quot;) Integer userId);&#125; 调用 12345678910111213141516171819202122232425262728293031public class FeignDemo &#123; public static void main(String[] args) &#123; // 就是获取动态代理对象而已 // 基于json // encoder指定对象编码方式，decoder指定对象解码方式 RemoteService service = Feign.builder() .logger(new Slf4jLogger(RemoteService.class)) .encoder(new JacksonEncoder()) .decoder(new JacksonDecoder()) // 支持Spring mvc注解 .contract(new SpringMvcContract()) // 支持Feign原生注解 //.contract(new Contract.Default()) // 超时时间，连接超时10s，读取超时60s .options(new Request.Options(10000, TimeUnit.MILLISECONDS, 60000, TimeUnit.MILLISECONDS, true)) // 设置重试策略 // 这里不是必须的，如果这里不设置，默认采用的就是这个， // 第一个参数是间隔，第二个就是最大的重试间隔，第三个就是最大的重试次数 // 每次的重试间隔的计算如下 // long interval = (long)((double)this.period * Math.pow(1.5D, (double)(this.attempt - 1))); // interval &gt; this.maxPeriod ? this.maxPeriod : interval; // 其实就是 interval = period * 1.5^(重试次数-1) // 在Spring Cloud项目中，默认是不开启重试的，可以根据需要是否使用Retryer.Default，还是自己重写 .retryer(new Retryer.Default(5000, 5000, 3)) // 指明接口和服务 .target(RemoteService.class, &quot;http://localhost:8020/&quot;); &#125;&#125; Spring Cloud Alibaba快速整合Feign——也就是openFeign引入依赖12345&lt;!-- openfeign 远程调用 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 编写调用接口+@FeignClient注解123456789// 定义服务接口// 同样的，服务提供方不一定要实现这个接口，可以只提供一个对应的http请求即可。// 这是SpringCloud的标准。上边使用了Feign的标准@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)public interface OrderFeignService &#123; @RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;) public R findOrderByUserId(@PathVariable(&quot;userId&quot;) Integer userId);&#125; 在@FeignClient注解中，有个url属性，这个属性的值就是指定具体的服务的url。指定有，底层调用就不走ribbon的均衡负载了。这种模式通常使用在测试时。 调用端在启动类上添加@EnableFeignClients注解1234567@SpringBootApplication@EnableFeignClientspublic class MallUserFeignDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MallUserFeignDemoApplication.class, args); &#125;&#125; @EnableFeignClients注解就是为了引入FeignClientsRegistrar类和指明服务接口类的包而已。 FeignClientsRegistrar这个类的为了扫描有@FeignClient注解的接口而已，最终会通过FeignClientFactoryBean这个FactoryBean来获取到真实的代理对象。 发起调用，像调用本地方式一样调用远程服务1234567891011121314@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private OrderFeignService orderFeignService; @RequestMapping(value = &quot;/findOrderByUserId/&#123;id&#125;&quot;) public R findOrderByUserId(@PathVariable(&quot;id&quot;) Integer id) &#123; //feign调用 R result = orderFeignService.findOrderByUserId(id); return result; &#125;&#125; Spring Cloud Feign的自定义配置及使用 Feign 提供了很多的扩展机制，让用户可以更加灵活的使用。 feign的yaml配置可以看类FeignClientProperties. feign通过配置类的配置可以看类FeignClientsConfiguration来了解扩展点有哪些 配置模式openFeigin的配置方式和ribbon的配置模式很像 全局配置 1234567@Configuration // 全局配置public class FeignConfig &#123; @Bean public Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125; 全局配置的优先级是最高的 局部配置 配置类 12345678910111213public class FeignConfig &#123; @Bean public Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125;@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;,configuration = FeignConfig.class)public interface OrderFeignService &#123; @RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;) R findOrderByUserId(@PathVariable(&quot;userId&quot;) Integer userId);&#125; FeignConfig不能被spring自动扫描到，否则会变成全局配置 yaml配置 123456feign: client: config: mall-order: #对应微服务 loggerLevel: FULL ...... 推荐使用这种方式 默认配置 @EnableFeignClients注解的basePackageClasses属性 1@EnableFeignClients(defaultConfiguration = &#123;FeignConfig.class&#125;) yaml配置 123456feign: client: config: default: # defaule是能修改的，通过feign.client.defaultConfig修改，它的默认值为default loggerLevel: FULL ...... 这3种配置方式又可以细分为注解和yaml文件，所以一共有5种配置方式。 在注解的配置方式下，全局配置的优先级是最高的，然后是局部配置，最后是默认配置。这是由Spring cloud项目在类NamedContextFactory中所定义的。这是Spring cloud的一个规范。而yaml配置就没有强制要求了，这要看要具体项目的定义。但有一点是确定的，就是在使用yaml配置时，某个服务的上下文已经根据注解方式的优先级完成了对起上下文的初始化，这时某些对象的配置已经确定了。 上面要求配置类都没有实现Order接口和没有@Order注解 在openFeign中yaml的配置与注解配置的优先级要分3中情况讨论，其代码在FeignClientFactoryBean类的configureFeign方法中。这里就只看默认情况下： 优先级最高的是局部配置的yaml方式 其次默认配置的yaml方式 最低的就是注解方式了。注解方式又按优先级高低，分为全局配置、局部配置最后是默认配置。 日志配置有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的日志了，以此让 Feign 把请求信息输出来。 定义一个配置类，指定日志级别 12345678910111213// 注意： 此处配置@Configuration注解就会全局生效，如果想指定对应微服务生效，就不能配置// 加了@Configuration就是全局配置了public class FeignConfig &#123; /** * 日志级别 * * @return */ @Bean public Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125;&#125; 通过源码可以看到日志等级有 4 种，分别是： NONE【性能最佳，适用于生产】：不记录任何日志（默认值）。 BASIC【适用于生产环境追踪问题】：仅记录请求方法、URL、响应状态代码以及执行时间。 HEADERS：记录BASIC级别的基础上，记录请求和响应的header。 FULL【比较适用于开发及测试环境定位问题】：记录请求和响应的header、body和元数据。 局部配置 让调用的微服务生效，在@FeignClient 注解中指定使用的配置类 12345678910@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;,configuration = FeignConfig.class)public interface OrderFeignService &#123; @RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;) R findOrderByUserId(@PathVariable(&quot;userId&quot;) Integer userId); @RequestMapping(value = &quot;/save&quot;,consumes = MediaType.APPLICATION_JSON_VALUE) R save(@RequestBody OrderVo order);&#125; 或者在yml中配置 12345feign: client: config: mall-order: #对应微服务 loggerLevel: FULL 建议使用配置文件的方式配置。 在yml配置文件添加执行 Client 的日志级别才能正常输出日志，格式是”logging.level.feign接口包路径&#x3D;debug” 1234logging: level: # 包名 com.tuling.mall.feigndemo.feign: debug 测试 契约配置 这里的契约指的是feign的Contract接口，该接口的作用就是指定Feign使用的是哪些注解。 Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，如果你想在 Spring Cloud 中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract。 修改契约配置，支持Feign原生的注解 12345678/** * 修改契约配置，支持Feign原生的注解 * @return */@Beanpublic Contract feignContract() &#123; return new Contract.Default();&#125; 或者 通过yml配置契约 123456feign: client: config: mall-order: #对应微服务 loggerLevel: FULL contract: feign.Contract.Default #指定Feign原生注解契约配置 推荐使用配置文件 &#x3D;&#x3D;注意：修改契约配置后，OrderFeignService 不再支持springmvc的注解，需要使用Feign原生的注解&#x3D;&#x3D; OrderFeignService 中配置使用Feign原生的注解 12345@FeignClient(value = &quot;mall-order&quot;,path = &quot;/order&quot;)public interface OrderFeignService &#123; @RequestLine(&quot;GET /findOrderByUserId/&#123;userId&#125;&quot;) public R findOrderByUserId(@Param(&quot;userId&quot;) Integer userId);&#125; 既然都使用Spring Cloud了，就使用SpringMVC的就好了。 通过拦截器实现认证——feign.RequestInterceptor通常我们调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，完成接口鉴权。比如 Basic 认证方式： Feign 中我们可以直接配置 1234567@Configuration // 全局配置public class FeignConfig &#123; @Bean public BasicAuthRequestInterceptor basicAuthRequestInterceptor() &#123; return new BasicAuthRequestInterceptor(&quot;fox&quot;, &quot;123456&quot;); &#125;&#125; 扩展点： feign.RequestInterceptor上边展示了生成Basic认证信息的拦截器，这个拦截器实现了feign.RequestInterceptor接口。而这个就是feign架构图中的Interceptors部分。每次 feign 发起http调用之前，会去执行拦截器中的逻辑。 1234567public interface RequestInterceptor &#123; /** * Called for every request. Add data using methods on the supplied &#123;@link RequestTemplate&#125;. */ void apply(RequestTemplate template);&#125; 使用场景 统一添加 header 信息； 对 body 中的信息做修改或替换； 自定义拦截器实现认证逻辑12345678public class FeignAuthRequestInterceptor implements RequestInterceptor &#123; @Override public void apply(RequestTemplate template) &#123; // 业务逻辑 String access_token = UUID.randomUUID().toString(); template.header(&quot;Authorization&quot;, access_token); &#125;&#125; 配置 全局配置 123456789101112131415@Configuration // 全局配置public class FeignConfig &#123; @Bean public Logger.Level feignLoggerLevel() &#123; return Logger.Level.FULL; &#125; /** * 自定义拦截器 * @return */ @Bean public FeignAuthRequestInterceptor feignAuthRequestInterceptor()&#123; return new FeignAuthRequestInterceptor(); &#125;&#125; 在yml中配置 123456feign: client: config: mall-order: #对应微服务 或者使用default作为默认的配置 requestInterceptors[0]: #配置拦截器 com.tuling.mall.feigndemo.interceptor.FeignAuthRequestInterceptor 推荐这种模式 超时时间配置Java配置方式通过 Options 可以配置连接超时时间和读取超时时间，Options 的第一个参数是连接的超时时间（ms），默认值是 2s；第二个是请求处理的超时时间（ms），默认值是 5s。 1234567@Configurationpublic class FeignConfig &#123; @Bean public Request.Options options() &#123; return new Request.Options(5000, 10000); &#125;&#125; yml中配置12345678feign: client: config: mall-order: #对应微服务 # 连接超时时间，默认2s connectTimeout: 5000 # 请求处理超时时间，默认5s readTimeout: 10000 补充说明： Feign的的Client部分会使用到Ribbon的均衡负载，而Ribbon的均衡负载有超时时间，这个超时时间以Feign配置为准 客户端组件配置——feign.Client#executeFeign 中默认使用 JDK 原生的 URLConnection 发送 HTTP 请求，我们可以集成别的组件来替换掉 URLConnection，比如 Apache HttpClient，OkHttp。 Feign发起调用真正执行逻辑：feign.Client#execute （扩展点） 到底使用哪个实现，可以看FeignRibbonClientAutoConfiguration配置类（使用Ribbon做均衡负载的时候，如果是使用Spring cloud标准的loadBlance，那就看FeignLoadBalancerAutoConfiguration） 其中@Import的顺序决定Client对象的优先级，优先级最高的是HttpClient，其次是OkHttp，最低的是Default也就是URLConnection 配置Apache HttpClient1234567891011&lt;!-- Apache HttpClient --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt; &lt;version&gt;10.1.0&lt;/version&gt;&lt;/dependency&gt; 然后修改yml配置，将 Feign 的Apache HttpClient启用 ： 1234feign: #feign 使用 Apache HttpClient 可以忽略，默认开启 httpclient: enabled: true 关于配置可参考源码： org.springframework.cloud.openfeign.FeignAutoConfiguration 调用会进入feign.httpclient.ApacheHttpClient#execute 配置 OkHttp1234&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 然后修改yml配置，将 Feign 的 HttpClient 禁用，启用 OkHttp，配置如下： 123456feign: #feign 使用 okhttp httpclient: enabled: false okhttp: enabled: true 关于配置可参考源码： org.springframework.cloud.openfeign.FeignAutoConfiguration http client的配置无论使用的是Apache HttpClient还是OkHttp，这两个客户端的其他配置都是用了FeignHttpClientProperties类作为配置接收类。到底哪些属性生效，看HttpClientFeignLoadBalancedConfiguration中的初始化过程。 GZIP 压缩配置开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP 来压缩数据： 1234567891011feign: # 配置 GZIP 来压缩数据 compression: request: enabled: true # 配置压缩的类型 mime-types: text/xml,application/xml,application/json # 最小压缩值 min-request-size: 2048 response: enabled: true 注意：只有当 Feign 的 Http Client 不是 okhttp3 的时候，压缩才会生效，配置源码在FeignAcceptGzipEncodingAutoConfiguration 核心代码就是 @ConditionalOnMissingBean（type&#x3D;”okhttp3.OkHttpClient”），表示 Spring BeanFactory 中不包含指定的 bean 时条件匹配，也就是没有启用 okhttp3 时才会进行压缩配置。 编码器解码器配置——feign.Encoder &amp; feign.DecoderFeign 中提供了自定义的编码解码器设置，同时也提供了多种编码器的实现，比如 Gson、Jaxb、Jackson。我们可以用不同的编码解码器来处理数据的传输。如果你想传输 XML 格式的数据，可以自定义 XML 编码解码器来实现获取使用官方提供的 Jaxb。 扩展点：Encoder &amp; Decoder 123456public interface Encoder &#123; void encode(Object object, Type bodyType, RequestTemplate template) throws EncodeException;&#125;public interface Decoder &#123; Object decode(Response response, Type type) throws IOException, DecodeException, FeignException;&#125; Java配置方式12345678@Beanpublic Decoder decoder() &#123; return new JacksonDecoder();&#125;@Beanpublic Encoder encoder() &#123; return new JacksonEncoder();&#125; yml配置方式1234567feign: client: config: mall-order: #对应微服务 # 配置编解码器 encoder: feign.jackson.JacksonEncoder decoder: feign.jackson.JacksonDecoder 比较全的yaml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657server: port: 8055spring: application: name: mall-user-feign-demo #微服务名称 #配置nacos注册中心地址 cloud: nacos: discovery: server-addr: 127.0.0.1:8848ribbon: eager-load: # 开启ribbon饥饿加载 enabled: true # 配置mall-user使用ribbon饥饿加载，多个使用逗号分隔 clients: mall-orderlogging: level: com.tuling.mall.feigndemo.feign: debugfeign: client: config: mall-order: #对应微服务 loggerLevel: FULL contract: feign.Contract.Default #指定Feign原生注解契约配置 requestInterceptors[0]: #配置拦截器 com.tuling.mall.feigndemo.interceptor.FeignAuthRequestInterceptor 连接超时时间，默认2s connectTimeout: 3000 请求处理超时时间，默认5s readTimeout: 10000 配置编解码器 encoder: feign.jackson.JacksonEncoder decoder: feign.jackson.JacksonDecoder #feign 使用 okhttp httpclient: enabled: false okhttp: enabled: true # 配置 GZIP 来压缩数据 compression: request: enabled: true # 配置压缩的类型 mime-types: text/xml,application/xml,application/json # 最小压缩值 min-request-size: 2048 response: enabled: true 关于配置可参考源码： 12org.springframework.cloud.openfeign.FeignAutoConfigurationorg.springframework.cloud.openfeign.FeignRibbonClientAutoConfiguration feign.clent配置的接受类为FeignClientProperties。 feign.clent.config的配置的接受类为FeignClientConfiguration 而feign的client如论使用那个http客户端，其配置的接受类都为FeignHttpClientProperties 而GZIP配置的接受类为FeignAcceptGzipEncodingAutoConfiguration","categories":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/categories/springcloud/"},{"name":"feign","slug":"springcloud/feign","permalink":"http://sv.pointcut.cc/categories/springcloud/feign/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/tags/springcloud/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-03-14T09:09:11.122Z","updated":"2022-03-14T09:09:11.122Z","comments":true,"path":"blog/hello-world/","link":"","permalink":"http://sv.pointcut.cc/blog/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"markdown","slug":"markdown","permalink":"http://sv.pointcut.cc/categories/markdown/"}],"tags":[]},{"title":"Untitled","slug":"spring/SpringBoot/使用/Untitled","date":"2021-11-20T12:01:01.000Z","updated":"2022-03-14T09:04:26.899Z","comments":true,"path":"blog/spring/SpringBoot/使用/Untitled/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/%E4%BD%BF%E7%94%A8/Untitled/","excerpt":"","text":"","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"01-整合Servlet、Filter和Listener","slug":"spring/SpringBoot/使用/01-整合Servlet、Filter和Listener","date":"2021-11-20T12:01:00.000Z","updated":"2022-03-14T09:04:26.898Z","comments":true,"path":"blog/spring/SpringBoot/使用/01-整合Servlet、Filter和Listener/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/%E4%BD%BF%E7%94%A8/01-%E6%95%B4%E5%90%88Servlet%E3%80%81Filter%E5%92%8CListener/","excerpt":"","text":"整合Servlet、Filter和Listener只需要加上 1@ServletComponentScan(basePackages = &#123;&quot;com.xyz.demo&quot;&#125;) 这个注解就好了 然后在 Servlet、Filter、Listener 上面加入响应注解即可。如: 1234567891011121314151617181920212223242526272829@WebServlet(name=&quot;HelloServlet&quot;,urlPatterns = &quot;/HelloServlet&quot;,loadOnStartup = 1)public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.println(&quot;hello servlet!&quot;); &#125;&#125;@WebFilter(urlPatterns = &quot;/*&quot;,filterName = &quot;myFilter&quot;)public class MyFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;--------MyFilter----------&quot;); chain.doFilter(request,response); &#125;&#125;@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent contextEvent) &#123; System.out.println(&quot;contextDestroyed&quot;); &#125; @Override public void contextInitialized(ServletContextEvent contextEvent) &#123; System.out.println(&quot;contextInitialized&quot;); &#125;&#125; 还可以使用ServletListenerRegistrationBean、ServletRegistrationBean和FilterRegistrationBean","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"SpringBoot很好用的一组 Condition —— AllNestedConditions AnyNestedCondition NoneNestedConditions","slug":"spring/SpringBoot/SpringBoot很好用的一组 Condition —— AllNestedConditions AnyNestedCondition NoneNestedConditions","date":"2021-11-20T12:00:59.000Z","updated":"2022-03-14T09:04:26.897Z","comments":true,"path":"blog/spring/SpringBoot/SpringBoot很好用的一组 Condition —— AllNestedConditions AnyNestedCondition NoneNestedConditions/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/SpringBoot%E5%BE%88%E5%A5%BD%E7%94%A8%E7%9A%84%E4%B8%80%E7%BB%84%20Condition%20%E2%80%94%E2%80%94%20AllNestedConditions%20AnyNestedCondition%20NoneNestedConditions/","excerpt":"","text":"前言 SpringBoot 对 @Conditional 注解的拓展是十分漂亮的，也是 SpringBoot 式 API 设计 的代表作，本文介绍几个很好用的 Condition 拓展类，在这之前如果想要了解一下 Conditon 相关，可以阅读下文 【源码】Spring —— Condition 条件匹配解读 【源码】SpringBoot 对 Condition 的拓展 —— @ConditionalOnXxx系列注解 123456789101112关于什么叫做 SpringBoot 式 API 设计，这是我个人的理解：Spring 式 API，java API 设计的天花板，简单、优雅，最重要的是拥有无限的生命力（易拓展，不然也不会有 SpringBoot 了），“简单” 是指逻辑的实现相对简单（设计可一点都不简单）而且代码伴随着大量的注解，因此想潜心看还是有可能看懂的SpringBoot 式 API，同样是 java API 设计的天花板，但是逻辑实现是真的复杂，且伴随着 天马行空 的想象力，编码风格逐渐向 函数式编程 靠拢，且因为代码注解相对 Spring 少的多了，因此我认为逻辑能力如果不够强且没有足够的时间，真的看不懂一些 API 的实现逻辑（反正我看不懂，光一个Binder 我看了一周没看明白，放弃了） AllNestedConditions， 该类本身就是一个 Condition，因此可以直接作为条件注解 @Conditonal 的 value，但是它可以包含一组 Condition，且当前目标类要 match 这些所有 Conditon，才会被注册进去 如果不好理解，直接看示例 12345678910111213141516171819202122232425262728293031323334353637@Configurationpublic class ConditionConfig &#123; @Bean @Conditional(BorCCondition.class) public BorC borC() &#123; return new BorC(); &#125; static class BorCCondition extends AllNestedConditions &#123; public BorCCondition() &#123; super(ConfigurationPhase.REGISTER_BEAN); &#125; @ConditionalOnBean(B.class) class BCondition &#123; &#125; @ConditionalOnBean(C.class) class CCondition &#123; &#125; &#125; @Configuration static class Config &#123; @Bean public B b() &#123; return new B(); &#125; &#125;&#125; 示例中的 BorCCondition 包含了一组 Conditon，其中 BCondition 是容器中要有 B 的 bean实例，CConditon 亦然，同时 BorCCondition 是一个 AllNestedConditions，因此只有当 BCondition 和 CConditon 全都 match 时，BorC 的 bean实例 才会被注册到容器中 1至于为什么命名 BorCCondition 是因为我一开始写的 demo 是 AnyNestedCondition 如上示例中，BorC 的 bean实例 不会被注册，可以自己动手试试 AnyNestedCondition这就不难理解了，只要 match 其中任意 Condition，目标实例就会被注册 NoneNestedConditions只有不 match 所有 Conditon，目标实例才会被注册","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring Boot 2 官方指导手册译文","slug":"spring/SpringBoot/Spring Boot 2 官方指导手册译文","date":"2021-11-20T12:00:58.000Z","updated":"2022-03-14T09:04:26.897Z","comments":true,"path":"blog/spring/SpringBoot/Spring Boot 2 官方指导手册译文/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/Spring%20Boot%202%20%E5%AE%98%E6%96%B9%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C%E8%AF%91%E6%96%87/","excerpt":"","text":"Spring Boot 2 官方指导手册译文 官方文档 Spring Boot 2.3.9.RELEASE Reference Documentation Gradle 安装Spring Boot 与 Gradle 4 兼容。如果您还没有安装 Gradle，您可以按照 gradle.org 上的说明进行操作。 Spring Boot 依赖关系可以使用 org.springframework.boot group 声明。通常，你的项目向一个或多个启动器声明依赖关系。Spring Boot 提供了一个有用的 Gradle 插件，它可以用来简化依赖项声明并创建可执行的 jar。 Gradle Wrapper 当您需要构建一个项目时，Gradle Wrapper 提供了一种“获取”Gradle 的好方法。它是一个小脚本和库，您可以在代码旁边提交，以引导构建过程。有关详细信息，请参阅 docs.gradle.org&#x2F;4.2.1&#x2F;userguide&#x2F;gradle_wrapper.html。 下面的示例显示一个典型的 build.gradle 文件： 12345678910111213141516171819plugins &#123; id &#x27;org.springframework.boot&#x27; version &#x27;2.0.2.RELEASE&#x27; id &#x27;java&#x27;&#125;jar &#123; baseName = &#x27;myproject&#x27; version = &#x27;0.0.1-SNAPSHOT&#x27;&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)&#125; 从 Spring Boot 的一个早期的版本升级如果您正在从早期的 Spring Boot 版本升级，请检查提供详细的升级说明的“迁移指南”。还要检查发行说明，以获得每个版本的“新的和值得注意的”特性。 开发你的第一个 Spring Boot 应用程序本节描述如何开发一个简单的“Hello World!”web 应用程序突出了 Spring Boot 的一些关键特性。我们使用 Maven 来构建这个项目，因为大多数 IDE 都支持它。 spring.io 网站包含许多使用 Spring Boot 的“入门”指南。如果你需要解决一个具体的问题，先检查一下。 要简化下面的步骤，你可以去 start.spring.io 并从依赖关系搜索器中选择“Web”启动器。这样做会生成一个新的项目结构，这样您就可以立即开始编写代码。查看 Spring Initializr 文档了解更多细节。 在开始之前，打开一个终端并运行以下命令，以确保安装了有效的 Java 和 Maven 版本： 1234$ java -versionjava version &quot;1.8.0_102&quot;Java(TM) SE Runtime Environment (build 1.8.0_102-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode) 1234$ mvn -vApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T16:41:47+00:00)Maven home: /usr/local/Cellar/maven/3.3.9/libexecJava version: 1.8.0_102, vendor: Oracle Corporation 此示例需要在其自己的文件夹中创建。随后的指令假设您已经创建了一个合适的文件夹，并且它是您当前的目录。 创建 POM我们需要从创建一个 Maven pom.xml 文件开始。pom.xml 是用于构建你的项目的“食谱”。打开你喜欢的文本编辑器并添加如下内容： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 前面的清单应该给您一个生效的构建。您可以通过运行 mvn package 来测试它（现在，您可以忽略“jar will be empty - no content was marked for inclusion!”警告）。 此时，您可以将项目导入到 IDE 中（大多数现代 Java IDE 都包含对 Maven 的内置支持）。为了简单起见，我们继续使用这个示例的纯文本编辑器。 添加类路径依赖项Spring Boot 提供了一些“启动器”让你可以添加 jar 到你的类路径。我们的示例应用程序已经在 POM 的 parent 部分使用了 spring-boot-starter-parent。spring-boot-starter-parent 是一个特殊的启动器，它提供了有用的 Maven 默认值。它还提供了一个 dependency-management 部分，以便对于“有福的”依赖项你可以省略版本标记。 其它“启动器”提供在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个 web 应用程序，所以我们添加了一个 spring-boot-starter-web 依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容： 123$ mvn dependency:tree[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT mvn dependency:tree 命令打印你的项目依赖项的树型表示。您可以看到 spring-boot-starter-parent 本身不提供依赖项。要添加必要的依赖项，请编辑 pom.xml 并将 spring-boot-starter-web 依赖项立即添加到 parent 部分下方： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果你再次运行 mvn dependency:tree，您可以看到现在有许多额外的依赖项，包括 Tomcat web 服务器和 Spring Boot 本身。 编写你的代码要完成我们的应用程序，我们需要创建一个 Java 文件。默认情况下，Maven 从 src/main/java 编译源代码，因此您需要创建该文件夹结构，然后添加一个名为 src/main/java/Example.java 的文件，包含以下代码： 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(&quot;/&quot;) String home() &#123; return &quot;Hello World!&quot;; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 虽然这里没有多少代码，但仍有很多工作要做。我们将在接下来的几节中讨论重要的部分。 @RestController 和 @RequestMapping 注解 在我们的示例类上的第一个注解是 @RestController。这被称为构造型注解。它为阅读代码的人们提供了一些提示，并且为 Spring 提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以 Spring 在处理传入 web 请求时考虑它。 @RequestMapping 注解提供了“路由”信息。它告诉 Spring，任何带有 &#x2F; 路径的 HTTP 请求都应该映射到 home 方法。@RestController 注解告诉 Spring 将生成的字符串直接呈现给调用者。 @RestController 和 @RequestMapping 注解是 Spring MVC 注解。（它们不是特定于 Spring Boot 的。）有关更多详细信息，请参见 Spring 参考文档中的 MVC 部分。 @EnableAutoConfiguration 注解 第二个类级别注解是 @EnableAutoConfiguration。这个注解告诉 Spring Boot 去“猜测”您想如何配置 Spring，这基于您添加的 jar 依赖项。因为 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，所以自动配置假设您正在开发一个 web 应用程序，并相应地设置 Spring。 启动器和自动配置 自动配置被设计成与“启动器”很好地工作，但是这两个概念并没有直接关联。您可以自由地选择除启动器之外的 jar 依赖项。Spring Boot 仍然尽力地自动配置您的应用程序。 main 方法 我们的应用程序的最后一部分是 main 方法。这只是遵循应用程序入口点的 Java 约定的标准方法。通过调用 run，我们的 main 方法委托给 Spring Boot 的 SpringApplication 类。SpringApplication 引导我们的应用程序启动 Spring，而 Spring 又启动了自动配置的 Tomcat web 服务器。我们需要传递 Example.class 作为 run 方法的参数，以告诉 SpringApplication 它是主要的 Spring 组件。args 数组也被传递，以暴露任何命令行参数。 运行这个示例此时，您的应用程序应该可以工作了。因为您使用了 spring-boot-starter-parent POM，所以您有一个有用的 run 目标，您可以使用它来启动应用程序。 在根项目目录键入 mvn spring-boot:run 以启动应用程序。您应该会看到类似如下的输出： 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 如果你打开一个浏览器，访问 http://localhost:8080/，你应该会看见如下输出： 1Hello World! 要优雅地退出应用程序，按 ctrl-c。 创建一个可执行的 jar我们通过创建一个可以在生产中运行的完全自包含的可执行 jar 文件来完成我们的示例。可执行 jar（有时称为“fat jars”）是包含您的编译类的存档文件，以及您的代码需要运行所需的所有 jar 依赖项。 可执行的 jar 和 Java Java 没有提供加载嵌套 jar 文件的标准方法（jar 文件本身包含在一个 jar 中）。如果您希望分发一个自包含的应用程序，这可能会有问题。 为了解决这个问题，许多开发人员使用“uber”jar。一个 uber jar 将所有应用程序依赖项的所有类打包成一个归档文件。这种方法的问题在于，很难看到应用程序中有哪些库。如果在多个 jar 中使用相同的文件名（但使用不同的内容），也会有问题。 Spring Boot 采用了一种不同的方法，让您可以直接嵌套 jar。 要创建一个可执行 jar，我们需要将 spring-boot-maven-plugin 添加到我们的 pom.xml 中。要做到这一点，请在 dependencies 部分下面插入以下几行： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; spring-boot-starter-parent POM 包含 &lt;executions&gt; 配置以绑定 repackage 目标。如果您不使用父 POM，您需要自己声明这个配置。有关详细信息，请参见插件文档。 保存你的 pom.xml 并在命令行运行 mvn package，如下所示： 123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.0.2.RELEASE:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 如果你查看 target 目录内部，你应该会看到 myproject-0.0.1-SNAPSHOT.jar，这个文件应该差不多 10MB 大小。如果你想偷看里面的内容，你可以使用 jar tvf，如下所示： 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 你应该也会看见一个更小的名为 myproject-0.0.1-SNAPSHOT.jar.original 的文件在 target 目录下。这是在 Spring Boot 重新打包之前，Maven 创建的初始 jar 文件 。 要运行该应用程序，使用 java -jar 命令，如下所示： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 像前面一样，要退出该应用程序，按 ctrl-c。 下一步该读什么希望这一节提供了一些 Spring Boot 基础知识，并帮助您编写自己的应用程序。如果您是面向任务的开发人员，您可能想跳到 spring.io 并查看一些入门指南来解决具体的“我如何用 Spring 实现它？”问题。我们还有 Spring Boot 特有的“如何做”参考文档。 Spring Boot 存储库也有一些您可以运行的示例。这些示例与代码的其余部分无关（也就是说，您不需要构建其余的代码来运行或使用示例）。 否则，下一个逻辑步骤是阅读 *第三部分：“使用 Spring Boot”*。如果你真的很不耐烦，你也可以跳过，读一下 *Spring Boot 特性*。 使用 Spring Boot本节将详细讨论如何使用 Spring Boot。它涵盖了诸如构建系统、自动配置以及如何运行应用程序等主题。我们还介绍了一些 Spring Boot 最佳实践。尽管 Spring Boot 没有什么特别之处（它只是您可以使用的另一个库），但是有一些建议，在接下来的时候，使您的开发过程更容易一些。 如果您开始使用 Spring Boot，那么您应该在深入这一节之前阅读*入门*指南。 构建系统强烈建议您选择一个支持依赖管理的构建系统，并且可以使用发布到“Maven Central”存储库的工件。我们建议您选择 Maven 或 Gradle。可以让 Spring Boot 与其他构建系统（例如 Ant）一起工作，但是它们并不是特别受支持。 依赖管理Spring Boot 的每一个版本都提供了它所支持的一个被整理的依赖项列表。实际上，在构建配置中，您不需要为这些依赖项提供一个版本，因为 Spring Boot 为您管理这些依赖项。当您升级 Spring Boot 本身时，这些依赖项也会以一致的方式升级。 如果需要，您仍然可以指定一个版本并覆盖 Spring Boot 的建议。 策划列表包含了 Spring Boot 可以使用的所有 spring 模块以及第三方库的改进列表。这个列表可以作为一个标准的材料清单（spring-boot-dependencies），可以适用于 Maven 和 Gradle。 Spring Boot 的每个版本都与 Spring 框架的一个基本版本相关联。我们强烈建议您不要指定它的版本。 MavenMaven 用户可以从 spring-boot-starter-parent 项目继承来获得合理的默认值。父项目提供了以下特性： Java 1.8 作为默认编译等级 UTF-8 源码编码 一个依赖管理部分，继承自 spring-boot-dependencies pom，管理通用依赖项的版本。这个依赖管理允许你在自己的 pom 中使用这些依赖项时省略 &lt;version&gt; 标签 明智的资源过滤 明智的插件配置（exec plugin、Git commit ID 和 shade） 明智的用于 application.properties 和 application.yml 的包含特定 profile 文件的资源过滤（比如：application-dev.properties 和 application-dev.yml） 注意，由于 application.properties 和 application.yml 文件接受 Spring 风格的占位符 $&#123;…&#125;，Maven 过滤被更改为使用 @..@ 占位符。（你可以通过设置一个名为 resource.delimiter 的 Maven 属性来覆盖它。） 继承父启动器 要配置你的项目继承自 spring-boot-starter-parent，设置 parent 如下所示： 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt; 您应该仅在此依赖项上指定 Spring Boot 版本号。如果您导入额外的启动器，您可以安全地省略版本号。 通过这种设置，您还可以通过在自己的项目中覆盖一个属性来覆盖单个依赖项。例如，要升级到另一个 Spring Data release train，您需要将以下内容添加到您的 pom.xml： 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 检查 spring-boot-dependencies pom 获取支持的属性列表。 使用没有父 POM 的 Spring Boot 不是每个人都喜欢继承自 spring-boot-starter-parent POM。您可能有您自己的企业标准父类，您需要使用它们，或者您可能倾向于显式地声明所有的 Maven 配置。 如果你不想使用 spring-boot-starter-parent，您仍然可以使用 scope=import 依赖项来保持依赖管理（但不是插件管理）的好处： 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 前面的示例设置不允许您使用属性来覆盖单个依赖项，如上所述。要实现相同的结果，您需要在 spring-boot-dependencies 条目之前在您的项目的依赖项管理中添加一个条目。例如，要升级到另一个 Spring Data release train，您可以将以下元素添加到您的 pom.xml： 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在前面的示例中，我们指定了一个 BOM，但是任何依赖类型都可以以相同的方式被覆盖。 使用 Spring Boot Maven 插件 Spring Boot 包含了一个 Maven 插件可以将项目打包成一个可执行的 jar。如果你想使用它，添加该插件到你的 &lt;plugins&gt; 部分，如下示例所示： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果你使用 Spring Boot 启动器父 pom，你只需要添加该插件。没有其它需要配置的东西，除非你想修改父 pom 中定义的设置。 Gradle要了解搭配 Gradle 来使用 Spring Boot，请参考 Spring Boot 的 Gradle 插件文档： 参考手册（HTML 和 PDF） API 启动器启动器是一组方便的依赖关系描述符，您可以在应用程序中包括这些描述符。您可以获取为所有 Spring 和相关技术提供一站式服务，而无需通过示例代码和复制粘贴的依赖描述符来进行搜索。例如，如果您想要开始使用 Spring 和 JPA 进行数据库访问，请在项目中包含 spring-boot-starter-data-jpa 依赖项。 启动器包含大量的依赖项，您需要通过一个一致的、受支持的管理传递依赖集来快速地启动项目并运行。 名字里包含了什么 所有官方的启动器都遵循类似的命名模式：spring-boot-starter-*，其中 * 是一种特殊类型的应用程序。这种命名结构旨在帮助您找到启动器。许多 IDE 中的 Maven 集成让您可以通过名称搜索依赖项。例如，如果安装了适当的 Eclipse 或 STS 插件，您可以在 POM 编辑器中按下 ctrl-space，并在一个完整的列表中键入“spring-boot-starter”。 正如在“创建你自己的启动器”部分中所解释的，第三方启动器不应该从 spring-boot 开始，因为它是为官方 Spring Boot 工件预留的。相反，第三方启动器通常以项目的名称开始。例如，一个名为 thirdpartyproject 的第三方启动项目通常会被命名为 thirdpartyproject-spring-boot-starter。 下面列举的应用程序启动器，由 Spring Boot 提供，位于 org.springframework.boot group 下： 名称 描述 Pom spring-boot-starter 核心启动器，保留自动配置支持、日志和 YAML Pom spring-boot-starter-activemq 用于使用 Apache ActiveMQ 进行 JMS 消息传递 Pom spring-boot-starter-amqp 用于使用 Spring AMQP 和 Rabbit MQ Pom spring-boot-starter-aop 用于使用 Spring AOP 和 AspectJ 进行面向切面编程 Pom spring-boot-starter-artemis 用于使用 Apache Artemis 进行 JMS 消息传递 Pom spring-boot-starter-batch 用于使用 Spring Batch Pom spring-boot-starter-cache 用于使用 Spring Framework 的缓存支持 Pom spring-boot-starter-cloud-connectors 用于使用 Spring Cloud Connectors，它简化了与云平台里的服务的连接，如 Cloud Foundry 和 Heroku Pom spring-boot-starter-data-cassandra 用于使用 Cassandra 分布式数据库和 Spring Data Cassandra Pom spring-boot-starter-data-cassandra-reactive 用于使用 Cassandra 分布式数据库和 Spring Data Cassandra Reactive Pom spring-boot-starter-data-couchbase 用于使用 Couchbase 面向文档型数据库和 Spring Data Couchbase Pom spring-boot-starter-data-couchbase-reactive 用于使用 Couchbase 面向文档型数据库和 Spring Data Couchbase Reactive Pom spring-boot-starter-data-elasticsearch 用于使用 Elasticsearch 搜索分析引擎和 Spring Data Elasticsearch Pom spring-boot-starter-data-jpa 用于使用基于 Hibernate 的 Spring Data JPA Pom spring-boot-starter-data-ldap 用于使用 Spring Data LDAP Pom spring-boot-starter-data-mongodb 用于使用 MongoDB 面向文档型数据库和 Spring Data MongoDB Pom spring-boot-starter-data-mongodb-reactive 用于使用 MongoDB 面向文档型数据库和 Spring Data MongoDB Reactive Pom spring-boot-starter-data-neo4j 用于使用 Neo4j 图形数据库和 Spring Data Neo4j Pom spring-boot-starter-data-redis 用于使用 Redis 键值对数据存储，以及 Spring Data Redis 和 Lettuce 客户端 Pom spring-boot-starter-data-redis-reactive 用于使用 Redis 键值对数据存储，以及 Spring Data Redis reactive 和 Lettuce 客户端 Pom spring-boot-starter-data-rest 用于使用 Spring Data Rest 通过 REST 暴露 Spring Data 仓库 Pom spring-boot-starter-data-solr 用于使用 Apache Solr 搜索平台以及 Spring Data Solr Pom spring-boot-starter-freemarker 用于使用 FreeMarker 视图构建 MVC web 应用程序 Pom spring-boot-starter-groovy-templates 用于使用 Groovy Templates 视图构建 MVC web 应用程序 Pom spring-boot-starter-hateoas 用于构建基于超媒体的 RESTful web 应用程序，使用 Spring MVC 和 Spring HATEOAS Pom spring-boot-starter-integration 用于使用 Spring Integration Pom spring-boot-starter-jdbc 用于使用 JDBC 以及 HikariCP 连接池 Pom spring-boot-starter-jersey 用于构建 RESTful web 应用程序，使用 JAX-RS 和 Jersey。spring-boot-starter-web 的另一种选择。 Pom spring-boot-starter-jooq 用于使用 jOOQ 访问 SQL 数据库。spring-boot-starter-data-jpa 或 spring-boot-starter-jdbc 的另一种选择。 Pom spring-boot-starter-json 用于读写 json Pom spring-boot-starter-jta-atomikos 用于使用 Atomikos JTA 事务 Pom spring-boot-starter-jta-bitronix 用于使用 Bitronix JTA 事务 Pom spring-boot-starter-jta-narayana 用于使用 Narayana JTA 事务 Pom spring-boot-starter-mail 用于使用 Java Mail 和 Spring Framework 的 email 发送支持 Pom spring-boot-starter-mustache 用于使用 Mustache 视图构建 web 应用程序 Pom spring-boot-starter-quartz 用于使用 Quartz 调度程序 Pom spring-boot-starter-security 用于使用 Spring Security Pom spring-boot-starter-test 用于测试 Spring Boot 应用程序，包括 JUnit、Hamcrest 和 Mockito 库 Pom spring-boot-starter-thymeleaf 用于使用 Thymeleaf 视图构建 MVC web 应用程序 Pom spring-boot-starter-validation 用于使用基于 Hibernate Validator 的 Java Bean 校验程序 Pom spring-boot-starter-web 用于构建 web，包括 RESTful 和使用 Spring MVC 的应用程序。使用 Tomcat 作为默认内置容器 Pom spring-boot-starter-web-services 用于使用 Spring Web Services Pom spring-boot-starter-webflux 用于构建 WebFlux 应用程序，使用 Spring Framework 的 Reactive Web 支持 Pom spring-boot-starter-websocket 用于构建 WebSocket 应用程序，使用 Spring Framework 的 WebSocket 支持 Pom 除了应用程序启动器之外，下面的启动器还可以用于添加*生产就绪*特性： 名称 描述 Pom spring-boot-starter-actuator 用于使用 Spring Boot 的 Actuator 提供生产就绪特性，帮助您监视和管理应用程序 Pom 最后，Spring Boot 还包括以下启动器，如果您想要排除或交换特定的技术方面，可以使用： 名称 描述 Pom spring-boot-starter-jetty 用于使用 Jetty 作为内置 servlet 容器。spring-boot-starter-tomcat 的另一种选择。 Pom spring-boot-starter-log4j2 用于使用 Log4j2 记录日志。spring-boot-starter-logging 的另一种选择。 Pom spring-boot-starter-logging 用于logging 使用 Logback. Default logging starter Pom spring-boot-starter-reactor-netty 用于使用 Reactor Netty 作为内置响应式 HTTP 服务器。 Pom spring-boot-starter-tomcat 用于使用 Tomcat 作为内置 servlet 容器。spring-boot-starter-web 使用的默认 servlet 容器启动器。 Pom spring-boot-starter-undertow 用于使用 Undertow 作为内置 servlet 容器。spring-boot-starter-tomcat 的另一种选择。 Pom 有关附加社区贡献的启动器列表，请参阅 Github 上的 spring-boot-starters 模块中的自述文件。 组织你的代码Spring Boot 不需要任何特定的代码布局来工作。然而，有一些最佳实践可以提供帮助。 使用“default”包当一个类不包含包声明时，它被认为是在“default 包”中。使用“default 包”通常是不鼓励的，应该避免使用。它可能会导致使用 @ComponentScan、@EntityScan 或 @SpringBootApplication 注解的 Spring Boot 应用程序的特定问题，因为每个 jar 的每个类都被读取。 我们建议您遵循 Java 推荐的包命名约定，并使用一个反向的域名（例如，com.example.project）。 定位主应用程序类我们通常建议您在其他类之上的根包中定位主应用程序类。@SpringBootApplication 注解通常放在主类上，它隐式地为某些项定义了一个基本的“搜索包”。例如，如果您正在编写一个 JPA 应用程序，则使用 @SpringBootApplication 注解类的包来搜索 @Entity 项。使用根包也允许组件扫描只应用于您的项目。 如果您不想使用 @SpringBootApplication，那么 @EnableAutoConfiguration 和 @ComponentScan 注解将定义该行为，因此您也可以使用它。 下面的清单展示了一个典型的布局： 12345678910111213141516com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java Application.java 文件会声明 main 方法，以及基础的 @SpringBootApplication，如下所示： 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 配置类Spring Boot 支持基于 Java 的配置。虽然可以使用 XML 源码的 SpringApplication，但是我们通常建议您的主源是一个 @Configuration 类。通常，定义主方法的类是一个很好的候选者，作为主要的 @Configuration。 许多 Spring 配置示例已经在 Internet 上发布，它们使用 XML 配置。如果可能，始终尝试使用等效的基于 Java 的配置。搜索 Enable* 注解可能是一个很好的起点。 导入附加的配置类你不需要把你所有的 @Configuration 放入单一的类中。@Import 注解可用来导入附加的配置类。替代地，你可以使用 @ComponentScan 自动拾取所有的 Spring 组件，包括 @Configuration 类。 导入 XML 配置如果你必须使用基于 XML 的配置，我们推荐你仍然从 @Configuration 类开始。你可以使用 @ImportResource 注解加载 XML 配置文件。 自动配置Spring Boot 自动配置尝试根据您添加的 jar 依赖项自动配置 Spring 应用程序。例如，如果 HSQLDB 在您的类路径上，并且您没有手动配置任何数据库连接 bean，那么 Spring Boot 将自动配置内存数据库。 通过将 @EnableAutoConfiguration 或 @SpringBootApplication 注解添加到您的一个 @Configuration 类中，您需要选择加入到自动配置（原文：You need to opt-in to auto-configuration）。 您应该只添加一个 @SpringBootApplication 或 @EnableAutoConfiguration 注解。我们通常建议只在主 @Configuration 类中添加其中一个。 逐步取代自动配置自动配置是非侵入性的。在任何时候，您都可以开始定义自己的配置来替换自动配置的特定部分。例如，如果您添加了自己的 DataSource bean，默认的嵌入式数据库支持就会被取代。 如果您需要了解当前正在应用的自动配置，以及为什么。使用 --debug 开关启动应用程序。这样做可以为一些核心日志记录器开始调试日志，并将条件报告记录到控制台。 禁用特定的自动配置类如果你发现你不想应用的特定自动配置类，你可以使用 @EnableAutoConfiguration 的 exclude 属性禁用它们，如下示例所示： 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 如果那个类不在类路径，你可以使用这个注解的 excludeName 属性，指定完整的全类名。最后，您还可以通过使用 spring.autoconfigure.exclude property 来控制需要排除的自动配置类的列表。 你可以同时使用注解级别和 property 定义排除项。 Spring Bean 和依赖注入您可以自由使用任何标准 Spring 框架技术来定义 bean 及其注入的依赖项。为了简单起见，我们经常发现使用 @ComponentScan（找到您的 bean）和使用 @Autowired（进行构造函数注入）工作得很好。 如果按照上面建议的方式构造代码（在根包中定位应用程序类），可以不带任何参数添加 @ComponentScan。所有应用程序组件（@Component、@Service、@Repository、@Controller 等）都自动注册为 Spring bean。 下面的示例显示了使用构造函数注入来获得所需的 RiskAssessor Bean 的 @Service Bean： 123456789101112131415161718package com.example.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 如果一个 Bean 只有一个构造函数，你可以省略 @Autowired，如下示例所示： 123456789101112@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 注意，使用构造函数注入时，可以将 riskAssessor 字段标记为 final，表示它不能在之后被修改。 使用 @SpringBootApplication 注解许多 Spring Boot 开发者喜欢在他们的应用中使用自动配置、组件扫描，并且能够在他们的“application class”上定义额外配置。单个 @SpringBootApplication 注解即可以用来开启上述三个特性，即： @EnableAutoConfiguration：开启 Spring Boot 的自动配置机制 @ComponentScan：在应用程序的包上开启 @Component 扫描（查看最佳实践） @Configuration：允许在上下文注册额外的 bean，或者导入额外的配置类 @SpringBootApplication 相当于使用默认属性的 @Configuration、@EnableAutoConfiguration 和 @ComponentScan，如下示例所示： 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @SpringBootApplication 也提供了别名去定制 @EnableAutoConfiguration 和 @ComponentScan 的属性。 这些特性都不是强制性的，您可以选择用它支持的任何特性来替换这个注解。例如，您可能不想在应用程序中使用组件扫描： 1234567891011121314151617package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在本例中，应用程序和其他 Spring Boot 应用程序一样，只是没有自动检测到 @Component 注解的类，而用户定义的 bean 是显式导入的（参见 @Import）。 运行你的应用程序将您的应用程序打包为 jar 并使用嵌入式 HTTP 服务器的最大优点之一是，您可以像对待其他应用程序一样运行应用程序。调试 Spring Boot 应用程序也很简单。您不需要任何特殊的 IDE 插件或扩展。 本节只讨论基于 jar 的打包。如果您选择将应用程序打包为 war 文件，则应该参考服务器和 IDE 文档。 从 IDE 运行您可以从 IDE 运行 Spring Boot 应用程序，作为简单的 Java 应用程序。但是，您首先需要导入您的项目。导入步骤取决于您的 IDE 和构建系统。大多数 IDE 可以直接导入 Maven 项目。例如，Eclipse 用户可以选择 File 菜单的 Import… → Existing Maven Projects。 如果不能直接将项目导入到 IDE 中，那么可以使用构建插件生成 IDE 元数据。Maven 包含 Eclipse 和 IDEA 的插件。Gradle 提供各种 IDE 的插件。 如果您不小心运行了两次 web 应用程序，您会看到一个“Port already in use”错误。STS 用户可以使用 Relaunch 按钮而不是 Run 按钮来确保任何现有实例都已关闭。 作为打包应用程序运行如果您使用 Spring Boot Maven 或 Gradle 插件来创建一个可执行 jar，您可以使用 java -jar 运行您的应用程序，如下面的例子所示： 1$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar 还可以运行具有远程调试支持的打包应用程序。这样做可以将调试器附加到您的打包应用程序中，如下面的示例所示： 12$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\ -jar target/myapplication-0.0.1-SNAPSHOT.jar 使用 Maven 插件Spring Boot Maven 插件包含一个 run 目标，可以用来快速编译和启动你的应用程序。应用程序以展开的方式运行，正如它们在你的 IDE 中所做的那样。下面的示例显示一个典型的 Maven 命令来运行 Spring Boot 应用程序： 1$ mvn spring-boot:run 您可能还希望使用 MAVEN_OPTS 操作系统环境变量，如下例所示： 1$ export MAVEN_OPTS=-Xmx1024m 使用 Gradle 插件Spring Boot Gradle 插件还包括一个 bootRun 任务，它可以用来以一个展开的形式运行您的应用程序。当您应用 org.springframework.boot 和 java 插件时，将添加 bootRun 任务。如下例所示： 1$ gradle bootRun 您可能还想使用 JAVA_OPTS 操作系统环境变量，如下例所示： 1$ export JAVA_OPTS=-Xmx1024m 热交换由于 Spring Boot 应用程序只是普通的 Java 应用程序，所以 JVM 热交换应该可以开箱即用。JVM 热交换在一定程度上限制了它可以替换的字节码。对于更完整的解决方案，可以使用 JRebel。 spring-boot-devtools 模块还包括对快速应用程序重启的支持。查看本章后面的开发者工具部分和如何做热交换获取详细信息。 开发者工具Spring Boot 包括一组额外的工具，这些工具可以使应用程序开发体验变得更加愉快。spring-boot-devtools 模块可以包含在任何项目中，以提供额外的开发时特性。要包含 devtools 支持，请将模块依赖项添加到您的构建中，如下所示的 Maven 和 Gradle 列表： Maven 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle 123dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-devtools&quot;)&#125; 在运行完全打包的应用程序时，开发者工具会自动被禁用。如果您的应用程序是从 java -jar 启动的，或者是从一个特殊的类加载器开始的，那么它就被认为是一个“生产应用程序”。在 Maven 中将依赖项标记为 optional 或 在 Gradle 使用 compileOnly 中是一种最佳实践，它可以防止 devtools 被传递到其他使用您的项目的模块中。 默认情况下，重新打包的存档不包含 devtools。如果您想要使用某个远程 devtools 特性，您需要禁用 excludeDevtools 构建属性来包含它。该属性同时支持 Maven 和 Gradle 插件。 属性默认值Spring Boot 所支持的几个库都使用缓存来提高性能。例如，模板引擎缓存已编译的模板以避免重复解析模板文件。另外，Spring MVC 可以在服务静态资源时添加 HTTP 缓存头信息。 虽然缓存在生产中非常有益，但在开发过程中可能会产生相反的效果，使您无法看到您在应用程序中所做的更改。出于这个原因，spring-boot-devtools 在默认情况下禁用了缓存选项。 缓存选项通常在你的 application.properties 文件中配置。例如，Thymeleaf 提供了 spring.thymeleaf.cache 属性。spring-boot-devtools 模块不需要手动设置这些属性，而是自动应用合理的开发时配置。 有关 devtools 应用的属性的完整列表，请参见 DevToolsPropertyDefaultsPostProcessor。 自动重启使用 spring-boot-devtools 的应用程序在类路径更改时自动重新启动。当在 IDE 中工作时，这可能是一个有用的特性，因为它为代码更改提供了非常快速的反馈循环。默认情况下，指向一个文件夹的类路径上的任何条目都会被监控以进行更改。请注意，某些资源（如静态资产和视图模板）不需要重新启动应用程序。 触发重启 当 DevTools 监视类路径资源时，触发重启的惟一方法是更新类路径。您导致要更新的类路径的方式取决于您使用的 IDE。在 Eclipse 中，保存修改后的文件会导致类路径被更新并触发重新启动。在 IntelliJ IDEA 中，构建项目（Build -&gt; Build Project）具有相同的效果。 只要启用了 forking，您就可以使用支持的构建插件（Maven 和 Gradle）来启动应用程序，因为 DevTools 需要一个独立的应用程序类加载器才能正常运行。默认情况下，Gradle 和 Maven 在类路径上检测 DevTools 时是这样做的。 当与 LiveReload 一起使用时，自动重启非常有效。详情请参阅 LiveReload 一节。如果您使用 JRebel，自动重新启动将被禁用，以支持动态类重载。其他 devtools 特性（如 LiveReload 和 property overrides）仍然可以使用。 DevTools 依赖于应用程序上下文的关闭钩子在重新启动时关闭它。如果您已经禁用了关闭钩子（SpringApplication.setRegisterShutdownHook(false)），那么它将无法正常工作。 当决定是否在类路径上的条目发生更改时触发重新启动时，DevTools 会自动忽略名为 spring-boot、spring-boot-devtools、spring-boot-autoconfigure、spring-boot-actuator 和 spring-boot-starter 的项目。 DevTools 需要自定义 ApplicationContext 所使用的 ResourceLoader。如果您的应用程序已经提供了一个，那么它将被打包。不支持在 ApplicationContext 上直接覆盖 getResource 方法。 重启和重新加载 Spring Boot 提供的重启技术使用两个类加载器。不改变的类（例如，来自第三方 jar 的类）被加载到一个基类加载器中。正在积极开发的类被加载到重启类加载器中。当应用程序重新启动时，重启类加载器将被丢弃，并创建一个新的类加载器。这种方法意味着应用程序重新启动通常要比“冷启动”快得多，因为基类加载器已经可用并填充了。 如果您发现重新启动对应用程序不够快，或者遇到了类加载问题，那么您可以考虑重新加载技术，例如从 ZeroTurnaround 转向 JRebel。这些工作通过重写类，使它们更适合重载。 记录状态评估的变化（Logging changes in condition evaluation） 默认情况下，每次应用程序重新启动时，都会记录显示状态评估增量的报告。报告显示了在进行更改（如添加或删除 bean 和设置配置属性）时对应用程序的自动配置的更改。 若要禁用报告的日志记录，请设置以下属性： 1spring.devtools.restart.log-condition-evaluation-delta=false 排除资源 某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf 模板可以就地编辑。默认情况下，/META-INF/maven、/META-INF/resources、/resources、/static、/public 或 /templates 不会触发重新启动，而是触发 live reload。如果你想要自定义这些排除项，你可以使用 spring.devtools.restart.exclude 属性。例如，只排除 /static 和 /public 可以这样设置： 1spring.devtools.restart.exclude=static/**,public/** 如果你想要保留默认设置并添加额外的排除项，使用 spring.devtools.restart.additional-exclude 替代它。 观察附加路径 你可能希望当你对不在类路径上的文件进行更改时，重新启动或加载你的应用程序。要这样，使用 spring.devtools.restart.additional-paths 属性配置要观察变化的附加路径。您可以使用上面提到的 spring.devtools.restart.exclude 属性来控制在附加路径下的更改是否会触发完全重启或 live reload。 禁用重启 如果您不想使用重启功能，您可以使用 spring.devtools.restart.enabled 属性禁用它。在大多数情况下，您可以在 application.properties 中设置此属性（这样做仍然初始化重启类加载器，但它不观察文件的更改）。 如果您需要完全禁用重新启动支持（例如，因为它不能与特定的库一起工作），那么您需要设置 spring.devtools.restart.enabled 系统属性为 false，然后调用 SpringApplication.run(…)，如下例所示： 1234public static void main(String[] args) &#123; System.setProperty(&quot;spring.devtools.restart.enabled&quot;, &quot;false&quot;); SpringApplication.run(MyApp.class, args);&#125; 使用一个触发文件 如果您使用一个持续编译已更改文件的 IDE，您可能只需要在特定的时间触发重新启动。为此，您可以使用一个“触发文件”，它是一个特殊的文件，当您想要实际触发重新启动检查时，必须对其进行修改。更改文件只会触发检查，只有当 Devtools 检测到它必须做某事时才会重新启动。触发器文件可以手动更新，也可以使用 IDE 插件进行更新。 要使用一个触发器文件，请将 spring.devtools.restart.trigger-file 属性设置为触发器文件的路径。 您可能想要设置 spring.devtools.restart.trigger-file 作为全局设置，以便所有的项目都以相同的方式运行。 自定义重启类加载器 如前所述，在“重启和重新加载”部分中，重新启动功能是通过使用两个类加载器实现的。对于大多数应用程序来说，这种方法运行良好。然而，它有时会导致类加载问题。 默认情况下，IDE 中的任何开放项目都包含“重启”类加载器，任何常规的 .jar 文件都装载了“基础”类加载器。如果您在一个多模块项目中工作，而不是每个模块都导入到您的 IDE 中，您可能需要定制一些东西。为此，您可以创建一个 META-INF/spring-devtools.properties 文件。 spring-devtools.properties 文件可以包含以 restart.exclude 和 restart.include 为前缀的属性。include 元素是应该被拉到“重启”类加载器中的项，而 exclude 元素则是应该被推入“基础”类加载器的项。属性的值是应用于类路径的正则表达式模式，如下例所示： 12restart.exclude.companycommonlibs=/mycorp-common-[\\\\w-]+\\.jarrestart.include.projectcommon=/mycorp-myproj-[\\\\w-]+\\.jar 所有属性的键必须是唯一的。只有属性以 restart.include. 或 restart.exclude. 开头，它才会被考虑。 所有类路径的 META-INF/spring-devtools.properties 都会被加载。您可以在项目中或项目使用的库中打包文件。 已知局限性 通过使用标准 ObjectInputStream 来反序列化的对象，重新启动功能不会很好地工作。如果需要反序列化数据，可能需要使用 Spring 的 ConfigurableObjectInputStream 和 Thread.currentThread().getcontextclassloader()。 不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果您发现这样的问题，您需要向原始作者请求修复。 LiveReloadspring-boot-devtools 模块包含一个嵌入式的 LiveReload 服务器，当资源被更改时，它可以用来触发浏览器刷新。LiveReload 浏览器扩展可以从 livereload.com 免费提供给 Chrome、Firefox 和 Safari。 如果您不想在应用程序运行时启动 LiveReload 服务器，则可以设置 spring.devtools.livereload.enabled 属性为 false。 您一次只能运行一个 LiveReload 服务器。在启动应用程序之前，确保没有其他的 LiveReload 服务器在运行。如果您在 IDE 中启动多个应用程序，那么只有第一个应用程序得到了 LiveReload 的支持。 全局设置您可以通过添加名为 .spring-boot-devtools.properties 的文件到 $HOME 文件夹（注意文件名以“.”开头）来配置全局 devtools 设置。添加到该文件的任何属性都适用于使用 devtools 的机器上的所有 Spring Boot 应用程序。例如，要配置重新启动以始终使用触发器文件，您需要添加以下属性： ~&#x2F;.spring-boot-devtools.properties. 1spring.devtools.reload.trigger-file=.reloadtrigger 远程应用程序Spring Boot 开发者工具并不局限于本地开发。在远程运行应用程序时，还可以使用几个特性。远程支持是可选的。要启用它，您需要确保将 devtools 包含在重新打包的归档文件中，如下面的清单所示： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后，你需要设置 spring.devtools.remote.secret 属性，如下示例所示： 1spring.devtools.remote.secret=mysecret 在远程应用程序上启用 spring-boot-devtools 是一种安全风险。您不应该在生产部署上启用支持。 远程 devtools 支持分两部分提供：一个服务器端端点接受连接，一个客户端应用程序在 IDE 中运行。当 spring.devtools.remote.remote.secret 属性被设置时，服务器组件自动启用。客户端组件必须手动启动。 运行远程客户端应用程序 远程客户端应用程序被设计为从 IDE 中运行。你需要运行 org.springframework.boot.devtools.RemoteSpringApplication，使用你链接的远程项目相同的类路径。应用程序的唯一必需参数是它连接的远程 URL。 例如，如果您正在使用 Eclipse 或 STS，并且您有一个名为 my-app 的项目，您已经部署到 Cloud Foundry，那么您将执行以下操作： 选择 Run 菜单的 Run Configurations… 创建一个新的 Java Application “launch configuration” 浏览 my-app 项目 使用 org.springframework.boot.devtools.RemoteSpringApplication 作为主类 添加 https://myapp.cfapps.io 到 Program arguments（或者你的任何远程 URL） 运行中的远程客户端可能类似于如下列表： 12345678910111213 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ ___ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | | _ \\___ _ __ ___| |_ ___ \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| []::::::[] / -_) &#x27; \\/ _ \\ _/ -_) ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | |_|_\\___|_|_|_\\___/\\__\\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote :: 2.0.2.RELEASE2015-06-10 18:25:06.632 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)2015-06-10 18:25:06.671 INFO 14938 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy2015-06-10 18:25:07.043 WARN 14938 --- [ main] o.s.b.d.r.c.RemoteClientConfiguration : The connection to http://localhost:8080 is insecure. You should use a URL starting with &#x27;https://&#x27;.2015-06-10 18:25:07.074 INFO 14938 --- [ main] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292015-06-10 18:25:07.130 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105) 因为远程客户端使用与实际应用程序相同的类路径，它可以直接读取实际应用程序属性。这是 spring.devtools.remote.secret 属性被读取并传递给服务器进行身份验证的方法。 使用 https:// 作为连接协议总是明智的，这样就可以加密传输并不能截获密码。 如果需要使用代理访问远程应用程序，配置 spring.devtools.remote.proxy.host 和 spring.devtools.remote.proxy.port 属性。 远程更新 远程客户端监控您的应用程序类路径，以与本地重启相同的方式进行更改。任何更新的资源都被推送到远程应用程序，并且（如果需要的话）触发重启。如果您在一个使用不本地化的云服务的特性上进行迭代，这将是很有帮助的。一般来说，远程更新和重新启动比完整的重建和部署周期要快得多。 只在远程客户端运行时监视文件。如果在启动远程客户端之前更改一个文件，则不会将其推送到远程服务器。 打包用于生产环境的应用程序可执行 jar 可以用于生产部署。由于它们是自包含的，所以它们也非常适合基于云的部署。 对于额外的“生产就绪”特性，如健康、审计和度量 REST 或 JMX 端点，考虑添加 spring-boot-actuator。查看 *Spring Boot Actuator：生产就绪特性*获取详细信息。 下一步该读什么现在您应该了解如何使用 Spring Boot 和您应该遵循的一些最佳实践。现在，您可以深入了解特定的 *Spring Boot 特性*，或者您可以跳过，阅读 Spring Boot 的“生产就绪”方面的内容。 Spring Boot 特性本节将深入介绍 Spring Boot 的详细信息。在这里，您可以了解您可能想要使用和定制的关键特性。如果您还没有这样做，您可能希望阅读“入门”和“使用 Spring Boot”部分，这样您就有了良好基础。 SpringApplicationSpringApplication 类提供了一种方便的方法来引导从 main() 方法开始的 Spring 应用程序。在许多情况下，您可以委托给静态 SpringApplication.run 方法，如下例所示： 123public static void main(String[] args) &#123; SpringApplication.run(MySpringConfiguration.class, args);&#125; 当你的应用程序启动时，你应该看到类似于如下输出： 123456789101112 . ____ _ __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &#x27; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: v2.0.2.RELEASE2013-07-31 00:08:16.117 INFO 56603 --- [ main] o.s.b.s.app.SampleApplication : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)2013-07-31 00:08:16.166 INFO 56603 --- [ main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy2014-03-04 13:09:54.912 INFO 41370 --- [ main] .t.TomcatServletWebServerFactory : Server initialized with port: 80802014-03-04 13:09:56.501 INFO 41370 --- [ main] o.s.b.s.app.SampleApplication : Started SampleApplication in 2.992 seconds (JVM running for 3.658) 默认情况下，显示 INFO 日志消息，包括一些相关的启动细节，比如启动应用程序的用户。如果您需要一个除 INFO 之外的日志级别，您可以设置它，如日志级别。 启动失败如果您的应用程序启动失败，注册的 FailureAnalyzers 将有机会提供专用的错误消息和解决问题的具体操作。例如，如果您在端口 8080 上启动 web 应用程序，并且该端口已经在使用，您应该会看到类似于以下消息的内容： 1234567891011***************************APPLICATION FAILED TO START***************************Description:Embedded servlet container failed to start. Port 8080 was already in use.Action:Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port. Spring Boot 提供了大量的 FailureAnalyzer 实现，您可以添加自己的。 如果没有故障分析器能够处理异常，您仍然可以显示完整的情况报告，以便更好地理解错误。要做到这一点，您需要启用 debug 属性或为 org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener 启用 DEBUG 日志记录。 例如，如果您正在使用 java -jar 运行您的应用程序，您可以使调试属性如下： 1$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug 定制横幅可以通过向类路径中添加 banner.txt 文件或将 spring.banner.location 属性设置为此类文件的位置来更改在启动时打印的横幅。如果文件的编码不是 UTF-8，则可以设置 spring.banner.charset。除了文本文件之外，还可以向类路径中添加 banner.gif、banner.jpg 或 banner.png 图像文件，或者设置 spring.banner.image.location 属性。图像转换为 ASCII 艺术表示，并打印在任何文本横幅之上。 在 banner.txt 文件中, 您可以使用下列任何一个占位符： 变量 描述 $&#123;application.version&#125; 你的应用程序版本号，如 MANIFEST.MF 中声明的。比如，Implementation-Version: 1.0 打印为 1.0。 $&#123;application.formatted-version&#125; 你的应用程序版本号，如 MANIFEST.MF 中声明的，格式化显示（被括号包裹，用 v 作前缀）。比如 (v1.0)。 $&#123;spring-boot.version&#125; 你使用的 Spring Boot 版本。比如 2.0.2.RELEASE。 $&#123;spring-boot.formatted-version&#125; 你使用的 Spring Boot 版本，格式化显示（被括号包裹，用 v 作前缀）。比如 (v2.0.2.RELEASE)。 $&#123;Ansi.NAME&#125;（或 $&#123;AnsiColor.NAME&#125;, $&#123;AnsiBackground.NAME&#125;, $&#123;AnsiStyle.NAME&#125;） 其中 NAME 是 ANSI 转义代码的名称。查看 AnsiPropertySource 获取详细信息。 $&#123;application.title&#125; 你的应用程序的标题，如 MANIFEST.MF 中声明的。比如 Implementation-Title: MyApp 打印为 MyApp。 如果您想以编程的方式生成横幅，则可以使用 SpringApplication.setBanner(…) 方法。使用 org.springframework.boot.Banner 接口并实现您自己的 printBanner() 方法。 你也可以使用 spring.main.banner-mode 属性决定横幅是否打印在 System.out（console） 上、发送到配置的日志记录器（log）、完全不产生（off）。 在以下名称中，打印的横幅被注册为一个单例 bean：springBootBanner。 YAML 映射 off 到 false，所以如果您想要禁用应用程序中的横幅，请确保添加引号，如下例所示： 123spring: main: banner-mode: &quot;off&quot; 定制 SpringApplication如果 SpringApplication 的默认值不符合您的喜好，您可以创建一个本地实例并自定义它。例如，要关闭横幅，你可以写： 12345public static void main(String[] args) &#123; SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args);&#125; 传递给 SpringApplication 的构造函数参数是 Spring bean 的配置源。在大多数情况下，这些都是对 @Configuration 类的引用，但是它们也可以是对 XML 配置的引用，或者对应该被扫描的包的引用。 也可以使用 application.properties 文件配置 SpringApplication。查看*外部化配置*以获取详细信息。 有关配置选项的完整列表，查看 SpringApplication Javadoc。 Fluent 风格构建器 API如果您需要构建 ApplicationContext 层次结构（包含父&#x2F;子关系的多个上下文），或者您更喜欢使用“fluent”构建器 API，那么您可以使用 SpringApplicationBuilder。 SpringApplicationBuilder 允许您将多个方法调用链接在一起，并包含让您创建层次结构的 parent 和 child 方法，如下例所示： 12345new SpringApplicationBuilder() .sources(Parent.class) .child(Application.class) .bannerMode(Banner.Mode.OFF) .run(args); 在创建 ApplicationContext 层次结构时，有一些限制。例如，Web 组件必须包含在子上下文内，并且在父和子上下文环境中都使用相同的 Environment。请参阅 SpringApplicationBuilder Javadoc 了解详细信息。 应用程序事件和监听器除了通常的 Spring Framework 事件（比如 ContextRefreshedEvent）之外，SpringApplication 还会发送一些附加的应用程序事件。 在创建 ApplicationContext 之前，实际上触发了一些事件，因此不能将侦听器注册为 @Bean。您可以使用 SpringApplication.addListeners(…) 方法或 SpringApplicationBuilder.listeners(…) 方法注册它们。 如果您希望这些侦听器自动注册，不管应用程序是如何创建的，您都可以添加一个 META-INF/spring.factories 文件到您的项目，并通过使用 org.springframework.context.ApplicationListener 键来引用您的侦听器，如下例所示： 1org.springframework.context.ApplicationListener = com.example.project.MyListener 应用程序事件按以下顺序发送： ApplicationStartingEvent，是在运行开始时发送的，但在任何处理之前，除了侦听器和初始化器的注册之外。 ApplicationEnvironmentPreparedEvent，当 Environment 被使用时，在上下文被创建之前被发送。 ApplicationPreparedEvent，在刷新之前发送，但是在加载 bean 定义之后。 ApplicationStartedEvent，在调用上下文之后发送，但是在调用任何应用程序和命令行运行程序之前。 ApplicationReadyEvent，在调用任何应用程序和命令行运行程序后发送。它表明应用程序已经准备好服务请求。 ApplicationFailedEvent，如果启动时出现异常，则发送。 您通常不需要使用应用程序事件，但是知道它们的存在是很方便的。在内部，Spring Boot 使用事件来处理各种任务。 使用 Spring Framework 的事件发布机制发送应用程序事件。该机制的一部分确保在子环境中发布给侦听器的事件也会在任何祖先上下文中被发布给侦听器。因此，如果您的应用程序使用了 SpringApplication 实例的层次结构，那么侦听器可能会接收到相同类型的应用程序事件的多个实例。 为了让您的侦听器区分事件的上下文和派生上下文的事件，它应该请求将其应用程序上下文注入，然后将注入的上下文与事件上下文进行比较。可以通过实现 ApplicationContextAware 或，如果侦听器是 bean，通过使用 @Autowired 来注入上下文。 Web 环境SpringApplication 试图为您创建合适的 ApplicationContext 类型。用于确定 WebEnvironmentType 的算法相当简单： 如果 Spring MVC 存在，则使用 AnnotationConfigServletWebServerApplicationContext 如果 Spring MVC 不存在，Spring WebFlux 是存在的，那么就使用一个 AnnotationConfigReactiveWebServerApplicationContext 否则，使用 AnnotationConfigApplicationContext 这意味着如果您使用 Spring MVC 和来自 Spring WebFlux 的新 WebClient 在相同的应用程序中，Spring MVC 将在默认情况下使用。您可以通过调用 setWebApplicationType(WebApplicationType) 来轻松覆盖它。 还可以完全控制调用 setApplicationContextClass(…) 所使用的 ApplicationContext 类型。 在 JUnit 测试中使用 SpringApplication 时，通常需要调用 setWebApplicationType(WebApplicationType.NONE)。 访问应用程序参数如果您需要访问传递到 SpringApplication.run(…) 的应用程序参数，您可以注入一个 org.springframework.boot.ApplicationArguments bean。ApplicationArguments 接口提供了对原始 String[] 参数以及解析 option 和 non-option 参数的访问，如下例所示： 123456789101112131415import org.springframework.boot.*;import org.springframework.beans.factory.annotation.*;import org.springframework.stereotype.*;@Componentpublic class MyBean &#123; @Autowired public MyBean(ApplicationArguments args) &#123; boolean debug = args.containsOption(&quot;debug&quot;); List&lt;String&gt; files = args.getNonOptionArgs(); // if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;] &#125;&#125; Spring Boot 还会在 Spring Environment 中注册一个 CommandLinePropertySource。这允许您使用 @Value 注解注入单个应用程序参数。 使用 ApplicationRunner 或 CommandLineRunner如果您需要在 SpringApplication 启动之后运行一些特定的代码，您可以实现 ApplicationRunner 或 CommandLineRunner 接口。两个接口都以相同的方式工作，并提供了一个单独的运行方法，在 SpringApplication.run(…) 完成之前调用。 CommandLineRunner 接口提供对应用程序参数的访问作为一个简单的字符串数组，而 ApplicationRunner 使用前面讨论的 ApplicationArguments 接口。下面的示例展示了一个使用 run 方法的 CommandLineRunner： 1234567891011import org.springframework.boot.*;import org.springframework.stereotype.*;@Componentpublic class MyBean implements CommandLineRunner &#123; public void run(String... args) &#123; // Do something... &#125;&#125; 如果定义了多个 CommandLineRunner 或 ApplicationRunner bean，必须以特定的顺序调用它们，那么您可以额外地实现 org.springframework.core.Ordered 接口或使用 org.springframework.core.annotation.Order 注解。 应用程序退出每个 SpringApplication 都向 JVM 注册一个关闭钩子，以确保 ApplicationContext 在退出时优雅地关闭。可以使用所有标准的 Spring 生命周期回调函数（如 DisposableBean bean 接口或 @PreDestroy 注解）。 此外，bean 可以实现 org.springframework.boot.ExitCodeGenerator 接口，如果希望当 SpringApplication.exit() 被调用时，返回特定的退出代码。然后可以将此退出代码传递给 System.exit()，以将其作为状态代码返回，如下面的示例所示： 1234567891011121314@SpringBootApplicationpublic class ExitCodeApplication &#123; @Bean public ExitCodeGenerator exitCodeGenerator() &#123; return () -&gt; 42; &#125; public static void main(String[] args) &#123; System.exit(SpringApplication .exit(SpringApplication.run(ExitCodeApplication.class, args))); &#125;&#125; 此外，ExitCodeGenerator 接口也可以由异常来实现。当遇到这样的异常时，Spring Boot 返回由实现的 getExitCode() 方法提供的退出代码。 管理员特性通过指定 spring.application.admin.enabled 属性，可以为应用程序启用与 admin 相关的特性。这将在平台 MBeanServer 上公开 SpringApplicationAdminMXBean。您可以使用该特性远程管理您的 Spring Boot 应用程序。这个特性还可以用于任何服务包装器实现。 如果您想知道应用程序正在运行哪个 HTTP 端口，请使用 local.server.port 的键获取该属性。 谨慎 在启用该特性时要注意，因为 MBean 公开了关闭应用程序的方法。 外部化配置（Externalized Configuration）Spring Boot 允许您外部化您的配置，这样您就可以在不同的环境中使用相同的应用程序代码。您可以使用 properties 文件、YAML 文件、环境变量和命令行参数来外部化配置。属性值可以通过使用 @Value 注解直接注入到您的 bean 中，通过 Spring 的 Environment 抽象访问，或者通过 @ConfigurationProperties 绑定到结构化对象。 Spring Boot 使用一种非常特殊的 PropertySource 命令，该命令旨在允许对值进行合理的覆盖。属性按以下顺序考虑： 主目录上的 Devtools 全局设置属性（~/.spring-boot-devtools.properties，当 devtools 激活时） 测试上的 @TestPropertySource 注解 测试上的 @SpringBootTest#properties 注解 命令行参数 来自 SPRING_APPLICATION_JSON 的属性（嵌入在环境变量或系统属性中的内联 JSON） ServletConfig 初始化参数 ServletContext 初始化参数 来自 java:comp/env 的 JNDI 属性 Java 系统属性（System.getProperties()） OS 环境变量 RandomValuePropertySource，只在 random.* 中的属性 指定 Profile 的应用程序 properties，在打包好的 jar 之外（application-&#123;profile&#125;.properties 和 YAML variants） 指定 Profile 的应用程序 properties，打包在 jar 中（application-&#123;profile&#125;.properties 和 YAML variants） 应用程序属性，在打包好的 jar 之外（application.properties 和 YAML variants） 应用程序属性，打包在 jar 中（application.properties 和 YAML variants） @Configuration 类上的 @PropertySource 注解 默认属性（通过设置 SpringApplication.setDefaultProperties 明确规定） 为了提供一个具体的示例，假设您开发了一个使用 name 属性的 @Component，如下例所示： 123456789101112import org.springframework.stereotype.*;import org.springframework.beans.factory.annotation.*;@Componentpublic class MyBean &#123; @Value(&quot;$&#123;name&#125;&quot;) private String name; // ...&#125; 在您的应用程序类路径（例如，在 jar 中）您可以有一个 application.properties 文件，为 name 提供一个合理的默认属性值。在新环境中运行时，可以在您的 jar 之外提供 application.properties 文件，以覆盖 name。对于一次性测试，您可以使用特定的命令行开关启动（例如，java -jar app.jar --name=&quot;Spring&quot;）。 SPRING_APPLICATION_JSON 属性可以在命令行上提供环境变量。例如：你可以在 UN*X shell 中使用如下行： 1$ SPRING_APPLICATION_JSON=&#x27;&#123;&quot;acme&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27; java -jar myapp.jar 在前面的示例中，您在 Spring Environment 中最终得到了 acme.name=test。您也可以提供 JSON 如 spring.application.json 在系统属性中，如下例所示： 1$ java -Dspring.application.json=&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27; -jar myapp.jar 您还可以使用命令行参数来提供 JSON，如下面的示例所示： 1$ java -jar myapp.jar --spring.application.json=&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27; 您还可以将 JSON 作为 JNDI 变量提供，如下所示：java:comp/env/spring.application.json。 配置随机值RandomValuePropertySource 用于注入随机值（例如，在机密或测试用例中）。它可以生成 integer、long、uuid 或 string，如下面的示例所示： 123456my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.uuid=$&#123;random.uuid&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125; random.int* 语法是 OPEN value (,max) CLOSE，其中 OPEN,CLOSE 为任意字符、value,max 为 integer。如果 max 被提供，value 便是最小值、max 便是最大值（不包含）。 访问命令行属性在默认情况下，SpringApplication 会转换任何命令行选项参数（也就是说，参数以 -- 开始，如 --server.port=9000）到一个属性，并将它们添加到 Spring Environment 中。如前所述，命令行属性总是优先于其他属性源。 如果您不希望将命令行属性添加到 Environment 中，您可以使用 SpringApplication.setAddCommandLineProperties(false) 禁用它们。 应用程序属性文件SpringApplication 从以下位置的 application.properties 文件加载属性，并将它们添加到Spring Environment： 当前目录的 /config 子目录 当前目录 类路径的 /config 包 类路径根 列表按优先顺序排序（在列表中较高的位置定义的属性覆盖在较低位置定义的属性）。 你也可以使用 YAML (‘.yml’) 文件代替“.properties”。 如果您不喜欢 application.properties 作为配置文件名，可以通过指定 spring.config.name 环境属性切换到另一个文件名。您还可以使用 spring.config.location 环境属性来引用一个显式的位置（它是一个以逗号分隔的目录位置或文件路径列表）。下面的示例演示如何指定不同的文件名： 1$ java -jar myproject.jar --spring.config.name=myproject 下面的示例演示如何指定两个位置： 1$ java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties spring.config.name 和 spring.config.location 很早就被用于确定哪些文件必须被加载，因此它们必须被定义为环境属性（通常是一个 OS 环境变量、一个系统属性或一个命令行参数）。 如果 spring.config.location 包含目录（相对于文件），它们应该以 &#x2F; 结束（并且在运行时，被附加到 spring.config.name 生成的名称，包括特定于 profile 的文件名)。spring.config.location 中指定的文件是按原样使用的，不支持特定于 profile 的变体，并且被任何特定于 profile 的属性覆盖。 配置位置按相反顺序搜索。默认情况下，配置的位置是 classpath:/,classpath:/config/,file:./,file:./config/。由此产生的搜索顺序如下： file:./config/ file:./ classpath:/config/ classpath:/ 当自定义配置位置使用 spring.config.location 配置时，它们替换默认的位置。例如，如果 spring.config.location 配置为值：classpath:/custom-config/,file:./custom-config/，搜索顺序如下： file:./custom-config/ classpath:custom-config/ 或者，当自定义配置位置使用 spring.config.additional-location 配置时，除了默认位置外，还使用它们。在默认位置之前搜索额外的位置。例如，如果额外的位置配置为 classpath:/custom-config/,file:./custom-config/，搜索顺序如下： file:./custom-config/ classpath:custom-config/ file:./config/ file:./ classpath:/config/ classpath:/ 这个搜索排序允许您在一个配置文件中指定默认值，然后在另一个配置文件中选择性地覆盖这些值。您可以在位于默认位置之一的 application.properties 中为应用程序提供默认值（或您在 spring.config.name 中选择的其他 basename）。这些默认值可以在运行时被定制的位置中放置的一个不同的文件重写。 如果您使用环境变量而不是系统属性，大多数操作系统都不允许使用句号分隔的键名，但是您可以使用下划线（例如，SPRING_CONFIG_NAME 而不是 spring.config.name）。 如果应用程序在容器中运行，那么可以使用 JNDI 属性（在 java:comp/env 中）或 servlet 上下文初始化参数，而不是环境变量或系统属性。 特定于 Profile 属性除了 application.properties 文件，特定于 profile 的属性也可以通过使用以下命名约定来定义：application-&#123;profile&#125;.properties。Environment 中有一组默认 profile（默认情况下是 [default]），如果没有设置激活的 profile，则使用默认 profile。换句话说，如果没有显式地激活 profile，那么就会加载 application-default.properties。 特定于 profile 的属性从相同的位置加载到标准 application.properties 中，特定于 profile的文件总是覆盖非特定的文件，无论特定于 profile 的文件是否在您的打包 jar 内或外部。 如果指定了多个 profile，则应用最后的策略。例如，spring.profiles.active 属性指定的 profile，在通过 SpringApplication API 配置后，被添加，因此优先。 如果您在 spring.config.location 中指定了任何文件，这些文件特定于 profile 的变体不会被考虑。如果您还想使用特定于 profile 的属性，使用在 spring.config.location 中的目录。 属性中的占位符在 application.properties 中的值在使用时通过现有 Environment 进行过滤，因此您可以引用之前定义的值（例如，从系统属性）。 12app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot application 您还可以使用此技术创建存在于 Spring Boot 属性中的“短”变体。请参阅*使用“短”命令行参数*来获取详细信息。 使用 YAML 代替 PropertiesYAML 是 JSON 的超集，因此，它是一种用于指定分层配置数据的方便格式。当您的类路径上有 SnakeYAML 库时，SpringApplication 类会自动支持 YAML 作为属性的替代品。 如果你使用“启动器”，SnakeYAML 是由 spring-boot-starter 自动提供的。 加载 YAML Spring 框架提供了两个方便的类，可以用来加载 YAML 文档。YamlPropertiesFactoryBean 将 YAML 加载为 Properties，而 YamlMapFactoryBean 将 YAML 加载为 Map。 例如，考虑以下 YAML 文档： 1234567environments: dev: url: http://dev.example.com name: Developer Setup prod: url: http://another.example.com name: My Cool App 前面的示例将转换为以下属性： 1234environments.dev.url=http://dev.example.comenvironments.dev.name=Developer Setupenvironments.prod.url=http://another.example.comenvironments.prod.name=My Cool App YAML 列表表示为 [index] 引用的属性键。例如，考虑以下 YAML： 1234my:servers: - dev.example.com - another.example.com 前面的示例将转换为这些属性： 12my.servers[0]=dev.example.commy.servers[1]=another.example.com 要使用 Spring Boot 的 Binder 工具（这是 @ConfigurationProperties 所做的）来绑定到这样的属性，您需要在 java.util.List（或 Set）类型的目标 bean 中拥有一个属性，您要么需要提供一个 setter，要么用一个可变值初始化它。例如，下面的示例绑定到前面显示的属性： 123456789@ConfigurationProperties(prefix=&quot;my&quot;)public class Config &#123; private List&lt;String&gt; servers = new ArrayList&lt;String&gt;(); public List&lt;String&gt; getServers() &#123; return this.servers; &#125;&#125; 在 Spring Environment 中暴露 YAML 作为 Properties YamlPropertySourceLoader 类可以用于在 Spring Environment 中将 YAML 作为 PropertySource 公开。这样做可以让您使用带有占位符语法的 @Value 注解来访问 YAML 属性。 多 profile 的 YAML 文档 您可以使用 spring.profiles 键在单个文件中指定多个特定于 profile 的 YAML 文档，以指示文档何时应用，如以下示例所示： 123456789101112server: address: 192.168.1.100---spring: profiles: developmentserver: address: 127.0.0.1---spring: profiles: productionserver: address: 192.168.1.120 在前面的示例中，如果 development profile 是激活的，则 server.address 属性是 127.0.0.1。类似地，如果 production profile 是激活的，则 server.address 属性是 192.168.1.120。如果未启用 development 和 production profile，则该属性的值为 192.168.1.100。 如果在应用程序上下文启动时没有显式激活，则会激活默认 profile。因此，在接下来的 YAML 中，我们为 spring.security.user.password 设置了一个值，仅在 “default” profile 中可用： 12345678server: port: 8000---spring: profiles: default security: user: password: weak 然而，在下面的例子中，密码总是被设置，因为它没有附加到任何 profile，而且必须在必要时显式地重置所有其他 profile： 123456server: port: 8000spring: security: user: password: weak 使用 spring.profiles 元素指定的 Spring profile 可以选择性地使用 ! 字符否定。如果为单个文档指定了否定和非否定的 profile，那么至少有一个非否定的 profile 必须匹配，并且没有任何被否定的 profile 可能匹配。 YAML 缺陷 YAML 文件不能通过使用 @PropertySource 注解来加载。因此，在需要以这种方式加载值的情况下，需要使用 properties 文件。 类型安全的配置属性使用 @Value(&quot;$&#123;property&#125;&quot;) 注解注入配置属性有时会很麻烦，特别是如果您使用的是多个属性，或者您的数据在本质上是分层的。Spring Boot 提供了一种处理属性的替代方法，可以让强类型 bean 管理和验证应用程序的配置，如下面的示例所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example;import java.net.InetAddress;import java.util.ArrayList;import java.util.Collections;import java.util.List;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(&quot;acme&quot;)public class AcmeProperties &#123; private boolean enabled; private InetAddress remoteAddress; private final Security security = new Security(); public boolean isEnabled() &#123; ... &#125; public void setEnabled(boolean enabled) &#123; ... &#125; public InetAddress getRemoteAddress() &#123; ... &#125; public void setRemoteAddress(InetAddress remoteAddress) &#123; ... &#125; public Security getSecurity() &#123; ... &#125; public static class Security &#123; private String username; private String password; private List&lt;String&gt; roles = new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;)); public String getUsername() &#123; ... &#125; public void setUsername(String username) &#123; ... &#125; public String getPassword() &#123; ... &#125; public void setPassword(String password) &#123; ... &#125; public List&lt;String&gt; getRoles() &#123; ... &#125; public void setRoles(List&lt;String&gt; roles) &#123; ... &#125; &#125;&#125; 前面的 POJO 定义了以下属性： acme.enabled，默认值为 false acme.remote-address，一个可以从 String 强转的类型 acme.security.username，使用嵌套的“security”对象，其名称由属性的名称决定。特别是，返回类型在那里没有使用，并且可能是 SecurityProperties acme.security.password acme.security.roles，String 集合 getter 和 setter 通常是强制的，因为绑定是通过标准的 Java bean 属性描述符，就像在 Spring MVC 中一样。在下列情况下，可以省略 setter： Map，只要它们被初始化，就需要一个 getter，但不一定需要 setter，因为它们可以由绑定器进行更改。 可以通过索引（通常是 YAML）或使用单个逗号分隔值（属性）来访问集合和数组。在后一种情况下，setter 是强制的。我们建议总是为这种类型添加一个 setter。如果您初始化一个集合，请确保它不是不可变的（就像前面的例子）。 如果嵌套的 POJO 属性被初始化（比如前面示例中的 Security 字段），则不需要 setter。如果您希望绑定器使用它的默认构造函数来动态创建实例，那么您需要一个 setter。 有些人使用项目 Lombok 自动添加 getter 和 setter。确保 Lombok 不会为这种类型生成任何特定的构造函数，因为它是由容器自动使用来实例化对象的。 最后，只考虑标准的 Java Bean 属性，不支持对静态属性的绑定。 也可参考 @Value 和 @ConfigurationProperties 的区别。 您还需要列出在 @EnableConfigurationProperties 注解中注册的属性类，如下例所示： 1234@Configuration@EnableConfigurationProperties(AcmeProperties.class)public class MyConfiguration &#123;&#125; 当 @ConfigurationProperties bean 以这种方式注册时，bean 有一个常规名称： &lt;prefix&gt;-&lt;fqn&gt;，其中 &lt;prefix&gt; 是 @ConfigurationProperties 注解中指定的环境键前缀，&lt;fqn&gt; 是 bean 的完全限定名称。如果注解没有提供任何前缀，则只使用 bean 的完全限定名。 上面示例中的 bean 名称是 acme-com.example.AcmeProperties。 即使前面的配置为 AcmeProperties 创建了一个常规 bean，我们建议 @ConfigurationProperties 只处理环境，特别是不从上下文注入其他 bean。已经说过，@EnableConfigurationProperties 注解也会自动地应用到您的项目中，这样就可以从 Environment 中配置任何带有 @ConfigurationProperties 的现有 bean。您可以通过确保 AcmeProperties 已经是一个 bean 来快捷地进行 MyConfiguration，如下面的示例所示： 1234567@Component@ConfigurationProperties(prefix=&quot;acme&quot;)public class AcmeProperties &#123; // ... see the preceding example&#125; 这种类型的配置与 SpringApplication 外部 YAML 配置特别有效，如下例所示： 1234567891011# application.ymlacme: remote-address: 192.168.1.1 security: username: admin roles: - USER - ADMIN# additional configuration as required 要使用 @ConfigurationProperties bean，您可以像其他 bean 一样注入它们，如下例所示： 12345678910111213141516171819@Servicepublic class MyService &#123; private final AcmeProperties properties; @Autowired public MyService(AcmeProperties properties) &#123; this.properties = properties; &#125; //... @PostConstruct public void openConnection() &#123; Server server = new Server(this.properties.getRemoteAddress()); // ... &#125;&#125; 使用 @ConfigurationProperties 还可以生成可以被 IDE 使用的 metadata 文件，为您自己的键提供自动完成。详见附录 B 配置 Metadata。 第三方配置 除了使用 @ConfigurationProperties 来注解一个类之外，还可以在 public @Bean 方法上使用它。当您希望将属性绑定到控件之外的第三方组件时，这样做尤其有用。 要从 Environment 属性配置 bean，请将 @ConfigurationProperties 添加到它的 bean 注册，如下例所示： 12345@ConfigurationProperties(prefix = &quot;another&quot;)@Beanpublic AnotherComponent anotherComponent() &#123; ...&#125; 用 another 前缀定义的任何属性都被映射到与前面的 AcmeProperties 示例类似的 AnotherComponent bean。 松散绑定 Spring Boot 使用一些松散的规则将 Environment 属性绑定到 @ConfigurationProperties bean，因此 Environment 属性名和 bean 属性名之间不需要精确匹配。常见的示例中，这是有用的，其中包括短横线分隔的环境属性（例如，context-path 绑定到 contextPath），以及大写的环境属性（例如，PORT 绑定到 port）。 例如，考虑以下 @ConfigurationProperties 类： 1234567891011121314@ConfigurationProperties(prefix=&quot;acme.my-project.person&quot;)public class OwnerProperties &#123; private String firstName; public String getFirstName() &#123; return this.firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125;&#125; 在前面的示例中，可以使用以下属性名称： 属性 注释 acme.my-project.person.first-name Kebab 风格，推荐使用在 .properties 和 .yml 文件中 acme.myProject.person.firstName 标准驼峰语法 acme.my_project.person.first_name 下划线符号，使用在 .properties 和 .yml 文件中的替代格式 ACME_MYPROJECT_PERSON_FIRSTNAME 大写格式，推荐系统环境变量使用 注解的 prefix 必须是 kebab 风格（小写字母、- 分隔，如 acme.my-project.person）。 属性源 简单的 List Properties Files Camel case、kebab case 或 underscore notation Standard list syntax using [ ] or comma-separated values YAML Files Camel case、kebab case 或 underscore notation Standard YAML list syntax or comma-separated values Environment Variables 使用下划线作为定界符的大写格式。_ 不应该在属性名称中使用 Numeric values surrounded by underscores, such as MY_ACME_1_OTHER &#x3D; my.acme[1].other System properties Camel case、kebab case 或 underscore notation Standard list syntax using [ ] or comma-separated values","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"04-自定义start","slug":"spring/SpringBoot/04-自定义start","date":"2021-11-20T12:00:57.000Z","updated":"2022-03-14T09:04:26.894Z","comments":true,"path":"blog/spring/SpringBoot/04-自定义start/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/04-%E8%87%AA%E5%AE%9A%E4%B9%89start/","excerpt":"","text":"自定义strat命名规范:官方命名空间: 123前缀:spring-boot-starter- 模式:spring-boot-starter-模块名 举例:spring-boot-starter-web、spring-boot-starter-jdbc 自定义命名空间: 123后缀:-spring-boot-starter模式:模块-spring-boot-starter举例:mybatis-spring-boot-starter 自定义strat定制strat的配置 12345678@Data@ConfigurationProperties(prefix = &quot;spring.redis&quot;)public class RedisConfig &#123; private String host; private Integer port;&#125; 定制配置类，并且引入@EnableConfigurationProperties注解，使得配置和类进行绑定 1234567891011121314@Configuration@ConditionalOnClass(JackTemplate.class)@EnableConfigurationProperties(RedisConfig.class)public class CustomStarterRun &#123; @Autowired private RedisConfig redisConfig; @Bean public JackTemplate jackTemplate() &#123; JackTemplate jackTemplate = new JackTemplate(redisConfig); return jackTemplate; &#125;&#125; 通过上边其实这个strat也可以使用了，在传统的spring项目中可以通过@Import注解引入CustomStarterRun类就可以了。在SpringBoot可以添加一个META-INF/spring.factories文件 并在该文件中添加如下内容： 123org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.xx.jack.start.CustomStarterRun0#多个用逗号“，”隔开 这样就可以实现自动启动了。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"03-SpringBoot项目启动原理","slug":"spring/SpringBoot/03-SpringBoot项目启动原理","date":"2021-11-20T12:00:56.000Z","updated":"2022-03-14T09:04:26.893Z","comments":true,"path":"blog/spring/SpringBoot/03-SpringBoot项目启动原理/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/03-SpringBoot%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/","excerpt":"","text":"SpringBoot项目启动原理在SpringBoot项目中都会有类似的代码 1234567@SpringBootApplicationpublic class ConfigurationFileApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigurationFileApplication.class, args); &#125;&#125; 创建SpringApplication该类就是SpringBoot应用的启动类。这里就需要看SpringApplication.run方法。该方法也很简单，就是 123public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args);&#125; 这里会创建一个SpringApplication对象 1234567891011121314151617181920public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); // 将启动类放入primarySources this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); // 推算当前web应用类型(webFlux, servlet) this.webApplicationType = WebApplicationType.deduceFromClasspath(); // 下面都是Spring SPI的应用， // 就是去spring.factories 中去获取所有key=org.springframework.context.ApplicationContextInitializer的类 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); // 就是去spring.factories 中去获取所有key: org.springframework.context.ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); // 获取main的class对象 this.mainApplicationClass = deduceMainApplicationClass();&#125; 通过上边可以了解到，这个SpringApplication对象会有一个我们传入的应用启动类的class对象，会把这个class对象放入到primarySources集合中。集合开头的，现在这个primarySources里面有ConfigurationFileApplication.class对象。之所以需要传入这个，是因为需要使用这个class对象来告诉spring的上下文，那些类需要spring容器管理。 这里通过Spring SPI收集ApplicationContextInitializer和ApplicationListener的实现类，然后分别放入集合initializers和listeners中。在SpringBoot中，会默认提供很多实现 总结 获取启动类:根据启动类加载ioc容器 获取web应用类型 Spring SPI读取ApplicationContextInitializer ,ApplicationListener 的实现类， 通过SPI进行解耦（实现全局配置文件、热部署插件） 根据main推算出所在的类 启动看SpringApplication对象的调用的run方法。该方法包含了启动springboot最核心的逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public ConfigurableApplicationContext run(String... args) &#123; // 用来记录当前springboot启动耗时 StopWatch stopWatch = new StopWatch(); // 就是记录了启动开始时间 stopWatch.start(); // 它是任何spring上下文的接口， 所以可以接收任何ApplicationContext实现 ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); // 开启了Headless模式： configureHeadlessProperty(); // 去spring.factroies中读取了SpringApplicationRunListener 的组件， 就是用来发布事件或者运行监听器 SpringApplicationRunListeners listeners = getRunListeners(args); // 发布1.ApplicationStartingEvent事件，在运行开始时发送 listeners.starting(); try &#123; // 根据命令行参数 实例化一个ApplicationArguments ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 预初始化环境： 读取环境变量，读取配置文件信息（基于监听器） ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 忽略beaninfo的bean configureIgnoreBeanInfo(environment); // 打印Banner 横幅 Banner printedBanner = printBanner(environment); // 根据webApplicationType创建Spring上下文 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //预初始化spring上下文 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 加载spring ioc 容器 **相当重要 由于是使用AnnotationConfigServletWebServerApplicationContext 启动的spring容器所以springboot对它做了扩展： // 加载自动配置类：invokeBeanFactoryPostProcessors ， 创建servlet容器onRefresh refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; SpringApplicationRunListener实现类收集123// 去spring.factroies中读取了SpringApplicationRunListener 的组件， 就是用来发布事件或者运行监听器SpringApplicationRunListeners listeners = getRunListeners(args); 首先通过SpringSPI获取SpringApplicationRunListener的实现类，实例化后把这些对象封装成SpringApplicationRunListeners对象，而SpringBoot默认提供了一个实现，这个实现为EventPublishingRunListener。 这里看EventPublishingRunListener的构造函数 1234567891011121314private final SpringApplication application;private final String[] args;private final SimpleApplicationEventMulticaster initialMulticaster;public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125;&#125; 可以看到，这里的使用了Spring提供的事件多播器SimpleApplicationEventMulticaster来完成事件的发布和订阅。而且把在创建SpringApplication对象收集到的ApplicationListener，添加到该多播器中。 从SpringApplicationRunListener这个接口的方法就能猜到这个接口的作用了，就是在SpringBoot的不同时机发布不同的事件的，然后通过这些SpringApplicationRunListener来完成事件的处理。 发布事件是由SpringApplicationRunListeners的方法进行发布。所以spring boot启动阶段的事件处理如下图： 发布ApplicationStartingEvent事件123// 发布1.ApplicationStartingEvent事件，在运行开始时发送// listeners=SpringApplicationRunListenerslisteners.starting(); 收集完SpringApplicationRunListener并完成订阅后，会调用starting方法，看EventPublishingRunListener的该方法 1234public void starting() &#123; // 这里的application，就是前面创建的SpringApplication，args就是main方法的args this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));&#125; 这里就是发布一个ApplicationStartingEvent事件，可以更具需要在spring.factories文件中添加对应的ApplicationListener。 配置对象的初始化 读取完配置后ApplicationEnvironmentPreparedEvent事件 代码继续走，看 1234 // 根据命令行参数 实例化一个ApplicationArguments ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);// 预初始化环境： 读取环境变量，读取配置文件信息（基于ApplicationListener）ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); 源码： 1234567891011121314151617181920212223242526272829303132private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments) &#123; // 根据webApplicationType 创建Environment // 会读取环境变量和jvm的-D参数 // Servlet是StandardServletEnvironment // 反应式的是StandardReactiveWebEnvironment // 不是上边的，那就是StandardEnvironment ConfigurableEnvironment environment = getOrCreateEnvironment(); // 将启动命令参数读取环境变量中 configureEnvironment(environment, applicationArguments.getSourceArgs()); // 这里会把ConfigurationPropertySourcesPropertySource放在第一位 ConfigurationPropertySources.attach(environment); // 读取配置文件@PropertySource优先级是最低 // 发布了ApplicationEnvironmentPreparedEvent事件，让ConfigFileApplicationListener来处理 // 该类会做一系列的配置加载，比如环境变量，配置文件 listeners.environmentPrepared(environment); // 将所有spring.main 开头的配置信息绑定SpringApplication的属性中 bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; //更新PropertySources ConfigurationPropertySources.attach(environment); return environment;&#125; 这里先创建了ConfigurableEnvironment对象来接收会读取环境变量、jvm的-D参数和main方法传入的值。然后调用下面方法 123456// EventPublishingRunListener@Overridepublic void environmentPrepared(ConfigurableEnvironment environment) &#123; this.initialMulticaster .multicastEvent(new ApplicationEnvironmentPreparedEvent(this.application, this.args, environment));&#125; 这里发布了一个ApplicationEnvironmentPreparedEvent事件。 之前有一批ApplicationListener添加到进了事件多播器中，而 ConfigFileApplicationListener就是读取SpringBoot项目的全局配置文件的. 这里个方法会去读 12345678910// 读config文件夹下的file:./config/ // 读项目的根目录下的file:./// 读类路径下的config文件夹classpath:config/// 读类路径下classpath: 这4个路径下的以application开头的配置文件（properties或者yaml文件） spring cloud 还是读取bootstrap 而ConfigFileApplicationListener是通过PropertySourceLoader来完成配置文件的加载的，会通过SpringSPI加载到ConfigFileApplicationListener中： 然后 打印横幅12345678910111213141516// 打印Banner 横幅Banner printedBanner = printBanner(environment);private Banner printBanner(ConfigurableEnvironment environment) &#123; if (this.bannerMode == Banner.Mode.OFF) &#123; return null; &#125; ResourceLoader resourceLoader = (this.resourceLoader != null) ? this.resourceLoader : new DefaultResourceLoader(getClassLoader()); SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(resourceLoader, this.banner); if (this.bannerMode == Mode.LOG) &#123; return bannerPrinter.print(environment, this.mainApplicationClass, logger); &#125; return bannerPrinter.print(environment, this.mainApplicationClass, System.out);&#125; 横幅的核心代码在 12345678910111213// SpringApplicationBannerPrinterprivate Banner getBanner(Environment environment) &#123; Banners banners = new Banners(); banners.addIfNotNull(getImageBanner(environment)); banners.addIfNotNull(getTextBanner(environment)); if (banners.hasAtLeastOneBanner()) &#123; return banners; &#125; if (this.fallbackBanner != null) &#123; return this.fallbackBanner; &#125; return DEFAULT_BANNER;&#125; 横幅支持图片和文字，而且这两种可以同时出现 图片横幅对于图片，可以看getImageBanner方法 12345678910111213141516static final String BANNER_IMAGE_LOCATION_PROPERTY = &quot;spring.banner.image.location&quot;;static final String[] IMAGE_EXTENSION = &#123; &quot;gif&quot;, &quot;jpg&quot;, &quot;png&quot; &#125;;private Banner getImageBanner(Environment environment) &#123; String location = environment.getProperty(BANNER_IMAGE_LOCATION_PROPERTY); if (StringUtils.hasLength(location)) &#123; Resource resource = this.resourceLoader.getResource(location); return resource.exists() ? new ImageBanner(resource) : null; &#125; for (String ext : IMAGE_EXTENSION) &#123; Resource resource = this.resourceLoader.getResource(&quot;banner.&quot; + ext); if (resource.exists()) &#123; return new ImageBanner(resource); &#125; &#125; return null;&#125; 这里的意思就是如果环境变量或者配置文件或者启动参数设置了spring.banner.image.location=图片，这个参数的话，那么在启动时就打印这张图片。 如果没有，就看下有没有resource目录下有没有banner.jpg、banner.png、banner.gif&#96;文件。 文字横幅12345678private Banner getTextBanner(Environment environment) &#123; String location = environment.getProperty(&quot;spring.banner.location&quot;, &quot;banner.txt&quot;); Resource resource = this.resourceLoader.getResource(location); if (resource.exists()) &#123; return new ResourceBanner(resource); &#125; return null;&#125; 这个也很简答，就是如果环境变量或者配置文件或者启动参数设置了spring.banner.location=文件 ，那么就答应文件的内容，如果没有就看下resource目录下有没有banner.txt，如果有的话就答应这个banner.txt文件的内容 创建Spring上下文 AnnotationConfigServletWebServerApplicationContext 123ConfigurableApplicationContext context = null; // 创建上下文对象context = createApplicationContext(); 看源码： 12345678910111213141516171819202122232425262728293031323334// Servletpublic static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot; + &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;// 反应式public static final String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = &quot;org.springframework.&quot; + &quot;boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext&quot;;// 默认public static final String DEFAULT_CONTEXT_CLASS = &quot;org.springframework.context.&quot; + &quot;annotation.AnnotationConfigApplicationContext&quot;;protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; 预初始化上下文 最后发布ApplicationContextInitializedEvent事件 接着执行了 123// context = AnnotationConfigServletWebServerApplicationContext// environment = ConfigurableEnvironment 包含了全部的变量prepareContext(context, environment, listeners, applicationArguments, printedBanner); 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; context.setEnvironment(environment); postProcessApplicationContext(context); // 拿到之前通过SpringSPI获取到的所有ApplicationContextInitializer对象 // 循环调用initialize方法.完成初始化 // 扩展点：可以修改下上下的一些值 applyInitializers(context); // 发布ApplicationContextInitializedEvent事件 listeners.contextPrepared(context); if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // 获取当前spring上下文beanFactory (负责创建bean) ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; // 在Spring下如果出现2个重名的bean, 则后读取到的会覆盖前面 // 在SpringBoot 在这里设置了不允许覆盖， 当出现2个重名的bean 会抛出异常 if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; // 设置当前spring容器是不是要将所有的bean设置为懒加载 if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); // 读取主启动类,将它注册为BD、就像我们以前register(启动类);一个意思 （因为后续要根据配置类解析配置的所有bean) load(context, sources.toArray(new Object[0])); // 读取完配置类后发布ApplicationPreparedEvent事件。 listeners.contextLoaded(context);&#125; 启动Spring容器 AbstractApplicationContext.refresh 12345678910111213141516171819202122// SpringApplication// 核心方法，启动spring容器refreshContext(context);private void refreshContext(ConfigurableApplicationContext context) &#123; // 调用AbstractApplicationContext.refresh // 这里的ApplicationContext是AnnotationConfigServletWebServerApplicationContext refresh(context); // 这里会注册jvm关闭前执行的钩子方法 // 就是和close方法差不多，只是执行的时机不同 // close是由别的地方主动调用的，比如Servlet容器关闭前 // 而这里是jvm关闭前，由jvm主动调用的 if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125;&#125; 这里就是调用AbstractApplicationContext.refresh方法，这个方法在Spring中就已经讲过了。 发起启动完成事件——ApplicationStartedEvent12// SpringApplicationlisteners.started(context); 内嵌Tomcat使用00-嵌入式Tomcat SpringBoot的ApplicationContext的onRefresh方法——Servlet容器初始化SpringBoot内嵌Tomcat启动时发生在AbstractApplicationContext.refresh方法中的，在这个方法中会调用onRefresh，该方法的调用时机发生在BeanDefinition已经创建完成，在Spring Bean的bean初始化前调用的。而这个方法中会启动内嵌tomcat。 从上边的源码分析可知，这里的ApplicationContext是AnnotationConfigServletWebServerApplicationContext，该类重写了onRefresh。看源码 12345678910111213// ServletWebServerApplicationContext// AnnotationConfigServletWebServerApplicationContext的父类@Overrideprotected void onRefresh() &#123; super.onRefresh(); try &#123; createWebServer(); &#125; catch (Throwable ex) &#123; throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex); &#125;&#125; creaetWebServer方法源码 12345678910111213141516171819202122/* * 创建servlet容器 */// ServletWebServerApplicationContextprivate void createWebServer() &#123; WebServer webServer = this.webServer; ServletContext servletContext = getServletContext(); if (webServer == null &amp;&amp; servletContext == null) &#123; ServletWebServerFactory factory = getWebServerFactory(); // 主要看这个方法 this.webServer = factory.getWebServer(getSelfInitializer()); &#125; else if (servletContext != null) &#123; try &#123; getSelfInitializer().onStartup(servletContext); &#125; catch (ServletException ex) &#123; throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex); &#125; &#125; initPropertySources();&#125; 该方法需要分两种情况 内置的tomcat 外置的tomcat 如果ServletContext servletContext = getServletContext();这行代码方会null就走内置tomcat 内置Tomcat1234// ServletWebServerApplicationContextServletWebServerFactory factory = getWebServerFactory();// 主要看这个方法this.webServer = factory.getWebServer(getSelfInitializer()); 这里的getWebServerFactory就是从beanFactory中获取一个实现了ServletWebServerFactory接口的类。这个接口是SpringBoot提供的，而且也提供了下面的实现类。 而TomcatServletWebServerFactory就是用来创建内嵌Tomcat的。 而这个类是是通过自动配置类ServletWebServerFactoryAutoConfiguration引入的。 看TomcatServletWebServerFactory的getWebServer 12345678910111213141516171819202122@Overridepublic WebServer getWebServer(ServletContextInitializer... initializers) &#123; if (this.disableMBeanRegistry) &#123; Registry.disableRegistry(); &#125; Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); connector.setThrowOnFailure(true); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); // new TomcatWebServer(tomcat, getPort() &gt;= 0) return getTomcatWebServer(tomcat);&#125; 会在创建TomcatWebServer对象的同时，启动tomcat 123456public TomcatWebServer(Tomcat tomcat, boolean autoStart) &#123; Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;); this.tomcat = tomcat; this.autoStart = autoStart; initialize();&#125; 外置的tomcat使用： 下载tomcat服务 设置当前maven项目的打包方式 12&lt;!--打包方式 默认是jar--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 让tomcat相关的依赖不参与打包部署 ，因为外置tomcat服务器已经有这些jar包 123456&lt;!--让它不参与打包部署--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 为了让它支持springboot需要加上： 才能启动springboot应用 123456public class TomcatStartSpringBoot extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(Application.class); &#125;&#125; 放到tomcat运行 这里讲的重点在第4步，这一步其实就和单纯的使用SpringMVC一样。单纯使用Spring的话，我们在项目中需要提供一个继承AbstractAnnotationConfigDispatcherServletInitializer的类。而SpringBoot是SpringBootServletInitializer。 SpringMVC详情看springMVC启动讲解.md 所以看SpringBootServletInitializer的onStartup方法， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void onStartup(ServletContext servletContext) throws ServletException &#123; // Logger initialization is deferred in case an ordered // LogServletContextInitializer is being used this.logger = LogFactory.getLog(getClass()); WebApplicationContext rootAppContext = createRootApplicationContext(servletContext); if (rootAppContext != null) &#123; servletContext.addListener(new ContextLoaderListener(rootAppContext) &#123; @Override public void contextInitialized(ServletContextEvent event) &#123; // no-op because the application context is already initialized &#125; &#125;); &#125; else &#123; this.logger.debug(&quot;No ContextLoaderListener registered, as createRootApplicationContext() did not &quot; + &quot;return an application context&quot;); &#125;&#125;protected WebApplicationContext createRootApplicationContext(ServletContext servletContext) &#123; SpringApplicationBuilder builder = createSpringApplicationBuilder(); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info(&quot;Root context already created (using as parent).&quot;); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers(new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigServletWebServerApplicationContext.class); builder = configure(builder); builder.listeners(new WebEnvironmentPropertySourceInitializer(servletContext)); SpringApplication application = builder.build(); if (application.getAllSources().isEmpty() &amp;&amp; MergedAnnotations.from(getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) &#123; application.addPrimarySources(Collections.singleton(getClass())); &#125; Assert.state(!application.getAllSources().isEmpty(), &quot;No SpringApplication sources have been defined. Either override the &quot; + &quot;configure method or add an @Configuration annotation&quot;); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class)); &#125; return run(application);&#125; 这里很简答，就是 1234SpringApplication springApplication = new SpringApplication(Application.class);// 有很多属性可以设置// springApplication.setspringApplication.run(args); 而在springApplication启动的时候，会通过Sping SPI引入DispatcherServletAutoConfiguration自动配置类，@Bean了DispatcherServletRegistrationBean进去。 回到ServletWebServerApplicationContext.createWebServer方法，外置Tomcat会走到这里 1234567891011121314getSelfInitializer().onStartup(servletContext);private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() &#123; return this::selfInitialize;&#125;private void selfInitialize(ServletContext servletContext) throws ServletException &#123; prepareWebApplicationContext(servletContext); registerApplicationScope(servletContext); WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext); for (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123; beans.onStartup(servletContext); &#125;&#125; getServletContextInitializerBeans方法就会获取到DispatcherServletRegistrationBean，然后执行onStartup。 最后 1servletContext.addServlet(servletName, dispatcherServlet);","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"02-为什么SpringBoot的jar可以直接运行","slug":"spring/SpringBoot/02-为什么SpringBoot的jar可以直接运行","date":"2021-11-20T12:00:55.000Z","updated":"2022-03-14T09:04:26.824Z","comments":true,"path":"blog/spring/SpringBoot/02-为什么SpringBoot的jar可以直接运行/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/02-%E4%B8%BA%E4%BB%80%E4%B9%88SpringBoot%E7%9A%84jar%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%90%E8%A1%8C/","excerpt":"","text":"为什么SpringBoot的jar可以直接运行SpringBoot项目我们可以只通过jar -jar一行命令便启动一个web项目。 java -jar做了什么先要弄清楚java -jar命令做了什么，在oracle官网找到了该命令的描述： 1If the -jar option is specified, its argument is the name of the JAR file containing class and resource files for the application. The startup class must be indicated by the Main-Class manifest header in its source code. 翻译 1如果指定了-jar参数，后面的参数就是jar文件名，这个jar文件包含了应用的class文件和资源文件。启动类必须由源码中的manifest的Main-Class指定 其实就是java -jar中会去jar包中找META-INF/MANIFEST.MF文件，在这个文件中找到真正的启动类 这是某个SpringBoot项目的jar包中的文件 这里就是通过 1Main-Class: org.springframework.boot.loader.JarLauncher 指定了真正的启动类。 疑惑出现在MANIFEST.MF文件中有这么一行内容： 1Start-Class: com.tulingxueyuan.Application 前面的java官方文档中，只提到过Main-Class ，并没有提到Start-Class。 Start-Class的值是com.tulingxueyuan.Application，这是我们的java代码中的唯一类，也是应用的真正的应用启动类； 所以问题就来了：理论上看，执行java -jar命令时JarLauncher类会被执行，但实际上是com.tulingxueyuan.Application被执行了，这其中发生了什么呢？为什么要这么做呢？ 其中，Java没有提供任何标准的方式来加载嵌套的jar文件（即，它们本身包含在jar中的jar文件）。 Jar包的打包插件及核心方法Spring Boot项目的pom.xml文件中默认使用如下插件进行打包： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行maven clean package之后，会生成两个文件： 12springboot_starter-0.0.1-SNAPSHOT.jarspringboot_starter-0.0.1-SNAPSHOT.jar.original spring-boot-maven-plugin项目存在于spring-boot-tools目录中。spring-boot-maven-plugin默认有5个goals：repackage、run、start、stop、build-info。 在打包的时候默认使用的是repackage。 spring-boot-maven-plugin的repackage能够将mvn package生成的软件包，再次打包为可执行的软件包，并将mvn package生成的软件包重命名为*.original。 spring-boot-maven-plugin的repackage在代码层面调用了RepackageMojo的execute方法，而在该方法中又调用了repackage方法。repackage方法代码及操作解析如下： 123456789101112131415161718192021222324private void repackage() throws MojoExecutionException &#123; // maven生成的jar，最终的命名将加上.original后缀 Artifact source = getSourceArtifact(); // 最终为可执行jar，即fat jar File target = getTargetFile(); // 获取重新打包器，将maven生成的jar重新打包成可执行jar Repackager repackager = getRepackager(source.getFile()); // 查找并过滤项目运行时依赖的jar Set&lt;Artifact&gt; artifacts = filterDependencies(this.project.getArtifacts(), getFilters(getAdditionalFilters())); // 将artifacts转换成libraries Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack, getLog()); try &#123; // 获得Spring Boot启动脚本 LaunchScript launchScript = getLaunchScript(); // 执行重新打包，生成fat jar repackager.repackage(target, libraries, launchScript); &#125;catch (IOException ex) &#123; throw new MojoExecutionException(ex.getMessage(), ex); &#125; // 将maven生成的jar更新成.original文件 updateArtifact(source, target, repackager.getBackupFile());&#125; 执行以上命令之后，便生成了打包结果对应的两个文件。下面针对文件的内容和结构进行一探究竟。 jar包目录结构首先来看看jar的目录结构，都包含哪些目录和文件，解压jar包可以看到如下结构： 12345678910111213springboot_starter-0.0.1-SNAPSHOT.jar├── META-INF│ └── MANIFEST.MF├── BOOT-INF│ ├── classes│ │ └── 应用程序类│ └── lib│ └── 第三方依赖jar└── org └── springframework └── boot └── loader └── springboot启动程序 META-INF内容1234567891011Manifest-Version: 1.0Created-By: Maven Jar Plugin 3.2.0Build-Jdk-Spec: 17Implementation-Title: 12_springboot_starterImplementation-Version: 0.0.1-SNAPSHOTMain-Class: org.springframework.boot.loader.JarLauncherStart-Class: com.tulingxueyuan.ApplicationSpring-Boot-Version: 2.3.6.RELEASESpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx 可以看到有Main-Class是org.springframework.boot.loader.JarLauncher ，这个是jar启动的Main函数。 还有一个Start-Class是com.tulingxueyuan.Application，这个是我们应用自己的Main函数。 Archive的概念在继续了解底层概念和原理之前，我们先来了解一下Archive的概念： archive即归档文件，这个概念在linux下比较常见。 通常就是一个tar&#x2F;zip格式的压缩包。 jar是zip格式。 SpringBoot抽象了Archive的概念，一个Archive可以是jar（JarFileArchive），可以是一个文件目录（ExplodedArchive），可以抽象为统一访问资源的逻辑层。关于Spring Boot中Archive的源码如下： 12345678public interface Archive extends Iterable&lt;Archive.Entry&gt; &#123; // 获取该归档的url URL getUrl() throws MalformedURLException; // 获取jar!/META-INF/MANIFEST.MF或[ArchiveDir]/META-INF/MANIFEST.MF Manifest getManifest() throws IOException; // 获取jar!/BOOT-INF/lib/*.jar或[ArchiveDir]/BOOT-INF/lib/*.jar List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException;&#125; SpringBoot定义了一个接口用于描述资源，也就是org.springframework.boot.loader.archive.Archive。该接口有两个实现，分别是org.springframework.boot.loader.archive.ExplodedArchive和org.springframework.boot.loader.archive.JarFileArchive。前者用于在文件夹目录下寻找资源，后者用于在jar包环境下寻找资源。而在SpringBoot打包的fatJar中，则是使用后者。 JarFile：对jar包的封装，每个JarFileArchive都会对应一个JarFile。JarFile被构造的时候会解析内部结构，去获取jar包里的各个文件或文件夹，这些文件或文件夹会被封装到Entry中，也存储在JarFileArchive中。如果Entry是个jar，会解析成JarFileArchive。 比如一个JarFileArchive对应的URL为： 1jar:file:/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/ 它对应的JarFile为： 1/Users/format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar 这个JarFile有很多Entry，比如： 123456789META-INF/META-INF/MANIFEST.MFspring/spring/study/....spring/study/executablejar/ExecutableJarApplication.classlib/spring-boot-starter-1.3.5.RELEASE.jarlib/spring-boot-1.3.5.RELEASE.jar... JarFileArchive内部的一些依赖jar对应的URL(SpringBoot使用org.springframework.boot.loader.jar.Handler处理器来处理这些URL)： 123jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-starter-web-1.3.5.RELEASE.jar!/jar:file:/Users/Format/Develop/gitrepository/springboot-analysis/springboot-executable-jar/target/executable-jar-1.0-SNAPSHOT.jar!/lib/spring-boot-loader-1.3.5.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class 我们看到如果有jar包中包含jar，或者jar包中包含jar包里面的class文件，那么会使用 !&#x2F; 分隔开，这种方式只有org.springframework.boot.loader.jar.Handler能处理，它是SpringBoot内部扩展出来的一种URL协议。 ### JarLauncher 从MANIFEST.MF可以看到Main函数是JarLauncher，下面来分析它的工作流程。JarLauncher类的继承结构是： 12class JarLauncher extends ExecutableArchiveLauncherclass ExecutableArchiveLauncher extends Launcher 按照定义，JarLauncher可以加载内部&#x2F;BOOT-INF&#x2F;lib下的jar及&#x2F;BOOT-INF&#x2F;classes下的应用class，其实JarLauncher实现很简单： 123456public class JarLauncher extends ExecutableArchiveLauncher &#123; public JarLauncher() &#123;&#125; public static void main(String[] args) throws Exception &#123; new JarLauncher().launch(args); &#125;&#125; 其主入口新建了JarLauncher并调用父类Launcher中的launch方法启动程序。在创建JarLauncher时，父类ExecutableArchiveLauncher找到自己所在的jar，并创建archive。 JarLauncher继承于org.springframework.boot.loader.ExecutableArchiveLauncher。该类的无参构造方法最主要的功能就是构建了当前main方法所在的FatJar的JarFileArchive对象。下面来看launch方法。该方法主要是做了2个事情： 以FatJar为file作为入参，构造JarFileArchive对象。获取其中所有的资源目标，取得其Url，将这些URL作为参数，构建了一个URLClassLoader。 以第一步构建的ClassLoader加载MANIFEST.MF文件中Start-Class指向的业务类，并且执行静态方法main。进而启动整个程序。 1234567891011121314151617181920212223242526272829303132public abstract class ExecutableArchiveLauncher extends Launcher &#123; private final Archive archive; public ExecutableArchiveLauncher() &#123; try &#123; // 找到自己所在的jar，并创建Archive this.archive = createArchive(); &#125; catch (Exception ex) &#123; throw new IllegalStateException(ex); &#125; &#125;&#125; public abstract class Launcher &#123; protected final Archive createArchive() throws Exception &#123; ProtectionDomain protectionDomain = getClass().getProtectionDomain(); CodeSource codeSource = protectionDomain.getCodeSource(); URI location = (codeSource == null ? null : codeSource.getLocation().toURI()); String path = (location == null ? null : location.getSchemeSpecificPart()); if (path == null) &#123; throw new IllegalStateException(&quot;Unable to determine code source archive&quot;); &#125; File root = new File(path); if (!root.exists()) &#123; throw new IllegalStateException( &quot;Unable to determine code source archive from &quot; + root); &#125; return (root.isDirectory() ? new ExplodedArchive(root) : new JarFileArchive(root)); &#125;&#125; 在Launcher的launch方法中，通过以上archive的getNestedArchives方法找到&#x2F;BOOT-INF&#x2F;lib下所有jar及&#x2F;BOOT-INF&#x2F;classes目录所对应的archive，通过这些archives的url生成LaunchedURLClassLoader，并将其设置为线程上下文类加载器，启动应用。 1234567891011121314151617181920212223protected void launch(String[] args) throws Exception &#123; JarFile.registerUrlProtocolHandler(); ClassLoader classLoader = createClassLoader(getClassPathArchives()); launch(args, getMainClass(), classLoader);&#125;protected List&lt;Archive&gt; getClassPathArchives() throws Exception &#123; List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(this.archive.getNestedArchives(this::isNestedArchive)); postProcessClassPathArchives(archives); return archives;&#125;protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception &#123; List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size()); for (Archive archive : archives) &#123; urls.add(archive.getUrl()); &#125; return createClassLoader(urls.toArray(new URL[0]));&#125;protected ClassLoader createClassLoader(URL[] urls) throws Exception &#123; return new LaunchedURLClassLoader(urls, getClass().getClassLoader());&#125; 至此，才执行我们应用程序主入口类的main方法，所有应用程序类文件均可通过&#x2F;BOOT-INF&#x2F;classes加载，所有依赖的第三方jar均可通过&#x2F;BOOT-INF&#x2F;lib加载。 123456protected void launch(String[] args, String mainClass, ClassLoader classLoader) throws Exception &#123; // 关键步骤，这时了启动线程的ClassLoader。 Thread.currentThread().setContextClassLoader(classLoader); // 这里知识通过反射调用main方法 createMainMethodRunner(mainClass, args, classLoader).run();&#125; URLStreamHandlerjava中描述资源常使用URL。而URL有一个方法用于打开链接java.net.URL#openConnection()。由于URL用于表达各种各样的资源，打开资源的具体动作由java.net.URLStreamHandler这个类的子类来完成。根据不同的协议，会有不同的handler实现。而JDK内置了相当多的handler实现用于应对不同的协议。比如jar、file、http等等。URL内部有一个静态HashTable属性，用于保存已经被发现的协议和handler实例的映射。 获得URLStreamHandler有三种方法： 实现URLStreamHandlerFactory接口，通过方法URL.setURLStreamHandlerFactory设置。该属性是一个静态属性，且只能被设置一次。 直接提供URLStreamHandler的子类，作为URL的构造方法的入参之一。但是在JVM中有固定的规范要求： 子类的类名必须是Handler，同时最后一级的包名必须是协议的名称。比如自定义了Http的协议实现，则类名必然为xx.http.Handler； 具体的需要看JDK提供的URL类 JVM启动的时候，需要设置java.protocol.handler.pkgs系统属性，如果有多个实现类，那么中间用|隔开。因为JVM在尝试寻找Handler时，会从这个属性中获取包名前缀，最终使用包名前缀.协议名.Handler，使用Class.forName方法尝试初始化类，如果初始化成功，则会使用该类的实现作为协议实现。而SpringBoot就是使用了这种模式 为了实现这个目标，SpringBoot首先从支持jar in jar中内容读取做了定制，也就是支持多个!&#x2F;分隔符的url路径。SpringBoot定制了以下两个方面： （1）实现了一个java.net.URLStreamHandler的子类org.springframework.boot.loader.jar.Handler。该Handler支持识别多个!&#x2F;分隔符，并且正确的打开URLConnection。打开的Connection是SpringBoot定制的org.springframework.boot.loader.jar.JarURLConnection实现。 （2）实现了一个java.net.JarURLConnection的子类org.springframework.boot.loader.jar.JarURLConnection。该链接支持多个!&#x2F;分隔符，并且自己实现了在这种情况下获取InputStream的方法。而为了能够在org.springframework.boot.loader.jar.JarURLConnection正确获取输入流，SpringBoot自定义了一套读取ZipFile的工具类和方法。 在JarLauncher的launch方法中有这一行代码 1JarFile.registerUrlProtocolHandler(); 这样就是注册SpringBoot定义的Handler 123456789private static final String PROTOCOL_HANDLER = &quot;java.protocol.handler.pkgs&quot;;private static final String HANDLERS_PACKAGE = &quot;org.springframework.boot.loader&quot;;public static void registerUrlProtocolHandler() &#123; String handlers = System.getProperty(PROTOCOL_HANDLER, &quot;&quot;); System.setProperty(PROTOCOL_HANDLER, (&quot;&quot;.equals(handlers) ? HANDLERS_PACKAGE : handlers + &quot;|&quot; + HANDLERS_PACKAGE)); resetCachedUrlHandlers();&#125; Spring Boot的Jar应用启动流程总结Spring Boot应用打包之后，生成一个Fat jar，包含了应用依赖的jar包和Spring Boot loader相关的类。 Fat jar的启动Main函数是JarLauncher，它负责创建一个LaunchedURLClassLoader来加载&#x2F;lib下面的jar，并以一个新线程调用应用设置的的Main函数。这个main函数所在的类就是通过META-INF/MANIFEST.MF文件的Start-Class指定的。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"01-自动配置原理","slug":"spring/SpringBoot/01-自动配置原理","date":"2021-11-20T12:00:54.000Z","updated":"2022-03-14T09:04:26.821Z","comments":true,"path":"blog/spring/SpringBoot/01-自动配置原理/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/01-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/","excerpt":"","text":"SpringBoot自动配置原理 依赖Spring的知识 简答介绍SpringBoot使用了Spring的DeferredImportSelector接口和SpringSPI来完成自动配置类的引入；然后在引入类中，通过各种注解（@Bean、各种@Conditional注解等）来完成类的引入。 自动配置类的引入流程分析项目中都是有这样的一个启动类 1234567@SpringBootApplicationpublic class ConfigurationFileApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigurationFileApplication.class, args); &#125;&#125; 该启动类有@SpringBootApplication注解。看该注解的定义 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; 。。。&#125; 这里重点看@EnableAutoConfiguration 123456789@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ....&#125; 该注解的作用就是@Import一个类，该类为AutoConfigurationImportSelector。也就意味着该类会被注册到Spring的容器中。看该类的类图： 该类实现了DeferredImportSelector接口。 DeferredImportSelector接口的作用、初始化和执行原理 而且AutoConfigurationImportSelector重写了getImportGroup方法，并返回了AutoConfigurationGroup的Class对象。所以现在的重点看AutoConfigurationGroup的process方法和selectImports方法 SpringSPI的运用——获取自动配置类看AutoConfigurationGroup.process方法。 12345678910111213// AutoConfigurationGrouppublic void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123; Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector, () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;, AutoConfigurationImportSelector.class.getSimpleName(), deferredImportSelector.getClass().getName())); AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector) .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata); this.autoConfigurationEntries.add(autoConfigurationEntry); for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123; this.entries.putIfAbsent(importClassName, annotationMetadata); &#125;&#125; 这里会调用AutoConfigurationImportSelectord的deferredImportSelector方法，看该方法 12345678910111213141516171819// AutoConfigurationImportSelectorprotected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); // SPI获取EnableAutoConfiguration为key的所有类 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); // 把某些自动配置类过滤掉 configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); // 包装成自动配置实体类 return new AutoConfigurationEntry(configurations, exclusions);&#125; 首先，该方法通过Sping的SPI获取到一批全限定名的列表 12345678910111213141516List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);// AutoConfigurationImportSelectorprotected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; // SPI获取EnableAutoConfiguration为key的所有实现类 List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot; + &quot;are using a custom packaging, make sure that file is correct.&quot;); return configurations;&#125;// AutoConfigurationImportSelectorprotected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123; return EnableAutoConfiguration.class;&#125; 上边的代码就是获取项目中META-INF/spring.factories文件定义的 自动配置类列表 而这些类在项目中不一定存在和不一定用到，所以在后面的代码就是对其进行过滤的，这里有两种过滤方式： 通过@SpringBootApplication注解的exclude或者excludeName或者配置spring.autoconfigure.exclude 1234// AutoConfigurationImportSelector.getAutoConfigurationEntrySet&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);checkExcludedClasses(configurations, exclusions);configurations.removeAll(exclusions); 通过AutoConfigurationImportFilter来过滤。 12345678910111213141516171819202122// AutoConfigurationImportSelector.getAutoConfigurationEntryconfigurations = getConfigurationClassFilter().filter(configurations);// AutoConfigurationImportSelectorprivate ConfigurationClassFilter getConfigurationClassFilter() &#123; if (this.configurationClassFilter == null) &#123; // 这里通过SPI获取key为AutoConfigurationImportFilter的实现类 List&lt;AutoConfigurationImportFilter&gt; filters = getAutoConfigurationImportFilters(); for (AutoConfigurationImportFilter filter : filters) &#123; // 检查是否有实现这些接口。 // ResourceLoaderAware、EnvironmentAware、BeanFactoryAware、BeanClassLoaderAware invokeAwareMethods(filter); &#125; this.configurationClassFilter = new ConfigurationClassFilter(this.beanClassLoader, filters); &#125; return this.configurationClassFilter;&#125;// AutoConfigurationImportSelectorprotected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader);&#125; 这里的过滤规则就是根据根据AutoConfigurationImportFilter的返回结果boolean[]，如果这个数组的某个位置为false，就把configurations的对应位置清除掉。 过滤完后就发布一个AutoConfigurationImportEvent事件，该事件由AutoConfigurationImportListener的实现类处理。 1234567891011121314151617// AutoConfigurationImportSelector.getAutoConfigurationEntryfireAutoConfigurationImportEvents(configurations, exclusions);// AutoConfigurationImportSelectorprivate void fireAutoConfigurationImportEvents(List&lt;String&gt; configurations, Set&lt;String&gt; exclusions) &#123; // 用Spring SPI获取AutoConfigurationImportListener的实现类 List&lt;AutoConfigurationImportListener&gt; listeners = getAutoConfigurationImportListeners(); if (!listeners.isEmpty()) &#123; AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, configurations, exclusions); for (AutoConfigurationImportListener listener : listeners) &#123; // 检查是否有实现这些接口。 // ResourceLoaderAware、EnvironmentAware、BeanFactoryAware、BeanClassLoaderAware invokeAwareMethods(listener); listener.onAutoConfigurationImportEvent(event); &#125; &#125;&#125; 最后返回AutoConfigurationEntry对象。返回后就是把AutoConfigurationEntry对象放到autoConfigurationEntries集合中。这个集合就在AutoConfigurationGroup.selectImports中遍历处理。 AutoConfigurationGroup.selectImports方法不看了很简单。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-注解说明","slug":"spring/SpringBoot/00-注解说明","date":"2021-11-20T12:00:53.000Z","updated":"2022-03-14T09:04:26.800Z","comments":true,"path":"blog/spring/SpringBoot/00-注解说明/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/00-%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/","excerpt":"","text":"注解说明jdk注解定义使用@interface，表示该类是一个注解 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inheritedpublic @interface AnnotationDemo &#123;&#125; 这里又涉及了几个jdk提供的注解 @Target 设置当前注解可以标记在哪，常用的有 1234ElementType.TYPE //对象ElementType.METHOD //方法ElementType.FIELD //字段ElementType.PARAMETER //参数 @Retention 当注解标注的类编译以什么方式保留，RetentionPolicy.RUNTIME表示会被jvm加载 @Documented java doc 会生成注解信息 @Inherited 是否会被继承 @SpringBootApplicationSpring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot 需要运行这个类的main方法来启动SpringBoot应用; @Configuration配置类上来标注这个注解。配置类 —– 配置文件;配置类也是容器中的一个组件;@Component。 其中有个属性proxyBeanMethods，该属性表示是否生成代理对象。默认值为true，生成代理对象后，通过对象的方法调用获取的bean就能保证多次调用都只生成一个。 @SpringBootConfigurationSpring Boot的配置类。标注在某个类上，表示这是一个Spring Boot的配置类；该注解其实就是@Configuration注解，只是名字换了而已 @EnableAutoConfiguration开启自动配置功能；以前我们需要配置的东西，Spring Boot帮我们自动配置;@EnableAutoConguration告诉SpringBoot开启自动配置，会帮我们自动去加载 自动配置类。在SpringBoot应用中，我们不需要显示的使用该注解 @ComponentScan扫描指定包下，有@Component注解的类，把这些类变成BeanDefinition。 @AutoConfigurationPackage将当前配置类所在包保存在BasePackages的Bean中。供Spring内部使用 @ImportSpring常用的扩展方式，通过该注解会引入一个类，来实现扩展 @EnableConfigurationProperties比如这样定义 1@EnableConfigurationProperties(&#123;ServerProperties.class&#125;) 表示将配置文件中对应的值和 ServerProperties绑定起来；并把 ServerProperties加入到 IOC 容器中。并注册ConfigurationPropertiesBindingPostProcessor用于将 @ConfigurationProperties的类和配置进行绑定 @ConfigurationProperties讲配置和类进行绑定，并将类注册的Spring的容器中 12345@ConfigurationProperties(prefix=&quot;xyz.demo&quot;)public class ConfigurationPropertiesDemo &#123; private String name; private Integer age;&#125; 通过这样设置后，只要配置中存在 1xyz.demo.name=xieyuezhi 等这样的配置，就会把对应的值设置到ConfigurationPropertiesDemo对象中。这样在项目中就能通过注入使用了。 @Conditional必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效; 派生注解 @Conditional扩展注解作用 (判断是否满足当前指定条件) @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean; @ConditionalOnMissingBean 容器中不存在指定Bean; @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定 比如： @Configuration:表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件。 @ConditionalOnWebApplication:Spring底层@Conditional注解(Spring注解版)，根据不同的条件，如果满足指定的条 件，整个配置类里面的配置就会生效; 判断当前应用是否是web应用，如果是，当前配置类生效。 @ConditionalOnClass:判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器。 @ConditionalOnProperty:判断配置文件中是否存在某个配置 spring.http.encoding.enabled;如果不存在，其中matchIfMissing &#x3D; true表示，没有指定配置时也能生效 @EnableConfigurationProperties({ServerProperties.class}):将配置文件中对应的值和 ServerProperties绑定起来; 并把 ServerProperties加入到 IOC 容器中。并注册ConfigurationPropertiesBindingPostProcessor用于将 @ConfigurationProperties的类和配置进行绑定","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-嵌入式Tomcat","slug":"spring/SpringBoot/00-嵌入式Tomcat","date":"2021-11-20T12:00:52.000Z","updated":"2022-03-14T09:04:26.788Z","comments":true,"path":"blog/spring/SpringBoot/00-嵌入式Tomcat/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/00-%E5%B5%8C%E5%85%A5%E5%BC%8FTomcat/","excerpt":"","text":"嵌入式TomcatMaven: 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;8.5.34&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920//自定义的一个Servlet(专门处理http请求)HttpServlet httpServlet = new HttpServlet() &#123; @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; res.getWriter().write(&quot;hello world!&quot;); &#125;&#125;;//引入嵌入式TomcatTomcat tomcat = new Tomcat();//部署应用的contextContext context = tomcat.addContext(&quot;/demo&quot;,null);//相当于往应用中添加Servlettomcat.addServlet(context,&quot;hello&quot;,httpServlet);//相当于添加了servletMapping 映射信息context.addServletMappingDecoded(&quot;/hello&quot;,&quot;hello&quot;);//启动Tomcat ---生命周期tomcat.init();tomcat.start();tomcat.getServer().await();//用于阻塞Tomcat,等待请求过来//http://localhost:8080/demo/hello 123456Tomcat tomcat = new Tomcat();tomcat.addWebapp(&quot;/ref&quot;,&quot;D:\\\\work_tomcat\\\\ref-comet&quot;);tomcat.getConnector().setPort(80);tomcat.init();tomcat.start();tomcat.getServer().await();","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-如何调试jar包","slug":"spring/SpringBoot/00-如何调试jar包","date":"2021-11-20T12:00:51.000Z","updated":"2022-03-14T09:04:26.787Z","comments":true,"path":"blog/spring/SpringBoot/00-如何调试jar包/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/SpringBoot/00-%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95jar%E5%8C%85/","excerpt":"","text":"如何调试jar包在IDEA中添加一个 配置：","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"从一个带范型的接口中发现了一个问题","slug":"spring/5.2.8/从一个带范型的接口中发现了一个问题","date":"2021-11-20T12:00:50.000Z","updated":"2022-03-14T09:04:26.777Z","comments":true,"path":"blog/spring/5.2.8/从一个带范型的接口中发现了一个问题/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%B8%A6%E8%8C%83%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/","excerpt":"","text":"从一个带范型的接口中发现了一个问题发现一个有意思的，以前没想过这个问题。 定了一个接口 123public interface TestBean&lt;T&gt; &#123; void print(T t);&#125; 实现类是 12345public class SubTestBean implements TestBean&lt;String&gt; &#123; @Override public void print(String s) &#123; &#125;&#125; 这是一个测试： 12345@Testpublic void test6() &#123; Method[] methods = ReflectionUtils.getDeclaredMethods(SubTestBean.class); Arrays.stream(methods).forEach(System.out::println);&#125; 打印的结果： 多了个print(Object)方法。 分析jvm的编译器对于范型是使用类型擦除的，也就是会把T变成Object，这时接口就变成了 123public interface TestBean&lt;Object&gt; &#123; void print(Object t);&#125; 那么实现类中的这个方法 1public void print(String s) &#123;&#125; 只是一个重载的方法，但由于接口的方法是必须在非抽象类中实现的，那么jvm就帮我们写了一个桥接方法，这个方法是这样定义的: 123public void print(Object s) &#123; this.print((String)s);&#125; 所以对于方法 1public void print(String s) &#123;&#125; 这个只是一个重载的方法，重载了桥接方法。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"spel表达式2","slug":"spring/5.2.8/spel表达式2","date":"2021-11-20T12:00:49.000Z","updated":"2022-03-14T09:04:26.776Z","comments":true,"path":"blog/spring/5.2.8/spel表达式2/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/spel%E8%A1%A8%E8%BE%BE%E5%BC%8F2/","excerpt":"","text":"SpEL简介​ 在Spring3中就已经支持EL表达式了, Spring Expression Language(SpEL)是类似于OGNL和JSF EL的表达式语言, 能够在运行时构建复杂表达式, 存取对象属性、调用对象方法等, 而且所有的SpEL都支持XML和Annotation两种方式, 使用的格式均为:#{SpEL expression}. 比如在XML中使用的例子: 12345&lt;bean id=&quot;helloBean&quot; class=&quot;com.***.Hello&quot;&gt; &lt;property name=&quot;item&quot; value=&quot;#&#123;otherBean&#125;&quot; /&gt; &lt;!-- 把otherBean注入到helloBean的item属性中 --&gt; &lt;property name=&quot;itemName&quot; value=&quot;#&#123;otherBean.name&#125;&quot; /&gt; &lt;!-- 把otherBean的name注入到helloBean的itemName属性中 --&gt;&lt;/bean&gt;1234 在Annotation中使用的例子: 12345@Componentpublic class Test &#123; @Value(&quot;#&#123;&#x27;Tom&#x27;.toUpperCase()&#125;&quot;) private String name;&#125; 上面的例子可以看出, 在使用Spring时, 我们已经在不知不觉中使用了SpEL表达式了. 另外我们自己使用SpEL表达式时, 大体可分三个步骤: 123456// 1. 构建解析器ExpressionParser parser = new SpelExpressionParser();// 2. 解析表达式Expression exp = parser.parseExpression(SpEl);// 3. 获取结果exp.getValue(); 这就是使用SpEL的基本方式, 还有许多功能, 下文将举例列举 一、文本表达式1234567 文本表达式支持: 字符串(需要用单引号声明)、日期、数字、布尔类型及null,对数字支持负数、指数及小数, 默认情况下实数使用Double.parseDouble()进行表达式类型转换.1parser.parseExpression(&quot;&#x27;hello&#x27;&quot;).getValue(String.class); // hello , 注意单引号parser.parseExpression(&quot;1.024E+3&quot;).getValue(Long.class); // 1024 , 指数形式parser.parseExpression(&quot;0xFFFF&quot;).getValue(Integer.class); // 65535 , 十六进制parser.parseExpression(&quot;true&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;null&quot;).getValue(); // null 二、变量 变量可以通过StandardEvaluationContext的setVariable方法设置到上下文中, 表达式中可以通过#变量名使用变量;另外, 还可以直接使用构造方法创建对象. 123456789// 定义变量String name = &quot;Tom&quot;;EvaluationContext context = new StandardEvaluationContext(); // 表达式的上下文,context.setVariable(&quot;myName&quot;, name); // 为了让表达式可以访问该对象, 先把对象放到上下文中ExpressionParser parser = new SpelExpressionParser();// 访问变量parser.parseExpression(&quot;#myName&quot;).getValue(context, String.class); // Tom , 使用变量// 直接使用构造方法创建对象parser.parseExpression(&quot;new String(&#x27;aaa&#x27;)&quot;).getValue(String.class); // aaa 三、属性和方法调用属性可直接使用属性名,属性名首字母大小写均可(只有首字母可不区分大小写)。 数组、列表可直接通过下表形式(list[index])访问; map可以直接把key当成索引来访问(map[key]); 方法可以直接访问; 1234567891011121314151617181920// 准备工作Person person = new Person(&quot;Tom&quot;, 18); // 一个普通的POJOList&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;);Map&lt;String, String&gt; map = Maps.newHashMap();map.put(&quot;A&quot;, &quot;1&quot;);map.put(&quot;B&quot;, &quot;2&quot;);EvaluationContext context = new StandardEvaluationContext(); // 表达式的上下文,context.setVariable(&quot;person&quot;, person); // 为了让表达式可以访问该对象, 先把对象放到上下文中context.setVariable(&quot;map&quot;, map);context.setVariable(&quot;list&quot;, list);ExpressionParser parser = new SpelExpressionParser();// 属性parser.parseExpression(&quot;#person.name&quot;).getValue(context, String.class); // Tom , 属性访问parser.parseExpression(&quot;#person.Name&quot;).getValue(context, String.class); // Tom , 属性访问, 但是首字母大写了// 列表parser.parseExpression(&quot;#list[0]&quot;).getValue(context, String.class) // a , 下标// mapparser.parseExpression(&quot;#map[A]&quot;).getValue(context, String.class); // 1 , key// 方法parser.parseExpression(&quot;#person.getAge()&quot;).getValue(context, Integer.class); // 18 , 方法访问 另外列表可以直接写在表达式中, {}表示一个空列表, 比如:parser.parseExpression(&quot;&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;&#125;[0]&quot;).getValue(String.class)跟上面效果一样, 同样会访问列表的第一个元素, 得到&quot;A&quot; 四、类型T操作符可以获取类型, 可以调用对象的静态方法 123456// 获取类型parser.parseExpression(&quot;T(java.util.Date)&quot;).getValue(Class.class); // class java.util.Date// 访问静态成员(方法或属性)parser.parseExpression(&quot;T(Math).abs(-1)&quot;).getValue(Integer.class); // 1// 判断类型parser.parseExpression(&quot;&#x27;asdf&#x27; instanceof T(String)&quot;).getValue(Boolean.class); // true; 五、操作符Spring EL 支持大多数的数学操作符、逻辑操作符、关系操作符. 关系操作符, 包括: eq(&#x3D;&#x3D;), ne(!&#x3D;), lt()&lt;, le(&lt;&#x3D;), gt(&gt;), ge(&gt;&#x3D;) 逻辑运算符, 包括: and(&amp;&amp;), or(||), not(!) 数学操作符, 包括: 加(+), 减(-), 乘(*), 除(&#x2F;), 取模(%), 幂指数(^) 其他操作符, 如: 三元操作符, instanceof, 赋值(&#x3D;), 正则匹配 另外三元操作符有个特殊的用法, 一般用于赋默认值, 比如: parseExpression(“#name?:’defaultName’”), 如果变量name为空时设置默认值. 123456789101112parser.parseExpression(&quot;1 &gt; -1&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;1 gt -1&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;true or true&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;true || true&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;2 ^ 3&quot;).getValue(Integer.class); // 8parser.parseExpression(&quot;true ? true : false&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;#name ?: &#x27;default&#x27;&quot;).getValue(context, String.class); // defaultparser.parseExpression(&quot;1 instanceof T(Integer)&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;&#x27;5.00&#x27; matches &#x27;^-?\\\\d+(\\\\.\\\\d&#123;2&#125;)?$&#x27;&quot;).getValue(Boolean.class); // trueparser.parseExpression(&quot;#person.name&quot;).getValue(context, String.class); // Tom , 原来的值parser.parseExpression(&quot;#person.name = &#x27;Jim&#x27;&quot;).getValue(context, String.class); // Jim , 赋值之后parser.parseExpression(&quot;#person.name&quot;).getValue(context, String.class); // Jim, 赋值起了作用 六、避免空指针 当访问一个对象的属性或方法时, 若该对象为null, 就会出现空指针异常. 安全导航会判断对象是否为null,如果是的话, 就返回null而不是抛出空指针异常. 使用方式就是在对象后面加个?. 如下: 12// 使用这种表达式可以避免抛出空指针异常parser.parseExpression(&quot;#name?.toUpperCase()&quot;).getValue(context, String.class); // null 七、#this变量有个特殊的变量#this来表示当前的对象. 常用于集合的过滤 12// this 使用示例parser.parseExpression(&quot;&#123;1, 3, 5, 7&#125;.?[#this &gt; 3]&quot;).getValue(); // [5, 7] 八、集合选择可以使用选择表达式对集合进行过滤或一些操作，从而生成一个新的符合选择条件的集合, 有如下一些形式: ?[expression]: 选择符合条件的元素 ^[expression]: 选择符合条件的第一个元素 $[expression]: 选择符合条件的最后一个元素 ![expression]: 可对集合中的元素挨个进行处理 对于集合可以配合#this变量进行过滤, 对于map, 可分别对keySet及valueSet分别使用key和value关键字; 12345678910111213141516// 集合parser.parseExpression(&quot;&#123;1, 3, 5, 7&#125;.?[#this &gt; 3]&quot;).getValue(); // [5, 7] , 选择元素parser.parseExpression(&quot;&#123;1, 3, 5, 7&#125;.^[#this &gt; 3]&quot;).getValue(); // 5 , 第一个parser.parseExpression(&quot;&#123;1, 3, 5, 7&#125;.$[#this &gt; 3]&quot;).getValue(); // 7 , 最后一个parser.parseExpression(&quot;&#123;1, 3, 5, 7&#125;.![#this + 1]&quot;).getValue(); // [2, 4, 6, 8] ,每个元素都加1// mapMap&lt;Integer, String&gt; map = Maps.newHashMap();map.put(1, &quot;A&quot;);map.put(2, &quot;B&quot;);map.put(3, &quot;C&quot;);map.put(4, &quot;D&quot;);EvaluationContext context = new StandardEvaluationContext();context.setVariable(&quot;map&quot;, map);parser.parseExpression(&quot;#map.?[key &gt; 3]&quot;).getValue(context); // &#123;4=D&#125;parser.parseExpression(&quot;#map.?[value == &#x27;A&#x27;]&quot;).getValue(context); // &#123;1=A&#125;parser.parseExpression(&quot;#map.?[key &gt; 2 and key &lt; 4]&quot;).getValue(context); // &#123;3=C&#125; 九、模板表达式模板表达式允许文字和表达式混合使用, 一般选择使用#{}作为一个定界符: 1parser.parseExpression(&quot;他的名字为#&#123;#person.name&#125;&quot;, new TemplateParserContext()).getValue(context); // 他的名字为Tom1","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"spel表达式","slug":"spring/5.2.8/spel表达式","date":"2021-11-20T12:00:48.000Z","updated":"2022-03-14T09:04:26.775Z","comments":true,"path":"blog/spring/5.2.8/spel表达式/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"Spel表达式前言 SpEL是一种表达式语言，可以与spring应用程序运行时的对象交互，可简化开发，减少一些逻辑、配置的编写。 既能在配置文件中使用，也能在注解中使用（常用于@Value等）。 一、用法SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。 @Value1234//@Value能修饰成员变量和方法形参 //#&#123;&#125;内就是表达式的内容 @Value(&quot;#&#123;表达式&#125;&quot;) public String arg; 如果修饰成员变量，是从Spring容器中按照SpEL表达式筛选修改数据后，赋值给所修饰的变量；如果修饰方法形参，则是过滤传进来的参数值。 &lt;bean&gt;配置1234&lt;bean id=&quot;xxx&quot; class=&quot;com.java.XXXXX.xx&quot;&gt; &lt;!-- 同@Value,#&#123;&#125;内是表达式的值，可放在property或constructor-arg内 --&gt; &lt;property name=&quot;arg&quot; value=&quot;#&#123;表达式&#125;&quot;&gt;&lt;/bean&gt; 用法跟注解@ Value修饰形参类似 Expression 在使用下面代码时，表达式只能以#name这种模式 123456789101112131415161718192021222324252627282930313233343536import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.expression.spel.support.StandardEvaluationContext; public class SpELTest &#123; public static void main(String[] args) &#123; String spelExpression = &quot;#diffDead/#average * #score&quot;; //创建ExpressionParser解析表达式 ExpressionParser parser = new SpelExpressionParser(); //表达式放置 Expression exp = parser.parseExpression(spelExpression); //执行表达式，默认容器是spring本身的容器：ApplicationContext Object value = exp.getValue(); /**如果使用其他的容器，则用下面的方法*/ //创建一个虚拟的容器EvaluationContext StandardEvaluationContext ctx = new StandardEvaluationContext(); //向容器内添加bean BeanA beanA = new BeanA(); ctx.setVariable(&quot;bean_id&quot;, beanA); Map&lt;String, Object&gt; variables = new HashMap&lt;&gt;(); variables.put(&quot;diffDead&quot;, 25); variables.put(&quot;average&quot;, 21.0); variables.put(&quot;score&quot;, 100); context.setVariables(variables); //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀 //ctx.setRootObject(XXX); //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值 Object value = exp.getValue(ctx); &#125;&#125; 用法比较灵活，可以在代码中使用SpEL进行数据的过滤和修改 以上概念还可以参考：SpEL详解 二、表达式语法在Spring项目中通过@Value等模式使用时，SpEL表达式都是#{}的格式。但是通过ExpressionParser类使用时，SpEL表达式都是以#name格式 表达式语法可以参考：SPEL语法 直接量表达式1234&quot;#&#123;&#x27;Hello World&#x27;&#125;&quot; //字符串&quot;#&#123;5&#125;&quot; //整数#&#123;true&#125; //boolean值等 引用Bean并使用其属性与方法12345678910111213141516通过ID引用bean#&#123;a&#125; //a为bean的id使用bean的属性#&#123;a.b&#125; //a为bean的id使用bean的方法#&#123;a.c()&#125;可链式调用#&#123;a.c().toUpperCase()&#125;通过?(类型安全的运算符)避免空指针(NullPointerException)#&#123;a.c()?.toUpperCase()&#125;即：a.c()存在时才使用toUpperCase() 集合定义使用”{表达式，……}”定义List，如”{1,2,3}” 对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList 方法将列表设置为不可修改。 1List&lt;Integer&gt; result1 = parser.parseExpression(&quot;&#123;1,2,3&#125;&quot;).getValue(List.class); properties文件中的内容如下： 123my.set=foo,barmy.list=foo,barmy.map=&#123;&quot;foo&quot;: &quot;bar&quot;&#125; 分别是我们要注入的Set，List，Map中的内容。注入方式如下： 123456789@Value(&quot;#&#123;$&#123;my.map&#125;&#125;&quot;)private Map&lt;String, String&gt; map;@Value(&quot;#&#123;&#x27;$&#123;my.set&#125;&#x27;&#125;&quot;)private Set&lt;String&gt; set;@Value(&quot;#&#123;&#x27;$&#123;my.list&#125;&#x27;&#125;&quot;)private List&lt;String&gt; list; 集合运算符集合过滤.?[](查询运算符)对集合过滤 #{jukebox.songs.?[artist eq ‘Aerosmith’]} 检查jukebox的歌曲songs的artist属性是不是等于Aerosmith，是的话放入新的集合。 集合访问SpEL目前支持所有集合类型和字典类型的元素访问 语法：”集合[索引]”、”map[key]” .^[]”和“.$[]”，它们分别用来在集合中查询第一个匹配项和最后一个匹配项 12345678910111213141516171819EvaluationContext context = new StandardEvaluationContext(); //即list.get(0)int result1 = parser.parseExpression(&quot;&#123;1,2,3&#125;[0]&quot;).getValue(int.class); //list获取某一项Collection&lt;Integer&gt; collection = new HashSet&lt;Integer&gt;();collection.add(1);collection.add(2); context.setVariable(&quot;collection&quot;, collection);int result2 = parser.parseExpression(&quot;#collection[1]&quot;).getValue(context, int.class); //map获取Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put(&quot;a&quot;, 1); context.setVariable(&quot;map&quot;, map);int result3 = parser.parseExpression(&quot;#map[&#x27;a&#x27;]&quot;).getValue(context, int.class); @Value 123my.set=foo,barmy.list=foo,barmy.map=&#123;&quot;foo&quot;: &quot;bar&quot;&#125; 代码： 12345@Value(&quot;#&#123;$&#123;my.map&#125;&#125;[0]&quot;)private String value1@Value(&quot;#&#123;&#x27;$&#123;my.list&#125;&#x27;&#125;[foo]&quot;)private String value2 投影运算符投影运算符（ .![]），它会从集合的每个成员中选择特定的属性放到另外一个集合中 根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素 语法：”SpEL使用”（list|map）.![投影表达式]” 12345678public class Book &#123; public String name; //书名 public String author; //作者 public String publisher; //出版社 public double price; //售价 public boolean favorite; //是否喜欢&#125; 1234567public class BookList &#123; @Autowired protected ArrayList&lt;Book&gt; list = new ArrayList&lt;Book&gt;() ; protected int num = 0;&#125; 将BookList的实例映射为bean&#x3D;readList，在另一个bean中注入时，进行投影 123//从readList的list下筛选出favorite为true的子集合，再将他们的name字段投为新的list@Value(&quot;#&#123;readList?.list.?[favorite eq true].![name]&#125;&quot;)private ArrayList&lt;String&gt; favoriteBookName; 集合修改可以使用赋值表达式或Expression接口的setValue方法修改； 123456//赋值语句int result = parser.parseExpression(&quot;#array[1] = 3&quot;).getValue(context, int.class); //赋值语句//serValue方法parser.parseExpression(&quot;#array[2]&quot;).setValue(context, 4); 直接使用java代码new&#x2F;instance of​ 此方法只能是java.lang 下的类才可以省略包名 1Expression exp = parser.parseExpression(&quot;new Spring(&#x27;Hello World&#x27;)&quot;); 使用T(Type)​ 使用”T(Type)”来表示java.lang.Class实例，同样，只有java.lang 下的类才可以省略包名。此方法一般用来引用常量或静态方法 1234parser.parseExpression(&quot;T(Integer).MAX_VALUE&quot;);通过T()获取方法#&#123;T(java.lang.Math).random()&#125; 变量获取容器内的变量，可以使用”#bean_id”来获取。有两个特殊的变量，可以直接使用。 #this 使用当前正在计算的上下文 #root 引用容器的root对象 123456String result2 = parser.parseExpression(&quot;#root&quot;).getValue(ctx, String.class); String s = new String(&quot;abcdef&quot;);ctx.setVariable(&quot;abc&quot;,s);//取id为abc的bean，然后调用其中的substring方法parser.parseExpression(&quot;#abc.substring(0,1)&quot;).getValue(ctx, String.class); 方法调用 与Java代码没有什么区别 可以自定义方法，如下： 1234Method parseInt = Integer.class.getDeclaredMethod(&quot;parseInt&quot;, String.class); ctx.registerFunction(&quot;parseInt&quot;, parseInt); ctx.setVariable(&quot;parseInt2&quot;, parseInt); String expression1 = &quot;#parseInt(&#x27;3&#x27;) == #parseInt2(&#x27;3&#x27;)&quot;; “registerFunction”和”setVariable”都可以注册自定义函数，但是两个方法的含义不一样，推荐使用”registerFunction”方法注册自定义函数。 运算符表达式1234567算数表达式（&quot;1+2-3*4/2&quot;）比较表达式（&quot;1&gt;2”）逻辑表达式（&quot;2&gt;1 and (!true or !false)”）赋值表达式（&quot;#variableName=value”）三目表达式（&quot;表达式1?表达式2:表达式3”）正则表达式（&quot;123′ matches ‘\\\\d&#123;3&#125;”）等运算符，都可以直接放在SpEL中 安全保证为了避免操作对象本身可能为null，取属性时报错，定义语法 语法： “对象?” 1list? 语法： “对象?.变量|方法” 1list?.length 当对象为null时，直接返回”null”，不会抛出NullPointerException Elvis运算符是三目运算符的特殊写法，可以避免null报错的情况 1234name != null? name : &quot;other&quot;//简写为：name?:&quot;other&quot;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring的#和$的区别","slug":"spring/5.2.8/Spring的#和$的区别","date":"2021-11-20T12:00:47.000Z","updated":"2022-03-14T09:04:26.746Z","comments":true,"path":"blog/spring/5.2.8/Spring的#和$的区别/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%E7%9A%84#%E5%92%8C$%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"在Spring中有#的使用也有$的使用，那么这两个分别是做什么的呢？ ${key名称}： 12341、用户获取外部文件中指定key的值2、可以出现在xml配置文件中，也可以出现在注解@Value中3、获取properties中环境变量 #{表达式}： 123SpEL表达式的格式，详情点击[Spring的EL表达式](http://blog.csdn.net/u012834750/article/details/79388294)可以出现在xml配置文件中，也可以出现在注解@Value中可以任意表达式，支持运算符等 在使用的时候也允许#{‘${key}’}这样使用，比如： 12@Value(&quot;#&#123;&#x27;$&#123;jdbc.url&#125;&#x27;&#125;&quot;)private String jdbcUrl;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring中的@Qualifier注解","slug":"spring/5.2.8/Spring中的@Qualifier注解","date":"2021-11-20T12:00:46.000Z","updated":"2022-03-14T09:04:26.746Z","comments":true,"path":"blog/spring/5.2.8/Spring中的@Qualifier注解/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%E4%B8%AD%E7%9A%84@Qualifier%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Spring中的@Qualifier注解该注解的作用就是限定注入的类 比如 123@Qualifier(&quot;beanName&quot;)@Autowiredprivate QualifierDemo demo 这样就是限定注入的对象的beanName 如果我自己定义了一个注解 1234567@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifier // 限定符public @interface MyLoadBalanced &#123;&#125; 使用 123@MyLoadBalanced@Autowired(required = false) // 限定注入到list的RestTemplateprivate List&lt;RestTemplate&gt; restTemplates = Collections.emptyList(); 这样的话就限定了注入的RestTemplate，这就要求RestTemplate在创建时也需要加上@MyLoadBalanced注解。比如： 123456789101112131415161718@Configurationpublic class RestConfig &#123; @Bean @LoadBalanced @Primary public RestTemplate restTemplate1() &#123; return new RestTemplate(); &#125; @Bean @MyLoadBalanced public RestTemplate restTemplate2() &#123; return new RestTemplate(); &#125;&#125; 这项定义了RestTemplate后 123@MyLoadBalanced@Autowired(required = false) // 限定注入到list的RestTemplateprivate List&lt;RestTemplate&gt; restTemplates = Collections.emptyList(); 这里注入的RestTemplate对象只有一个，这个bean的Name为restTemplate2。也就是有 @MyLoadBalanced注解的那个。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring中有用的注解或接口或扩展","slug":"spring/5.2.8/Spring中有用的注解或接口或扩展","date":"2021-11-20T12:00:45.000Z","updated":"2022-03-14T09:04:26.738Z","comments":true,"path":"blog/spring/5.2.8/Spring中有用的注解或接口或扩展/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%E4%B8%AD%E6%9C%89%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%88%96%E6%8E%A5%E5%8F%A3%E6%88%96%E6%89%A9%E5%B1%95/","excerpt":"","text":"spel表达式.md [BeanPostProcessor 接口理解.md](BeanPostProcessor 接口理解.md) 00-Spring中重要的接口 Spring中反射的工具类使用 [00 Spring源码中经常出现的工具类](.&#x2F;00 Spring源码中经常出现的工具类) Conditional注解使用.md [Spring Event事件通知机制.md](Spring Event事件通知机制.md) [Sping AOP在开发中的问题.md](Sping AOP在开发中的问题.md) Spring-SPI.md [Spring 全局（切面）的拦截器.md](Spring 全局（切面）的拦截器.md) 11-Spring-用接口实现AOP.md 06-Spring自定义Scope.md 11-Spring中的代理的TargetSource接口的使用.md 12-Spring的事物.md 13-Spring的事务传播属性 14-Spring中使用事物编程 15-Spring缓存注解的使用 18-springMVC使用和扩展 24-SpringMVC在项目有用的代码 25-SpringMVC中的异步请求","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring中反射的工具类使用","slug":"spring/5.2.8/Spring中反射的工具类使用","date":"2021-11-20T12:00:44.000Z","updated":"2022-03-14T09:04:26.737Z","comments":true,"path":"blog/spring/5.2.8/Spring中反射的工具类使用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%E4%B8%AD%E5%8F%8D%E5%B0%84%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring中事物传播属性","slug":"spring/5.2.8/Spring中事物传播属性","date":"2021-11-20T12:00:43.000Z","updated":"2022-03-14T09:04:26.737Z","comments":true,"path":"blog/spring/5.2.8/Spring中事物传播属性/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%E4%B8%AD%E4%BA%8B%E7%89%A9%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Spring中事物传播属性1234567891011121314151617181920PROPAGATION_REQUIRED如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。PROPAGATION_SUPPORTS支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY使用当前的事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER以非事务方式执行，如果当前存在事务，则抛出异常。PROPAGATION_NESTED如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 重点看 123PROPAGATION_REQUIREDPROPAGATION_REQUIRES_NEWPROPAGATION_NESTED 事务传播属性的作用就是控制事务的流转的，比如： 1234567891011@Transactionalfun1()@Transactionalfun2();@Transactionalfun4() &#123; fun()1 fun()2&#125; 在fun4中，比如我希望fun1使用一个事务，fun2使用另一个事务。也比如我希望fun1和fun2用同一个事务。这种涉及到事物的传播的都是通过这个属性来控制的。 所以事物传播属性起作用的前提是一定要有方法中调用了另一个方法，而且这些方法都是有@Transactional注解的。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring-SPI","slug":"spring/5.2.8/Spring-SPI","date":"2021-11-20T12:00:42.000Z","updated":"2022-03-14T09:04:26.737Z","comments":true,"path":"blog/spring/5.2.8/Spring-SPI/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring-SPI/","excerpt":"","text":"在resources/META-INF/目录中添加一个文件spring.factories spring.factories文件的内容： 123456cn.enjoy.handler.InvokeHandler=cn.enjoy.handler.InvokeAllHandlerImpl,cn.enjoy.handler.InvokeAssignHandlerImpl换行cn.enjoy.handler.InvokeHandler=\\cn.enjoy.handler.InvokeAllHandlerImpl,\\cn.enjoy.handler.InvokeAssignHandlerImpl 接口&#x3D;实现类,实现类2 我们只需要通过SpringFactoriesLoader就能获取了 1234// 返回的值是=好后面的内容List&lt;String&gt; invokeHandlerclassNames = SpringFactoriesLoader.loadFactoryNames(InvokeHandler.class, ClassUtils.getDefaultClassLoader());List&lt;InvokeHandler&gt; invokeHandlers = SpringFactoriesLoader.loadFactories(InvokeHandler.class, ClassUtils.getDefaultClassLoader());","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring 全局（切面）的拦截器","slug":"spring/5.2.8/Spring 全局（切面）的拦截器","date":"2021-11-20T12:00:41.000Z","updated":"2022-03-14T09:04:26.736Z","comments":true,"path":"blog/spring/5.2.8/Spring 全局（切面）的拦截器/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%20%E5%85%A8%E5%B1%80%EF%BC%88%E5%88%87%E9%9D%A2%EF%BC%89%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"12345678@Componentpublic class GirlAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;=======GirlAdvice.invoke&quot;); return invocation.proceed(); &#125;&#125; 12345678910111213141516@Componentpublic class SetGlobleAdvice implements BeanPostProcessor, PriorityOrdered &#123; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if(bean instanceof AnnotationAwareAspectJAutoProxyCreator) &#123; AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator = (AnnotationAwareAspectJAutoProxyCreator)bean; annotationAwareAspectJAutoProxyCreator.setInterceptorNames(&quot;girlAdvice&quot;); &#125; return bean; &#125; @Override public int getOrder() &#123; return 45; &#125;&#125; 通过这样的操作后，所有的有切面的代理类都会首先调用GirlAdvice这个增强。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Spring Event事件通知机制","slug":"spring/5.2.8/Spring Event事件通知机制","date":"2021-11-20T12:00:40.000Z","updated":"2022-03-14T09:04:26.736Z","comments":true,"path":"blog/spring/5.2.8/Spring Event事件通知机制/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Spring%20Event%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Spring Event事件通知机制使用事件订阅实现ApplicationListener接口 123456789101112131415161718@Componentpublic class ContextStoppedListener implements ApplicationListener&lt;EnjoyEvent&gt; &#123; @Override public void onApplicationEvent(EnjoyEvent event) &#123; System.out.println(&quot;========EnjoyEvent&quot;); &#125;&#125;@Datapublic class EnjoyEvent extends ApplicationEvent &#123; private String name; public EnjoyEvent(Object source,String name) &#123; super(source); this.name = name; &#125;&#125; 或者使用@EventListener 123456789101112131415161718192021222324252627282930313233343536@Componentpublic class AnoListener &#123; /** * 监听所有ApplicationEvent类型及其子类型的事件（spring） */ @EventListener public void processApplicationEvent(ApplicationEvent event) &#123; System.out.println(&quot;process common event, class:&quot; + event.getClass().getSimpleName()); &#125; /** * 监听 HelloEvent类型 事件 */ @EventListener public void processHelloEvent(EnjoyEvent event) &#123; System.out.println(&quot;process helloEvent, name:&quot; + event.getName()); &#125; /** * 监听 CustomerEvent 类型事件，但是需要满足condition条件,即name=&quot;xieyuezhi&quot; */ @EventListener(condition = &quot;#event.getName().equals(&#x27;miaomiao&#x27;)&quot;) public void processMiaoMiaoEvent(EnjoyEvent event) &#123; System.out.println(&quot;process miaomiao&#x27;s CustomerEvent, name:&quot; + event.getName()); &#125; /** * 支持异步处理事件 */ @Async @EventListener public void processAsyncCustomerEvent(EnjoyEvent event) &#123; System.out.println(&quot;Async process CustomerEvent, name:&quot; + event.getName()); &#125;&#125; 事件发布实现ApplicationContextAware 1234567891011121314151617@Componentpublic class ApplicationContextText implements ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; //可以通过这种模式来天际一个任务执行器，默认情况下调用publishEvent，监听的方法会被同步执行 SimpleApplicationEventMulticaster bean = applicationContext.getBean(SimpleApplicationEventMulticaster.class); //该值默认为空，也就是同步执行，但默认就是为null的 bean.setTaskExecutor(null); &#125; public void publishEvent(ApplicationEvent event) &#123; applicationContext.publishEvent(event); &#125; &#125; ApplicationEventMulticaster的创建ApplicationEventMulticaster是Spring evnet事件通知机制的接口定义，就是用完成事件的通知和订阅的。他的初始化是在AbstractApplicationContext.refresh方法中调用initApplicationEventMulticaster方法来完成初始化的。 1234567891011121314151617//AbstractApplicationContext#initApplicationEventMulticasterpublic static final String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = &quot;applicationEventMulticaster&quot;;protected void initApplicationEventMulticaster() &#123; // DefaultListableBeanFactory ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123; this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); //忽略打印日志 &#125; else &#123; this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); //忽略打印日志 &#125;&#125; 方法也很简单，初始化有两种方式 自己实现ApplicationEventMulticaster接口，然后通过@Component注解，并制定beanName为applicationEventMulticaster。这样就可以实现自己的时间通知机制。 就是什么都不做，使用默认模式。也就是Spring自己创建SimpleApplicationEventMulticaster来完成事件的通知机制 事件订阅的初始化通过使用可知，事件订阅有两种创建方式。第一种就是通过ApplicationListener接口，第二种就是通过@EventListener注解。这两种模式的初始化分别由ApplicationListenerDetector和EventListenerMethodProcessor来完成的。 ApplicationListenerDetector这个类的初始化有两个地方 在AbstractApplicationContext.refresh方法中调用了prepareBeanFactory方法，在这个方法中有这一行代码 1beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); 这个方法会把ApplicationListenerDetector加入到beanFactory的beanPostProcessor集合中 在AbstractApplicationContext.refresh方法中调用了registerBeanPostProcessors方法，在这个方法中： 123protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);&#125; 在方法最后会调用 1beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext)); 把ApplicationListenerDetector加入到beanFactory的beanPostProcessor集合中 这两个方法在Spring的初始化时都会执行，虽然添加了两次，beanFactory.addBeanPostProcessor方法会对先remove掉旧的BeanPostProcessor，然后添加新的 创建完后，在Spring bean的初始化阶段中，当创建完对象并完成初始化后（依赖注入后）,会遍历beanFactory的beanPostProcessor集合然后执行beanPostProcessor的postProcessAfterInitialization方法，所以看该类的方法 12345678910111213@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) &#123; if (bean instanceof ApplicationListener) &#123; // potentially not detected as a listener by getBeanNamesForType retrieval Boolean flag = this.singletonNames.get(beanName); if (Boolean.TRUE.equals(flag)) &#123; // singleton bean (top-level or inner): register on the fly this.applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean); &#125; 。。。。。 &#125; return bean;&#125; 这个方法就是调用applicationContext.addApplicationListener也就是添加事件订阅者的。 这个方法能添加成功有个前提，就是singletonNames.get(beanName);要返回true，而这个singletonNames的设置是通过 123456@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (ApplicationListener.class.isAssignableFrom(beanType)) &#123; this.singletonNames.put(beanName, beanDefinition.isSingleton()); &#125;&#125; 来完成的，这个方法的调用时机就是在Spring bean对象创建后，对注解的收集阶段调用的。详情可以看04-Spring的Bean实例化 EventListenerMethodProcessor 这个类的创建分两步，第一步就是BeanDefinition的创建，第二部就是在AbstractApplicationContext.refresh方法中调用了registerBeanPostProcessors方法，该方法会按照BeanPostProcessor的BeanDefinition的定义，创建对应的BeanPostProcessor对象。现在看第一步EventListenerMethodProcessor的BeanDefinition是在什么时候创建的。 无论是XML文件还是基于注解，在ApplicationContext初始化时，扫描完XML文件和注解，创建完BeanDefinition后，都会调用AnnotationConfigUtils#registerAnnotationConfigProcessors方法（不一定是这个方法，有些ApplicationContext会自己写，而不是掉这个方法）来添加一些必须的BeanPostProcessor。其中就有EventListenerMethodProcessor 12345if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));&#125; 所以在经过AbstractApplicationContext#registerBeanPostProcessors方法后，该类就创建成功了。 然后在Spring bean的初始化。 由于该类实现了接口SmartInitializingSingleton，该接口会在Spring所有的bean都完成了初始化后，都会调用该接口的方法。所以看该类的该方法就好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void afterSingletonsInstantiated() &#123; ConfigurableListableBeanFactory beanFactory = this.beanFactory; String[] beanNames = beanFactory.getBeanNamesForType(Object.class); for (String beanName : beanNames) &#123; ..... processBean(beanName, type); ..... &#125;&#125;private void processBean(final String beanName, final Class&lt;?&gt; targetType) &#123; if (!this.nonAnnotatedClasses.contains(targetType) &amp;&amp; AnnotationUtils.isCandidateClass(targetType, EventListener.class) &amp;&amp; !isSpringContainerClass(targetType)) &#123; //收集有EventListener注解的方法 Map&lt;Method, EventListener&gt; annotatedMethods = null; try &#123; annotatedMethods = MethodIntrospector.selectMethods(targetType, (MethodIntrospector.MetadataLookup&lt;EventListener&gt;) method -&gt; AnnotatedElementUtils.findMergedAnnotation(method, EventListener.class)); &#125; catch (Throwable ex) &#123; ...... &#125; if (CollectionUtils.isEmpty(annotatedMethods)) &#123; this.nonAnnotatedClasses.add(targetType); ..... &#125; else &#123; // Non-empty set of methods ConfigurableApplicationContext context = this.applicationContext; Assert.state(context != null, &quot;No ApplicationContext set&quot;); List&lt;EventListenerFactory&gt; factories = this.eventListenerFactories; Assert.state(factories != null, &quot;EventListenerFactory List not initialized&quot;); for (Method method : annotatedMethods.keySet()) &#123; for (EventListenerFactory factory : factories) &#123; if (factory.supportsMethod(method)) &#123; Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName)); ApplicationListener&lt;?&gt; applicationListener = factory.createApplicationListener(beanName, targetType, methodToUse); if (applicationListener instanceof ApplicationListenerMethodAdapter) &#123; ((ApplicationListenerMethodAdapter) applicationListener).init(context, this.evaluator); &#125; context.addApplicationListener(applicationListener); break; &#125; &#125; &#125; ...... &#125; &#125;&#125; 在processBean中，先收集该类中有@EventListener注解的方法，通过EventListenerFactory列表，创建成ApplicationListenor对象，最后调用了context.addApplicationListener(applicationListener)方法。 下面讲EventListenerFactory。 EventListenerFactoryEventListenerFactory列表的初始化是在方法 123456789@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; this.beanFactory = beanFactory; Map&lt;String, EventListenerFactory&gt; beans = beanFactory.getBeansOfType(EventListenerFactory.class, false, false); List&lt;EventListenerFactory&gt; factories = new ArrayList&lt;&gt;(beans.values()); AnnotationAwareOrderComparator.sort(factories); this.eventListenerFactories = factories;&#125; 完成的，由于该类实现了BeanFactoryPostProcessor接口，所以postProcessBeanFactory方法会在afterSingletonsInstantiated之前被执行。 由于Spring的事件订阅和通知的逻辑都是定义在ApplicationEventMulticaster接口上的，通过接口约定，订阅只接收ApplicationListener的实现类。所以对于有@EventListener注解的方法，需要一个实现了ApplicationListener接口的类来承载对象和方法，最终完成监听者的添加和事件的触发。而EventListenerFactory接口就是用来完成这个ApplicationListener类的创建的。 看这个接口的实现 Spring就提供了两个 DefaultEventListenerFactory TransactionalEventListenerFactory 其中TransactionalEventListenerFactory是用来处理TransactionalEventListener注解的。它是通过注解@EnableTransactionManagement引入的。TransactionalEventListener是用来监听事务的生命周期的（创建、commitBefore，commitAfter等事件的，如果要使用这个事件坚听，事件管理器一定不能添加线程池）。这个在事务章节展开讲。这里重点看DefaultEventListenerFactory。 DefaultEventListenerFactory和EventListenerMethodProcessor的加入时机一样，都是在AnnotationConfigUtils#registerAnnotationConfigProcessors方法中加入到Spring容器中的。 12345if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));&#125; 对于该类，我们看createApplicationListener方法就好了。 1234public ApplicationListener&lt;?&gt; createApplicationListener(String beanName, Class&lt;?&gt; type, Method method) &#123; return new ApplicationListenerMethodAdapter(beanName, type, method);&#125; 所以对于每个@EventListener注解的方法，都会生成一个ApplicationListenerMethodAdapter对象来完成事件通知。由于ApplicationListenerMethodAdapter的onApplicationEvent方法的参数为ApplicationEvent，所以所有事件都会进来，但由于在注解的方法中有指定对应的ApplicationEvent类型（参数只能有一个，不然会报错）和注解有condition属性，所以在ApplicationListenerMethodAdapter内部会通过这两个条件进一步的滤掉事件。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Sping AOP在开发中的问题","slug":"spring/5.2.8/Sping AOP在开发中的问题","date":"2021-11-20T12:00:39.000Z","updated":"2022-03-14T09:04:26.731Z","comments":true,"path":"blog/spring/5.2.8/Sping AOP在开发中的问题/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Sping%20AOP%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"注解事物的调用问题123456789101112131415161718192021222324252627282930@Servicepublic class StudentServiceImpl implements StudentService, ApplicationContextAware &#123; private ApplicationContext applicationContext;// @Autowired// private StudentService studentService; @Override public void eat(String a) &#123; System.out.println(&quot;=====StudentServiceImpl.eat&quot;);// StudentServiceImpl o = (StudentServiceImpl)AopContext.currentProxy();// StudentService bean = applicationContext.getBean(StudentService.class);// bean.sleep(new ArrayList&lt;&gt;()) sleep(new ArrayList&lt;&gt;()) &#125; @Override @Transactional public String sleep(List b) &#123; System.out.println(&quot;=====StudentServiceImpl.sleep&quot;); if(true)throw new RuntimeException(&quot;xx&quot;); return &quot;=====StudentServiceImpl.sleep&quot;; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 如果在代码中这样调用 1studentServiceImpl.eat(&quot;&quot;) 是不会为方法sleep生成一个事务的。因为上边的调用虽然是代理对象调用一个方法，但这个方法没有找到合适的切面，所以最终会有target，也就是目标对象通过反射调用方法。这时在eat方法中，对sleep的调用就相当于this.sleep，而这个this就是目标对象。 所以这样这样 设置了exposeProxy&#x3D;true后可以通过这样调用 123456@Overridepublic void eat(String a) &#123; System.out.println(&quot;=====StudentServiceImpl.eat&quot;); StudentService o = (StudentService)AopContext.currentProxy(); o.sleep(new ArrayList&lt;&gt;())&#125; 或者通过把自己注入到自己里面，然后通过注入的调用方法； 123456789101112131415161718192021222324252627@Servicepublic class StudentServiceImpl implements StudentService, ApplicationContextAware &#123; private ApplicationContext applicationContext; @Autowired private StudentService studentService; @Override public void eat(String a) &#123; System.out.println(&quot;=====StudentServiceImpl.eat&quot;); studentService.sleep(new ArrayList&lt;&gt;()) &#125; @Override @Transactional public String sleep(List b) &#123; System.out.println(&quot;=====StudentServiceImpl.sleep&quot;); if(true)throw new RuntimeException(&quot;xx&quot;); return &quot;=====StudentServiceImpl.sleep&quot;; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 还可以使用使用ApplicationContextAware，获取到上下文对象后获取代理对现象再调用、或者自己调用自己 12345678910111213141516171819202122232425@Servicepublic class StudentServiceImpl implements StudentService, ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void eat(String a) &#123; System.out.println(&quot;=====StudentServiceImpl.eat&quot;); StudentService bean = applicationContext.getBean(StudentService.class); bean.sleep(new ArrayList&lt;&gt;()) &#125; @Override @Transactional public String sleep(List b) &#123; System.out.println(&quot;=====StudentServiceImpl.sleep&quot;); if(true)throw new RuntimeException(&quot;xx&quot;); return &quot;=====StudentServiceImpl.sleep&quot;; &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"Conditional注解使用","slug":"spring/5.2.8/Conditional注解使用","date":"2021-11-20T12:00:38.000Z","updated":"2022-03-14T09:04:26.730Z","comments":true,"path":"blog/spring/5.2.8/Conditional注解使用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/Conditional%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Conditional注解使用使用1234567891011121314@Component@Conditional(value = &#123;CustomCondition.class,CustomCondition1.class&#125;)//@ConditionOnClass(name = &quot;com.enjoy.jack.bean.circular.CircularRefConB&quot;)@ConditionOnProperty(name = &quot;cn.enjoy.flag&quot;)public class ConditionalBean &#123;&#125;public class CustomCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; return true; &#125;&#125; 上边的定义中，只要@Conditional中的中，有一个类的matches返回true，那这个类才会被spring管理。 自定义条件注解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(value = OnBeanCondition.class)public @interface ConditionOnBean &#123; Class&lt;?&gt;[] value() default &#123;&#125;; String[] name() default &#123;&#125;;&#125;@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(value = OnPropertyCondition.class)public @interface ConditionOnProperty &#123; Class&lt;?&gt;[] value() default &#123;&#125;; String[] name() default &#123;&#125;;&#125;public class OnClassCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(metadata.isAnnotated(ConditionOnClass.class.getName())) &#123; Map&lt;String, Object&gt; annotationAttributes = metadata.getAnnotationAttributes(ConditionOnClass.class.getName()); try &#123; ClassUtils.forName(annotationAttributes.get(&quot;name&quot;).toString(),ClassUtils.getDefaultClassLoader()); return true; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; &#125; return false; &#125;&#125;public class OnPropertyCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(metadata.isAnnotated(ConditionOnProperty.class.getName()))&#123; //首先获取到这个类里面的所有的注解信息 AnnotationAttributes annotationAttributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(ConditionOnProperty.class.getName(), false)); String[] names = annotationAttributes.getStringArray(&quot;name&quot;); try &#123; Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;application.properties&quot;, ClassUtils.getDefaultClassLoader()); for (String name : names) &#123; String property = properties.getProperty(name); if(property.equalsIgnoreCase(&quot;true&quot;))&#123; return true; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); return false; &#125; &#125; return false; &#125;&#125;@Component@Conditional(value = &#123;CustomCondition.class,CustomCondition1.class&#125;)//@ConditionOnClass(name = &quot;com.enjoy.jack.bean.circular.CircularRefConB&quot;)@ConditionOnProperty(name = &quot;cn.enjoy.flag&quot;)public class ConditionalBean &#123;&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"CGLIB","slug":"spring/5.2.8/CGLIB","date":"2021-11-20T12:00:37.000Z","updated":"2022-03-14T09:04:26.729Z","comments":true,"path":"blog/spring/5.2.8/CGLIB/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/CGLIB/","excerpt":"","text":"CGLIB APIcglib动态代理其实很简单，就是生成一个子类来继承被代理的类，并且重写它的方法。 12345678910111213141516171819202122232425public class UserServiceImpl implements UserService &#123; @Override public String doSomething0(String param) &#123; System.out.println(&quot;==============doSomething0&quot;); return &quot;doSomething0&quot;; &#125; @Override public String doSomething1(String param) &#123; System.out.println(&quot;==============doSomething1&quot;); return &quot;doSomething1&quot;; &#125; @Override public String doSomething2(String param) &#123; System.out.println(&quot;==============doSomething2&quot;); return &quot;doSomething2&quot;; &#125; @Override public String myMethod(String param) &#123; System.out.println(&quot;==============myMethod&quot;); return &quot;myMethod&quot;; &#125;&#125; 1234567891011121314151617181920public class CglibBeanFactory &#123; public static Object getInstance() &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserServiceImpl.class); CallbackFilter callbackFilter = new CglibCallbackFilter(); enhancer.setCallbackFilter(callbackFilter); Callback callback1 = new DosomethingIntercepter1(); Callback callback2 = new DosomethingIntercepter2(); Callback callback3 = new DosomethingIntercepter3(); //这个NoOp表示no operator，即什么操作也不做，代理类直接调用被代理的方法不进行拦截。 Callback noop = NoOp.INSTANCE; Callback fixdValueCallback = new FixedValueIntercepter(); Callback[] callbacks = &#123;callback1, callback2, callback3, noop, fixdValueCallback&#125;; enhancer.setCallbacks(callbacks); return enhancer.create(); &#125;&#125; 12345678910111213141516public class CglibCallbackFilter implements CallbackFilter &#123; @Override public int accept(Method method) &#123; if (&quot;doSomething0&quot;.equalsIgnoreCase(method.getName())) &#123; return 3; &#125; else if (&quot;doSomething1&quot;.equalsIgnoreCase(method.getName())) &#123; return 1; &#125; else if (&quot;doSomething2&quot;.equalsIgnoreCase(method.getName())) &#123; return 2; &#125; else if (&quot;com.jack.controller.xx&quot;.equalsIgnoreCase(method.getName()))&#123; return 3; &#125; else &#123; return 4; &#125; &#125;&#125; 12345678910public class DosomethingIntercepter1 implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(method.getName() + &quot;执行前...&quot;); //被代理方法 Object object = methodProxy.invokeSuper(o, objects); System.out.println(method.getName() + &quot;执行后...&quot;); return object; &#125;&#125; 1234567public class Test &#123; public static void main(String[] args) &#123; UserService userService = (UserService)CglibBeanFactory.getInstance(); System.out.println(userService.doSomething1(&quot;Jack&quot;)); &#125;&#125; 上面的代码逻辑就是， UserService userService &#x3D; (UserService)CglibBeanFactory.getInstance();生成了一个代理对象了，当调用doSomething1时，会有一个拦截，触发了CglibCallbackFilter的accept方法，更具给方法的返回值，从Callback[]找一个Callback对象执行对应的方法。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"BeanPostProcessor 接口理解","slug":"spring/5.2.8/BeanPostProcessor 接口理解","date":"2021-11-20T12:00:36.000Z","updated":"2022-03-14T09:04:26.729Z","comments":true,"path":"blog/spring/5.2.8/BeanPostProcessor 接口理解/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/BeanPostProcessor%20%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3/","excerpt":"","text":"BeanPostProcessor 接口理解BeanPostProcessor这个接口的原本功能就是在Spring bean初始化阶段，在AbstractAutowireCapableBeanFactory中的doCreateBean方法定义了bean的初始化整个流程。 bean对象的创建 对bean对象对应的类的@Autowire、@Resource、@PostConstruct、@PreDestroy、@Value等注解的收集 添加三级缓存，让其他类能提前发现该对象 populateBean，依赖注入 BeanPostProcessor#postProcessBeforeInitialization invokeInitMethods方法的执行，对InitializingBean接口，afterPropertiesSet，init-method属性调用 BeanPostProcessor#postProcessAfterInitialization 所以，从这个调用时机看，就是在对Bean对象的初始话做了前置和后置处理 在Spring中，扩展都是通过BeanPostProcessor来完成的，Spring通过在BeanPostProcessor的基础做了进一步的扩展，定义了多个接口 SmartInstantiationAwareBeanPostProcessor MergedBeanDefinitionPostProcessor InstantiationAwareBeanPostProcessor 这里主要是两个方法，对象实例化前调用和实例化后调用 DestructionAwareBeanPostProcessor 这些BeanPostProcessor，让这些接口在Spring的初始化阶段的不同实际触发调用，来完成功能的扩展。 获取有@Autowired 注解的构造函数过滤的接口类型是:SmartInstantiationAwareBeanPostProcessor 调用的方法是:determineCandidateConstructors AbstractAutowireCapableBeanFactory#createBeanInstance 收集@Resource、@Autowired、@Value、@PostConstruct和@PreDestroy注解的方法和属性过滤的接口类型是:MergedBeanDefinitionPostProcessor 调用的方法是:postProcessMergedBeanDefinition AbstractAutowireCapobleBeanFactory#applyMergedBeanDefinitionPostProcessors 循环依赖解决中 bean 的提前暴露埋点过滤的接口类型是:SmartInstantiationAwareBeanPostProcessor 调用的方法是:getEarlyBeanReference AbstractAutowireCapobleBeanFactory#getEarlyBeanReference这个方法的掉用实际是当循环依赖发生时才会调用 阻止依赖注入埋点过滤的接口类型是:InstantiationAwareBeanPostProcessor 调用的方法是:postProcessAfterInstantiation AbstractAutowireCapobleBeanFactory#populateBean 依赖注入(DI)埋点过滤的接口类型是:InstantiationAwareBeanPostProcessor 调用的方法是:postProcessProperties(新版本) AbstractAutowireCapobleBeanFactory#populateBean DI 依赖注入后对接口的调用过滤的接口类型是:BeanPostProcessor 调用的方法是:postProcessBeforeInitialization AbstractAutowireCapobleBeanFactory#initializeBean IOC&#x2F;DI 后对接口的调用完成后（动态代理的入口）过滤的接口类型是:BeanPostProcessor 调用的方法是:postProcessAfterInitialization AbstractAutowireCapobleBeanFactory#initializeBean 代理对象的创建过滤的接口类型是:SmartInstantiationAwareBeanPostProcessor 调用的方法是:getEarlyBeanReference AbstractAutowireCapobleBeanFactory#getEarlyBeanReference这个方法的掉用实际是当循环依赖发生时才会调用","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"26-SpringMVC的消息转换器","slug":"spring/5.2.8/26-SpringMVC的消息转换器","date":"2021-11-20T12:00:35.000Z","updated":"2022-03-14T09:04:26.700Z","comments":true,"path":"blog/spring/5.2.8/26-SpringMVC的消息转换器/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/26-SpringMVC%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/","excerpt":"","text":"SpringMVC的消息转换器实现自己的消息转换器通过继承AbstractGenericHttpMessageConverter类来实现自己的消息转换器。 当然可以实现HttpMessageConverter接口，不过这个工作量就大了。 重写boolean supports(Class&lt;?&gt; clazz)方法来指明这个转换器支持的的请求参数类型和返回类型的类是什么。 重写boolean canRead(@Nullable MediaType mediaType)方法来限定这个请求头的Content-Type类型 重写boolean canWrite(@Nullable MediaType mediaType)方法来限定这个响应头的Content-Type类型 重写writeInternal(T t, HttpOutputMessage outputMessage)方法来实现请求内容的转换 重写void writeInternal(T t, @Nullable Type type, HttpOutputMessage outputMessage)方法来实现返回数据的转黄 不一定只能重写上边的方法。可以冲洗很多方法的，根据具体的需求重写方法。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"25-SpringMVC中的异步请求","slug":"spring/5.2.8/25-SpringMVC中的异步请求","date":"2021-11-20T12:00:34.000Z","updated":"2022-03-14T09:04:26.699Z","comments":true,"path":"blog/spring/5.2.8/25-SpringMVC中的异步请求/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/25-SpringMVC%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82/","excerpt":"","text":"SpringMVC中的异步请求 异步请求能提高请求数，但响应时间会更长（相对） 浏览器同步浏览器发起一个request然后会一直待一个响应response，在这期间里面它是阻塞的。比如早期我们在我们在逛电商平台的时候买东西我们打开一个商品的页面，大致流程是不是可能是这样，每次打开一个页面都是由一个线程从头到尾来处理，这个请求需要进行数据库的访问需要把商品价格库存啥的返回页面，还需要去调用第三方接口，比如优惠券接口等我们只有等到这些都处理完成后这个线程才会把结果响应给浏览器，在这等结果期间这个线程只能一直在干等着啥事情也不能干。这样的话是不是会有有一定的性能问题。大致的流程如下： 浏览器异步为了解决上面同步阻塞的问题，再Servlet3.0发布后，提供了一个新特性：异步处理请求。比如我们还是进入商品详情页面，这时候这个前端发起一个请求，然后会有一个线程来执行这个请求，这个请求需要去数据库查询库存、调用第三方接口查询优惠券等。这时候这个线程就不用干等着呢。它的任务到这就完成了，又可以处理下一个请求了。等查询数据库和第三方接口查询优惠券有结果了，这时候会有一个新的线程来把处理结果返回给前端。这样的话线程的工作量是不超级饱和，需要不停的干活，连休息的机会都不给了。 这个异步是纯后端的异步，对前端是无感的，异步也并不会带来响应时间上的优化，原来该执行多久照样还是需要执行多久。但是我们的请求线程（Tomcat 线程）为异步servlet之后，我们可以立即返回，依赖于业务的任务用业务线程来执行，也就是说，Tomcat的线程可以立即回收，默认情况下，Tomcat的核心线程是10，最大线程数是200,我们能及时回收线程，也就意味着我们能处理更多的请求，能够增加我们的吞吐量，这也是异步Servlet的主要作用。 Servlet规范 传统Servlet处理 Web容器会为每个请求分配一个线程，默认情况下，响应完成前，该线程占用的资源都不会被释放。若有些请求需要长时间(例如长处理时间运算、等待某个资源)，就会长时间占用线程所需资源，若这类请求很多，许多线程资源都被长时间占用，会对系统的性能造成负担。 Servlet 3.0新增了异步处理，可以先释放容器分配给请求的线程与相关资源，减轻系统负担，其响应将被延后，但此时客户端仍然堵塞。业务处理交给了业务线程来完成，可以在处理完成(例如长时间运算完成、所需资源已获得)时再对客户端进行响应（包含了HttpRequest和HttpResponse）。 Servlet 3.0异步接收请求后步骤： Servlet 接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；Servlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，客户端仍然堵塞。Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。 SpringMVC支持请求异步处理的返回值解析器 StreamingResponseBodyReturnValueHandler 看supportsReturnType方法 12345678910111213@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; if (StreamingResponseBody.class.isAssignableFrom(returnType.getParameterType())) &#123; return true; &#125; // 如果是ResponseEntity，而且该返回对象的范型为StreamingResponseBody，也就是这样定义 // ResponseEntity&lt;StreamingResponseBody&gt; else if (ResponseEntity.class.isAssignableFrom(returnType.getParameterType())) &#123; Class&lt;?&gt; bodyType = ResolvableType.forMethodParameter(returnType).getGeneric().resolve(); return (bodyType != null &amp;&amp; StreamingResponseBody.class.isAssignableFrom(bodyType)); &#125; return false;&#125; 这个处理器是用来处理StreamingResponseBody返回值的。 其中StreamingResponseBody接口是在Controller里处理输出流的 我们在java中创建I&#x2F;O输入输出流时，一般用完流后都要关闭流，但是在Controller里面，处理Http request是异步的，这个时候如果往request里写入流的时候，我们无法确定什么时候关闭流，例如在完成下载的功能的时候，需要下载比较大的File Stream，例如Video File Stream ,Excel File Stream。这个时候如果不关闭流，会造成比较大开销，并且File的线程会一直开着。StreamingResponseBody可以很有效的解决这个问题。 也就是说一个Controller在处理异步请求的时候，StreamingResponseBody会直接把流写入到response的输出流中，并且不会占用Servlet容器线程。 CallableMethodReturnValueHandler 看supportsReturnType方法 1234@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; return Callable.class.isAssignableFrom(returnType.getParameterType());&#125; 这个就是用来出个Callable返回值的 DeferredResultMethodReturnValueHandler 看supportsReturnType方法 1234567@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; Class&lt;?&gt; type = returnType.getParameterType(); return (DeferredResult.class.isAssignableFrom(type) || ListenableFuture.class.isAssignableFrom(type) || CompletionStage.class.isAssignableFrom(type));&#125; CompletionStage的一个实现类为CompletableFuture AsyncTaskMethodReturnValueHandler 看supportsReturnType方法 1234@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; return WebAsyncTask.class.isAssignableFrom(returnType.getParameterType());&#125; 在SpringMVC中使用异步请求配置业务线程12345678910111213141516171819@Configurationpublic class WebMvcConfigurerConfig implements WebMvcConfigurer &#123; @Bean public ThreadPoolTaskExecutor mvcTaskExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(10); executor.setQueueCapacity(100); executor.setMaxPoolSize(25); return executor; &#125; // 这不是必须的，不设置的话会使用默认的SimpleAsyncTaskExecutor // 可以看RequestMappingHandlerAdapter @Override public void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; configurer.setTaskExecutor(mvcTaskExecutor()); &#125;&#125; 使用StreamingResponseBody12345678 @RequestMapping(&quot;/test&quot;)public StreamingResponseBody test()&#123; return o-&gt;&#123; try(ObjectOutputStream oos = new ObjectOutputStream (o))&#123; oos.writeBytes (&quot;abcdefg&quot;); &#125; &#125;;&#125; Callable123456789101112@RequestMapping(value=&quot;/test2&quot;,produces = &#123;&quot;text/html;charset=utf-8&quot;&#125;)public Callable&lt;String&gt; test2()&#123; log.info (&quot;请求开始,线程为&#123;&#125;&quot;,Thread.currentThread ()); Callable&lt;String&gt; callable = () -&gt; &#123; log.info (&quot;异步请求开始,线程为&#123;&#125;&quot;,Thread.currentThread ()); Thread.sleep (10000); log.info (&quot;异步请求结束,线程为&#123;&#125;&quot;,Thread.currentThread ()); return &quot;abcdefg&quot;; &#125;; log.info (&quot;请求结束,线程为&#123;&#125;&quot;,Thread.currentThread ()); return callable;&#125; DeferredResult1234567891011121314151617181920212223@GetMapping(&quot;deferredResult&quot;)public DeferredResult&lt;String&gt; deferredResult() &#123; System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程(&quot;+Thread.currentThread().getName()+&quot;)开始&quot;); DeferredResult&lt;String&gt; deferredResult = new DeferredResult&lt;&gt;(); // 这里使用依赖注入注入执行线程池，不要用默认的ForkJoin线程池 CompletableFuture.supplyAsync(()-&gt; doBusiness(), Executors.newFixedThreadPool(5)).whenCompleteAsync((result, throwable)-&gt;&#123; if (throwable!=null) &#123; deferredResult.setErrorResult(throwable.getMessage()); &#125;else &#123; deferredResult.setResult(result); &#125; &#125;); // 异步请求超时时调用 deferredResult.onTimeout(()-&gt;&#123; System.out.println(LocalDateTime.now().toString() + &quot;---&gt;onTimeout&quot;); &#125;); // 异步请求完成后调用 deferredResult.onCompletion(()-&gt;&#123; System.out.println(LocalDateTime.now().toString() + &quot;---&gt;onCompletion&quot;); &#125;); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程(&quot;+Thread.currentThread().getName()+&quot;)结束&quot;); return deferredResult;&#125; 这种方式记得不要使用内置的不要使用内置的 ForkJoinPool线程池，需要自己创建线程池否则会有性能问题 ListenableFuture12345678910@GetMapping(&quot;listenableFuture&quot;)public ListenableFuture&lt;String&gt; listenableFuture() &#123; // 线程池一般不会放在这里，会使用static声明，这只是演示 ExecutorService executor = Executors.newCachedThreadPool(); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程开始&quot;); ListenableFutureTask&lt;String&gt; listenableFuture = new ListenableFutureTask&lt;&gt;(()-&gt; doBusiness()); executor.execute(listenableFuture); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程结束&quot;); return listenableFuture;&#125; 这种方式记得不要使用内置的不要使用内置的 ForkJoinPool线程池，需要自己创建线程池否则会有性能问题 CompletableFuture123456789@GetMapping(&quot;completableFuture&quot;)public CompletableFuture&lt;String&gt; completableFuture() &#123; // 线程池一般不会放在这里，会使用static声明，这只是演示 ExecutorService executor = Executors.newCachedThreadPool(); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程开始&quot;); CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(IndexController::doBusiness, executor); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程结束&quot;); return completableFuture;&#125; 这种方式记得不要使用内置的 ForkJoinPool线程池，需要自己创建线程池否则会有性能问题 WebAsyncTask12345678910111213141516@GetMapping(&quot;asynctask&quot;)public WebAsyncTask asyncTask() &#123; // 线程池一般不会放在这里，会使用static声明，这只是演示 SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor(); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程开始&quot;); WebAsyncTask&lt;String&gt; task = new WebAsyncTask(1000L, executor, ()-&gt; doBusiness()); task.onCompletion(()-&gt;&#123; System.out.println(LocalDateTime.now().toString() + &quot;---&gt;调用完成&quot;); &#125;); task.onTimeout(()-&gt;&#123; System.out.println(&quot;onTimeout&quot;); return &quot;onTimeout&quot;; &#125;); System.out.println(LocalDateTime.now().toString() + &quot;---&gt;主线程结束&quot;); return task;&#125; 这种方式记得不要使用内置的不要使用内置的 ForkJoinPool线程池，需要自己创建线程池否则会有性能问题 返回void这种就是最基本的情况，直接使用Servlet3.0的API 123456789101112131415161718192021222324ScheduledExecutorService executorService = Executors.newScheduledThreadPool(10);@RequestMapping(&quot;/async1&quot;)public void async1(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; // 释放http连接，转为异步 AsyncContext context = request.startAsync(); // 直接超时了 context.setTimeout(0L); // 异步处理，等待3秒后执行 executorService.schedule(()-&gt;&#123; PrintWriter writer = null; try &#123; writer = context.getResponse().getWriter(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; writer.print(&quot;111111111111&quot;); // TODO 异步完成，返回客户端信息 context.complete(); &#125;,3, TimeUnit.SECONDS);&#125; 总结上面这几种异步方式都是会等到业务doBusiness执行完之后才会把response给到前端，执行请求的主线程会立即结束，响应结果会交给另外的线程来返回给前端。 这种异步跟下面的这个所谓的假异步是不同的，这种情况是由主线程执行完成之后立马返回值（主线程）给前端，不会等个5s在返回给前端。 1234567891011121314@GetMapping(&quot;call&quot;)public String call() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); return &quot;这是个假异步&quot;;&#125; 这几种异步方式都跟返回Callable 差不多，都有对应的HandlerMethodReturnValueHandler 实现类，无非就是丰富了自己一些特殊的api、比如超时设置啥的，以及线程池的创建是谁来创建，执行流程基本都是一样的。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"24-SpringMVC在项目有用的代码","slug":"spring/5.2.8/24-SpringMVC在项目有用的代码","date":"2021-11-20T12:00:33.000Z","updated":"2022-03-14T09:04:26.695Z","comments":true,"path":"blog/spring/5.2.8/24-SpringMVC在项目有用的代码/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/24-SpringMVC%E5%9C%A8%E9%A1%B9%E7%9B%AE%E6%9C%89%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"添加自定义的Servlet、Filter、ListenerSpring版本使用自定义的ServletContainerInitializer项目中提供这个文件： 实现类为： 12345678910111213141516171819202122232425public interface LoadServlet &#123; void loadOnstarp(ServletContext servletContext);&#125;@HandlesTypes(LoadServlet.class)public class MyServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123; Iterator&lt;Class&lt;?&gt;&gt; iterator; if (set != null) &#123; iterator = set.iterator(); while (iterator.hasNext()) &#123; Class&lt;?&gt; clazz = iterator.next(); if (!clazz.isInterface() &amp;&amp; !Modifier.isAbstract(clazz.getModifiers()) &amp;&amp; LoadServlet.class.isAssignableFrom(clazz)) &#123; try &#123; ((LoadServlet) clazz.newInstance()).loadOnstarp(servletContext); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 意思就是加载实现了LoadServlet这个接口的类，然后把这些类实例化后执行方法。 这里我提供一个实现了LoadServlet的类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoadServletImpl implements LoadServlet &#123; @Override public void loadOnstarp(ServletContext servletContext) &#123; ServletRegistration.Dynamic initServlet = servletContext.addServlet(&quot;initServlet&quot;, InitServlet.class); initServlet.setLoadOnStartup(1); initServlet.addMapping(&quot;/init&quot;); ServletRegistration aDefault = servletContext.getServletRegistration(&quot;default&quot;); aDefault.addMapping(&quot;*.css&quot;,&quot;*.gif&quot;,&quot;*.jpg&quot;,&quot;*.js&quot;,&quot;*.JPG&quot;);// ServletRegistration.Dynamic defaults = servletContext.addServlet(&quot;default&quot;, DefaultServlet.class);// defaults.setLoadOnStartup(1);// defaults.addMapping(&quot;*.css&quot;,&quot;*.gif&quot;,&quot;*.jpg&quot;,&quot;*.js&quot;,&quot;*.JPG&quot;); &#125;&#125;public class InitServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;=====doget===&quot;); PrintWriter writer = resp.getWriter(); writer.print(&quot;&lt;h1&gt;Jack&lt;/h1&gt;&quot;); RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/jsp/ok.jsp&quot;); requestDispatcher.forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.service(req, resp); &#125;&#125; tomcat启动后，会加入一个名为initServlet的Servlet。 tomcat启动时答应如下内容 使用默认的ServletContainerInitializer也就意味着使用WebApplicationInitializer接口。大部分情况下只需要继承SpringMVC提供的AbstractAnnotationConfigDispatcherServletInitializer类就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 有很多可以重写的方法public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //父容器 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; System.out.println(&quot;-------调用了getRootConfigClasses---------&quot;); return new Class&lt;?&gt;[]&#123;SpringContainer.class&#125;; &#125; //SpringMVC配置子容器 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; System.out.println(&quot;-------调用了getServletConfigClasses---------&quot;); return new Class&lt;?&gt;[]&#123;MvcContainer.class&#125;; &#125; //获取DispatcherServlet的映射信息 @Override protected String[] getServletMappings() &#123; System.out.println(&quot;-------调用了getServletMappings---------&quot;); return new String[]&#123;&quot;/xyz&quot;&#125;; &#125; /** * 添加Filter * @return */ @Override protected Filter[] getServletFilters() &#123; System.out.println(&quot;-------调用了getServletFilters---------&quot;); MyFilter myFilter = new MyFilter(); CorsFilter corsFilter = new CorsFilter(); CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceEncoding(true); return new Filter[]&#123;myFilter, corsFilter, characterEncodingFilter&#125;; &#125; @Override protected void registerContextLoaderListener(ServletContext servletContext) &#123; // 添加Servlet// servletContext.addServlet() // 添加Filter// servletContext.addFilter() //添加Listener// servletContext.addListener(); // 这里必须 调用父类的registerContextLoaderListener方法 super.registerContextLoaderListener(servletContext); &#125; @Override protected ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123; return new ApplicationContextInitializer[]&#123;new ApplicationContextInitializerDemo()&#125;; &#125; @Override protected ApplicationContextInitializer&lt;?&gt;[] getServletApplicationContextInitializers() &#123; return super.getServletApplicationContextInitializers(); &#125;&#125; Spring Boot版本只需要加上 1@ServletComponentScan(basePackages = &#123;&quot;com.xyz.demo&quot;&#125;) 这个注解就好了 然后在 Servlet、Filter、Listener 上面加入响应注解即可。如: 1234567891011121314151617181920212223242526272829@WebServlet(name=&quot;HelloServlet&quot;,urlPatterns = &quot;/HelloServlet&quot;,loadOnStartup = 1)public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; PrintWriter writer = resp.getWriter(); writer.println(&quot;hello servlet!&quot;); &#125;&#125;@WebFilter(urlPatterns = &quot;/*&quot;,filterName = &quot;myFilter&quot;)public class MyFilter implements Filter &#123; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;--------MyFilter----------&quot;); chain.doFilter(request,response); &#125;&#125;@WebListenerpublic class MyListener implements ServletContextListener &#123; @Override public void contextDestroyed(ServletContextEvent contextEvent) &#123; System.out.println(&quot;contextDestroyed&quot;); &#125; @Override public void contextInitialized(ServletContextEvent contextEvent) &#123; System.out.println(&quot;contextInitialized&quot;); &#125;&#125; ServletRequestAttributes1234ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();HttpServletRequest request = servletRequestAttributes.getRequest();HttpServletResponse response = servletRequestAttributes.getResponse(); 通过Request对象获取SpringMVC上下文在项目中就能通过 1request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE) 这段代码获取到SpringMVC的上下，而该对象的的类型为AnnotationConfigWebApplicationContext。也就是说可以通过getParentBeanFactory方法到父BeanFactory，也就是Spring的上下文，该上下的类型也为AnnotationConfigWebApplicationContext。而且也能通过getServletContext()方法，获取到ServletContext，这样也就能做一些添加Servlet等操作，也可以通过ServletContext.getAttribute方法获取很多内置的属性或对象。 设置跨域配置使用注解模式1234567891011121314151617181920212223242526272829303132333435363738@ComponentScanpublic class WebMvcConfigurerConfig implements WebMvcConfigurer &#123; /** * listen 80; * server_name test.enjoy.com; * * #是否允许请求带有验证信息 * add_header Access-Control-Allow-Credentials true; * #允许跨域访问的域名,可以是一个域的列表，也可以是通配符*，多个用空格分开 * add_header Access-Control-Allow-Origin http://static.enjoy.com; * #允许脚本访问的返回头 * add_header Access-Control-Allow-Headers &#x27;x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp&#x27;; * #允许使用的请求方法，以逗号隔开 * add_header Access-Control-Allow-Methods &#x27;POST,GET,OPTIONS,PUT,DELETE&#x27;; * #允许自定义的头部，以逗号隔开,大小写不敏感 * add_header Access-Control-Expose-Headers &#x27;WWW-Authenticate,Server-Authorization&#x27;; * #P3P支持跨域cookie操作 * add_header P3P &#x27;policyref=&quot;/w3c/p3p.xml&quot;, CP=&quot;NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC&quot;&#x27;; * if ($request_method = &#x27;OPTIONS&#x27;) &#123;##OPTIONS类的请求，是跨域先验请求 * return 204;##204代表ok * &#125; * * @param registry */ @Override public void addCorsMappings(CorsRegistry registry) &#123; // 路径 CorsRegistration registration = registry.addMapping(&quot;/*&quot;); registration.allowCredentials(true); registration.allowedOrigins(&quot;http://static.enjoy.com&quot;); registration.allowedHeaders(&quot;x-requested-with&quot;, &quot;content-type&quot;, &quot;Cache-Control&quot;, &quot;Pragma&quot;, &quot;Date&quot;, &quot;x-timestamp&quot;); registration.allowedMethods(&quot;POST&quot;, &quot;GET&quot;, &quot;OPTIONS&quot;, &quot;DELETE&quot;); registration.exposedHeaders(&quot;WWW-Authenticate&quot;, &quot;Server-Authorization&quot;); registration.maxAge(3600L); &#125;&#125; 使用HttpRequestHandler接口使用CorsConfigurationSource接口123456789101112131415161718@Componentpublic class AreaController implements HttpRequestHandler, CorsConfigurationSource &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;======AreaController&quot;); PrintWriter writer = response.getWriter(); writer.println(&quot;&lt;h1&gt;==========Jack&lt;/h1&gt;&quot;); writer.flush(); writer.close(); &#125; // 定义跨域配置 @Override public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123; return null; &#125;&#125; 使用SimpleUrlHandlerMapping在配置定义的HttpRequestHandler是，会新建一个SimpleUrlHandlerMapping对像，这时可以通过下面的方式设置 其中setCorsConfigurationSource可以设置全局的CorsConfiguration。 UriComponentsBuilder和UriComponentsspring mvc提供了一种机制，可以构造和编码URI，即使用UriComponentsBuilder和UriComponents。比如：对url进行编码（比如请求中含有空格时编码为%20），同时支持变量替换。 构建URI 1234UriComponents uriComponents=UriComponentsBuilder .fromHttpUrl(&quot;http://localhost:8080//hello&quot;) .queryParams(params).build() //params是个MapString uri=uriComponents.toUriString(); 替换参数和编码（默认使用utf-8） 123UriComponents uriComponents = UriComponentsBuilder.fromUriString(&quot;http://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;&quot;).build();URI uri = uriComponents.expand(&quot;42&quot;, &quot;21&quot;).encode().toUri(); 注意：UriComponents是不可变的，expand()和encode()返回新的实例。 或者 1234UriComponents uriComponents = UriComponentsBuilder.newInstance() .scheme(&quot;http&quot;).host(&quot;example.com&quot;).path(&quot;/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;&quot;).build() .expand(&quot;42&quot;, &quot;21&quot;) .encode();","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"23-SpringMVC拦截器、跨域和异常处理","slug":"spring/5.2.8/23-SpringMVC拦截器、跨域和异常处理","date":"2021-11-20T12:00:32.000Z","updated":"2022-03-14T09:04:26.687Z","comments":true,"path":"blog/spring/5.2.8/23-SpringMVC拦截器、跨域和异常处理/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/23-SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8%E3%80%81%E8%B7%A8%E5%9F%9F%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"SpringMVC拦截器、跨域和异常处理拦截器使用1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class UserInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;======UserInterceptor用户权限校验=========&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;========UserInterceptor修改modelAndView======&quot;); int status = response.getStatus(); System.out.println(&quot;========UserInterceptor修改modelAndView======&quot; + status);// HttpSession session = request.getSession();// if(modelAndView != null &amp;&amp; session != null) &#123;// String modifyViewName = modelAndView.getViewName() + &quot;_&quot; + session.getAttribute(&quot;language&quot;);// modelAndView.setViewName(modifyViewName);// &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;========UserInterceptor资源释放======&quot;); &#125;&#125;@Configurationpublic class AppConfig implements WebMvcConfigurer &#123; @Autowired private UserInterceptor userInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(userInterceptor) .addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;/user/query/**&quot;); registry.addInterceptor(new UserInterceptor1()) .addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;&quot;); &#125; &#125; 源码——添加在springMVC的启动中，通过使用@EnableWebMvc注解引入了WebMvcConfigurationSupport来完成mvc bean的创建，其中最重要的是RequestMappingHandlerMapping这个从之前的分析中可知，这是用来处理@RuestingMapping注解的handlerMapping。 在创建RequestMappingHandlerMapping的过程过程中，通过getInterceptors来添加拦截器： 而从getInterceptors方法的源码中可以看到，spring MVC通过addInterceptors方法来添加自定义拦截器，其中扩展的源码和原理在前面《springMVC启动讲解》已经讲过了，这里关注拦截器的初始化。从源码可以看到，所有的拦截器都需要经过InterceptorRegistry，所以看InterceptorRegistry的定义： 123456789101112131415161718192021222324252627282930313233public class InterceptorRegistry &#123; private final List&lt;InterceptorRegistration&gt; registrations = new ArrayList&lt;&gt;(); public InterceptorRegistration addInterceptor(HandlerInterceptor interceptor) &#123; InterceptorRegistration registration = new InterceptorRegistration(interceptor); this.registrations.add(registration); return registration; &#125; public InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor) &#123; WebRequestHandlerInterceptorAdapter adapted = new WebRequestHandlerInterceptorAdapter(interceptor); InterceptorRegistration registration = new InterceptorRegistration(adapted); this.registrations.add(registration); return registration; &#125; protected List&lt;Object&gt; getInterceptors() &#123; return this.registrations.stream() .sorted(INTERCEPTOR_ORDER_COMPARATOR) .map(InterceptorRegistration::getInterceptor) .collect(Collectors.toList()); &#125; private static final Comparator&lt;Object&gt; INTERCEPTOR_ORDER_COMPARATOR = OrderComparator.INSTANCE.withSourceProvider(object -&gt; &#123; if (object instanceof InterceptorRegistration) &#123; return (Ordered) ((InterceptorRegistration) object)::getOrder; &#125; return null; &#125;);&#125; 从源码中可知，有两种类型的拦截器，HandlerInterceptor和WebRequestInterceptor，这两种拦截器的添加基本一样，而且作用都一样，区别是WebRequestInterceptor需要生成一个代理对象，这个代理对象类型就是适配器WebRequestHandlerInterceptorAdapter，最终被包装成InterceptorRegistration而已。WebRequestHandlerInterceptorAdapter就是做了适配，使得WebRequestInterceptor能够使用HandlerInterceptorde 的初始化和调用逻辑。 接着看回getInterceptors方法的最后，执行了registry.getInterceptors()方法。 123456protected List&lt;Object&gt; getInterceptors() &#123; return this.registrations.stream() .sorted(INTERCEPTOR_ORDER_COMPARATOR) .map(InterceptorRegistration::getInterceptor) .collect(Collectors.toList());&#125; 从上边的InterceptorRegistry类定义看getInterceptors方法。可以看到InterceptorRegistration#getInterceptor这段代码，而这段代码的源码如下： 123456789101112protected Object getInterceptor() &#123; if (this.includePatterns.isEmpty() &amp;&amp; this.excludePatterns.isEmpty()) &#123; return this.interceptor; &#125; String[] include = StringUtils.toStringArray(this.includePatterns); String[] exclude = StringUtils.toStringArray(this.excludePatterns); MappedInterceptor mappedInterceptor = new MappedInterceptor(include, exclude, this.interceptor); if (this.pathMatcher != null) &#123; mappedInterceptor.setPathMatcher(this.pathMatcher); &#125; return mappedInterceptor;&#125; 可以看到，这只是把匹配的路径、排除的路径和具体的HandlerInterceptor封装成MappedInterceptor。最后把MappedInterceptor列表通过HandlerMapping的setInterceptors方法把MappedInterceptor列表添加到了AbstractHandlerMapping的interceptors属性中 拦截器的添加源码就这么简单，只是做了封装。 把HandlerInterceptor和WebRequestInterceptor封装成InterceptorRegistration。 通过InterceptorRegistration生成MappedInterceptor 把MappedInterceptor列表添加到AbstractHandlerMapping的interceptors属性中 其中InterceptorRegistration的作用只是为了收集匹配的路径、排除的路径。从设计模式看，这个类是HandlerInterceptor的工厂，而MappedInterceptor包含了路径的匹配逻辑和HandlerInterceptor的调用逻辑。也就是说MappedInterceptor就是Spring调用的拦截器，而HandlerInterceptor只是为了完成拦截器的初始化和扩展。InterceptorRegistration为了包装数据和生成MappedInterceptor。 源码——初始化看RequestMappingHandlerMapping类的类图： 其中他的某一个父类实现了ApplicationContextAware接口，也就是setApplicationContext会被Spring执行。 重点看红框的代码，根据类图跟踪子类： 好了，现在跟踪子类的initApplicationContext()方法，一直到AbstractHandlerMapping的initApplicationContext()方法： 123456// AbstractHandlerMappingprotected void initApplicationContext() throws BeansException &#123; extendInterceptors(this.interceptors); detectMappedInterceptors(this.adaptedInterceptors); initInterceptors();&#125; 现在一个一个方法看。 extendInterceptors：该方法是一个钩子方法，是给子类扩展的，在AbstractHandlerMapping上，这个方法是一个空方法，但RequestMappingHandlerMapping并没有重写这个方法，所以这个方法没用 detectMappedInterceptors(this.adaptedInterceptors)： 入参adaptedInterceptors是AbstractHandlerMapping的一个内部属性，定义如下： 1private final List&lt;HandlerInterceptor&gt; adaptedInterceptors = new ArrayList&lt;&gt;() 看detectMappedInterceptors的源码： 12345protected void detectMappedInterceptors(List&lt;HandlerInterceptor&gt; mappedInterceptors) &#123; mappedInterceptors.addAll( BeanFactoryUtils.beansOfTypeIncludingAncestors( obtainApplicationContext(), MappedInterceptor.class, true, false).values());&#125; 从源码可以看到，该方法会在spring的上下文容器中获取MappedInterceptor的子类，并把这类类添加到AbstractHandlerMapping的内部属性adaptedInterceptors中 initInterceptors：看源码： 1234567891011protected void initInterceptors() &#123; if (!this.interceptors.isEmpty()) &#123; for (int i = 0; i &lt; this.interceptors.size(); i++) &#123; Object interceptor = this.interceptors.get(i); if (interceptor == null) &#123; throw new IllegalArgumentException(&quot;Entry number &quot; + i + &quot; in interceptors array is null&quot;); &#125; this.adaptedInterceptors.add(adaptInterceptor(interceptor)); &#125; &#125;&#125; 这代码就很简单了，interceptors在上边讲过，里面包含的就是拦截器，有自定义的和spring定义的，类型是MappedInterceptor。这个方法就是的作用就是把这些拦截器添加到内部属性adaptedInterceptors中。 源码——调用看DispatcherServlet的doDispatch方法，这方法在&lt;20-SpringMVC中请求是怎么到达Controller的&gt;中就已经讲过了，现在继续跟踪其中的getHandler方法，一直到AbstractHandlerMapping的getHandler(HttpServletRequest request)方法，在这个方法调用了方法getHandlerExecutionChain，这个方法在20中也讲过，这里简单看下源码： 从源码可以看到，这里按路径匹配出合适的HandlerInterceptor然后添加到HandlerExecutionChain中的interceptorList中，之后的流程在&lt;20-SpringMVC中请求是怎么到达Controller的&gt;这里已经说明过了。 跨域跨域问题由来：浏览器拒绝执行其它域名下的ajax运作。 如果浏览器在static.enjoy.com对应的html页面内，发起ajax请求偷盗www.enjoy.com域名下的内容来填充自己的页面,整个互联网秩序将混乱. 为了防止这种混乱,W3C组织制定了浏览器安全规范，即html页面发起的ajax请求仅限于同域名后端范围，跨越域名的ajax请求不得执行，此谓跨域问题。 cors方案的解决之道W3C制定跨域限制的本意，是防止页面领域安全混乱，即防止A公司不经B公司同意，使用ajax盗取B公司的服务内容。 出于这个本意，W3C改进了跨域的方案，即：如果B公司是同意将自己的内容分享给A公司的，跨域限制可放开，此方案即CORS方案，如下图： nginx配置跨域操作1234567891011121314151617181920server &#123; listen 80; server_name test.enjoy.com; #是否允许请求带有验证信息 add_header Access-Control-Allow-Credentials true; #允许跨域访问的域名,可以是一个域的列表，也可以是通配符*，多个用空格分开 add_header Access-Control-Allow-Origin http://static.enjoy.com; #允许脚本访问的返回头 add_header Access-Control-Allow-Headers &#x27;x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp&#x27;; #允许使用的请求方法，以逗号隔开 add_header Access-Control-Allow-Methods &#x27;POST,GET,OPTIONS,PUT,DELETE&#x27;; #允许自定义的头部，以逗号隔开,大小写不敏感 add_header Access-Control-Expose-Headers &#x27;WWW-Authenticate,Server-Authorization&#x27;; #P3P支持跨域cookie操作 add_header P3P &#x27;policyref=&quot;/w3c/p3p.xml&quot;, CP=&quot;NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC&quot;&#x27;; if ($request_method = &#x27;OPTIONS&#x27;) &#123;##OPTIONS类的请求，是跨域先验请求 return 204;##204代表ok &#125;&#125; spring中解决跨越从nginx中解决跨域配置中可以看到，就是在response中添加一些信息。比如这样: 12345HttpServletResponse response = (HttpServletResponse) res;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;);response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;); 而在spring中有很多方法可以在response中添加这些信息，可以在spring的拦截器、servlet的Filter等，下面介绍一下spring中基于注解的形式: 123456789101112@CrossOrigin(origins = &quot;*&quot; ,allowedHeaders = &quot;x-requested-with&quot; ,allowCredentials = &quot;true&quot; ,maxAge = 3600 ,methods = &#123;RequestMethod.GET,RequestMethod.POST,RequestMethod.OPTIONS,RequestMethod.DELETE&#125;)@RequestMapping(&quot;/queryArea&quot;)public @ResponseBodyList&lt;ConsultConfigArea&gt; queryArea(@RequestParam(required = false) String areaCode) &#123; Map map = new HashMap&lt;&gt;(); map.put(&quot;areaCode&quot;,areaCode); return areaService.queryAreaFromDB(map);&#125; 这个注解的解析也很简单，就是在AbstractHandlerMethodMapping#detectHandlerMethods方法中完成。而这个方法在20-SpringMVC中请求是怎么到达Controller的也已经说过了，就是将@RequestMapping解析成RequestMappingInfo，然后建立&lt;url,List&lt;RequestMapping&gt;&gt;和&lt;RequestMapping,HandlerMethod&gt;的对应关系，在建立这种对应关系后会做一件事： 就是建立&lt;HandlerMethod, CorsConfiguration&gt;的对应关系，有了这个对应关系后，继续看下调用时是怎么处理的。 回到DispatcherServlet，其中在doDispatch中会执行getHandler获取HandlerExecutionChain，跟踪getHandler，到这里： 上边的代码就是获取跨域配置的，其中有两种获取方式， 一种是通过AbstractHandlerMapping的属性CorsConfigurationSource， 一种是通过getCorsConfiguration方法。 第一种使用CorsConfigurationSource属性，该属性的初始化是需要调用AbstractHandlerMapping的setCorsConfigurations方法或者setCorsConfigurationSource方法设置的。对于使用注解的模式，可以直接通过WebMvcConfigurer接口的addCorsMappings方法添加。对于使用HttpRequestHandler接口的，需要使用SimpleUrlHandlerMapping对象设置。下面看第二种方式。 看getCorsConfiguration方法，这个方法更具不同的HandlerMapping，有不同的获取逻辑 如果不是RequestMappingHandlerMapping，那该方法就看AbstractHandlerMapping#getCorsConfiguration方法 12345678910protected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) &#123; Object resolvedHandler = handler; if (handler instanceof HandlerExecutionChain) &#123; resolvedHandler = ((HandlerExecutionChain) handler).getHandler(); &#125; if (resolvedHandler instanceof CorsConfigurationSource) &#123; return ((CorsConfigurationSource) resolvedHandler).getCorsConfiguration(request); &#125; return null;&#125; 逻辑很简单，就是检查handler是否实现了CorsConfigurationSource接口，如果实现了，调用对应的方法获取就行了。 如果是RequestMappingHandlerMapping，该类的父类重写了getCorsConfiguration方法，看 AbstractHandlerMethodMapping#getCorsConfiguration方法 12345678910111213141516@Overrideprotected CorsConfiguration getCorsConfiguration(Object handler, HttpServletRequest request) &#123; CorsConfiguration corsConfig = super.getCorsConfiguration(handler, request); if (handler instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod) handler; if (handlerMethod.equals(PREFLIGHT_AMBIGUOUS_MATCH)) &#123; return AbstractHandlerMethodMapping.ALLOW_CORS_CONFIG; &#125; else &#123; // MappingRegistry.crosLookup 缓存中取，建立映射发生在AbstractHandlerMethodMapping的register方法中建立 CorsConfiguration corsConfigFromMethod = this.mappingRegistry.getCorsConfiguration(handlerMethod); corsConfig = (corsConfig != null ? corsConfig.combine(corsConfigFromMethod) : corsConfigFromMethod); &#125; &#125; return corsConfig;&#125; 可以看到，会调用super.getCorsConfiguration(handler, request);，这个就是第一种模式的逻辑，这里看下面的代码。 这代码会在从MappingRegistry.crosLookup 缓存中获取，这个缓存就是解析@RequestMapping注解，建立uri与HandlerMethod映射前，前检查对应方法上是否有@CrossOrigin注解，有就在建立完立uri与HandlerMethod映射后，就建立HandlerMethod与CorsConfiguration的映射，这额映射就是保存在MappingRegister.corsLookup缓存中。 通过上边的代码，走上边的逻辑后，可能会获取到两个CorsConfiguration，这时需要把这个两个CorsConfiguration合并，然后执行getCorsHandlerExecutionChain方法，把一个拦截器添加到头部。看getCorsHandlerExecutionChain源码： 可以看到，该方法会添加一个CorsInterceptor拦截器，而且这个拦截器放在了第一个。这个拦截器的作用就是在response的handler中添加必要的参数的。 异常处理异常处理流程，看回DispatcherServlet中的doDispatch方法，在最后： 如果出现异常，异常被赋值给dispatchException引用，而该引用会作为参数传入processDispatchResult方法中。 看else代码块的，handler就是MethodHandle，看processHandlerException： 这里就是异常处理的核心。handlerExceptionResolvers的值是在SpringMVC启动前添加进去的，现在先看异常处理器的初始化 异常处理器的初始化先看源码WebMvcConfigurationSupport的handlerExceptionResolver： 钩子方法就不看了，if中的代码addDefaultHandlerExceptionResolvers，该方法会添加一些默认的异常处理器。 这里添加了3个异常处理器 ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 接着会把上面的3个异常处理器放到HandlerExceptionResolverComposite这个对象中，并把该对象注入到Spring容器中。 接着回到DispatcherServlet中的onRefresh，这个方法会在SpringMVC容器启动完成后，发起一个ContextRefreshedEvent事件后触发调用的。而在onRefresh方法中有一个方法initHandlerExceptionResolvers(context)，该方法就是用来初始化handlerExceptionResolvers： 从源码看到，这里初始化后的结果就是handlerExceptionResolvers中只有一个值，这个值就是HandlerExceptionResolverComposite类型对象。 回到DispatcherServlet#processHandlerException 这里可以看成HandlerExceptionResolverComposite#resolveException： 从之前可以知道，resolvers中有3个值，分别是： ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 顺序就是上边的顺序，所以这里可以就按上边的顺序解析 ExceptionHandlerExceptionResolver跟踪代码 resolveException—&gt;doResolveException—&gt;doResolveHandlerMethodException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455protected ModelAndView doResolveHandlerMethodException(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerMethod handlerMethod, Exception exception) &#123; ServletInvocableHandlerMethod exceptionHandlerMethod = getExceptionHandlerMethod(handlerMethod, exception); if (exceptionHandlerMethod == null) &#123; return null; &#125; if (this.argumentResolvers != null) &#123; exceptionHandlerMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; exceptionHandlerMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; ServletWebRequest webRequest = new ServletWebRequest(request, response); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); try &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Using @ExceptionHandler &quot; + exceptionHandlerMethod); &#125; Throwable cause = exception.getCause(); if (cause != null) &#123; // Expose cause as provided argument as well exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, cause, handlerMethod); &#125; else &#123; // Otherwise, just the given exception as-is exceptionHandlerMethod.invokeAndHandle(webRequest, mavContainer, exception, handlerMethod); &#125; &#125; catch (Throwable invocationEx) &#123; 。。。。。。 return null; &#125; if (mavContainer.isRequestHandled()) &#123; return new ModelAndView(); &#125; else &#123; ModelMap model = mavContainer.getModel(); HttpStatus status = mavContainer.getStatus(); ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, status); mav.setViewName(mavContainer.getViewName()); if (!mavContainer.isViewReference()) &#123; mav.setView((View) mavContainer.getView()); &#125; if (model instanceof RedirectAttributes) &#123; Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes(); RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes); &#125; return mav; &#125;&#125; 先看getExceptionHandlerMethod方法，这个方法是异常处理的核心逻辑。 123456789101112131415161718192021222324252627282930313233343536373839protected ServletInvocableHandlerMethod getExceptionHandlerMethod( @Nullable HandlerMethod handlerMethod, Exception exception) &#123; Class&lt;?&gt; handlerType = null; if (handlerMethod != null) &#123; // Local exception handler methods on the controller class itself. // To be invoked through the proxy, even in case of an interface-based proxy. handlerType = handlerMethod.getBeanType(); ExceptionHandlerMethodResolver resolver = this.exceptionHandlerCache.get(handlerType); if (resolver == null) &#123; //在这里建立异常和method的映射关系 resolver = new ExceptionHandlerMethodResolver(handlerType); this.exceptionHandlerCache.put(handlerType, resolver); &#125; Method method = resolver.resolveMethod(exception); if (method != null) &#123; return new ServletInvocableHandlerMethod(handlerMethod.getBean(), method); &#125; // For advice applicability check below (involving base packages, assignable types // and annotation presence), use target class instead of interface-based proxy. if (Proxy.isProxyClass(handlerType)) &#123; handlerType = AopUtils.getTargetClass(handlerMethod.getBean()); &#125; &#125; for (Map.Entry&lt;ControllerAdviceBean, ExceptionHandlerMethodResolver&gt; entry : this.exceptionHandlerAdviceCache.entrySet()) &#123; ControllerAdviceBean advice = entry.getKey(); if (advice.isApplicableToBeanType(handlerType)) &#123; ExceptionHandlerMethodResolver resolver = entry.getValue(); Method method = resolver.resolveMethod(exception); if (method != null) &#123; return new ServletInvocableHandlerMethod(advice.resolveBean(), method); &#125; &#125; &#125; return null;&#125; 而这段代码的核心在这里： 可以看到先从缓存中拿ExceptionHandlerMethodResolver，没有就new一个，现在看该类的构造方法。 123456789101112131415161718public static final MethodFilter EXCEPTION_HANDLER_METHODS = method -&gt; AnnotatedElementUtils.hasAnnotation(method, ExceptionHandler.class);public ExceptionHandlerMethodResolver(Class&lt;?&gt; handlerType) &#123; for (Method method : MethodIntrospector.selectMethods(handlerType, EXCEPTION_HANDLER_METHODS)) &#123; for (Class&lt;? extends Throwable&gt; exceptionType : detectExceptionMappings(method)) &#123; addExceptionMapping(exceptionType, method); &#125; &#125;&#125;private void addExceptionMapping(Class&lt;? extends Throwable&gt; exceptionType, Method method) &#123; Method oldMethod = this.mappedMethods.put(exceptionType, method); if (oldMethod != null &amp;&amp; !oldMethod.equals(method)) &#123; throw new IllegalStateException(&quot;Ambiguous @ExceptionHandler method mapped for [&quot; + exceptionType + &quot;]: &#123;&quot; + oldMethod + &quot;, &quot; + method + &quot;&#125;&quot;); &#125;&#125; 这个段代码的意思就是，获取handlerType的方法中有ExceptionHandler注解的方法，然后解析方法上的ExceptionHandler，得到Throwable类型也就是异常class对象的列表后，建立&lt;异常class对象, 方法的映射关系&gt;，这个映射关系保存在ExceptionHandlerMethodResolver的mappedMethods&#96;属性中。new完之后，这时有两个逻辑选择： 一种就是@ExceptionHandler中定义了错误 这里的意思就是错误类型在之前获取到的ExceptionHandlerMethodResolver中找到方法。那么这时就返回new一个ServletInvocableHandlerMethod返回，添加获取参数解析起和返回值处理器然后就只执行invokeAndHandle方法，也就是对应方法的调用了，使用就是在controller中这样定义后， 123456789101112131415161718@Controller@RequestMapping(&quot;/user&quot;)public class Controller &#123; @RequestMapping(&quot;/exceptionTest&quot;) public @ResponseBody String exceptionTest(String param) &#123; if(!param.equalsIgnoreCase(&quot;ok&quot;)) &#123; throw new RuntimeException(&quot;xs&quot;); &#125; return &quot;ok&quot;; &#125; @ExceptionHandler(Exception.class) public String exceptionHandler() &#123; return &quot;error&quot;; &#125;&#125; 当/exceptionTest?param=111调用后，后抛出一个错误RuntimeExceptionc错误，然后会创建一个ExceptionHandlerMethodResolver对象，在该对象中，建立了&lt;Exception.class, exceptionHandler()&gt;这样的映射关系后，由于RuntimeException能匹配到exceptionHandler()方法，所以在SpringMVC中就会调用到Controller中的exceptionHandler()方法。 另外一种逻辑@ControllerAdvice定义了错误处理这个逻辑涉及到的代码如下： 在这段代码中，exceptionHandlerAdviceCache的值是在异常处理器的初始化这步完成初始化的，具体逻辑就在这： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBodyAdvice beans initExceptionHandlerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125;private void initExceptionHandlerAdviceCache() &#123; if (getApplicationContext() == null) &#123; return; &#125; // 找有@ControllerAdvice注解的Bean List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext()); for (ControllerAdviceBean adviceBean : adviceBeans) &#123; Class&lt;?&gt; beanType = adviceBean.getBeanType(); if (beanType == null) &#123; throw new IllegalStateException(&quot;Unresolvable type for ControllerAdviceBean: &quot; + adviceBean); &#125; ExceptionHandlerMethodResolver resolver = new ExceptionHandlerMethodResolver(beanType); if (resolver.hasExceptionMappings()) &#123; this.exceptionHandlerAdviceCache.put(adviceBean, resolver); &#125; if (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123; this.responseBodyAdvice.add(adviceBean); &#125; &#125; if (logger.isDebugEnabled()) &#123; int handlerSize = this.exceptionHandlerAdviceCache.size(); int adviceSize = this.responseBodyAdvice.size(); if (handlerSize == 0 &amp;&amp; adviceSize == 0) &#123; logger.debug(&quot;ControllerAdvice beans: none&quot;); &#125; else &#123; logger.debug(&quot;ControllerAdvice beans: &quot; + handlerSize + &quot; @ExceptionHandler, &quot; + adviceSize + &quot; ResponseBodyAdvice&quot;); &#125; &#125;&#125; 上面代码的意思就是先通过 1234567891011121314151617List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());public static List&lt;ControllerAdviceBean&gt; findAnnotatedBeans(ApplicationContext context) &#123; List&lt;ControllerAdviceBean&gt; adviceBeans = new ArrayList&lt;&gt;(); for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context, Object.class)) &#123; if (!ScopedProxyUtils.isScopedTarget(name)) &#123; ControllerAdvice controllerAdvice = context.findAnnotationOnBean(name, ControllerAdvice.class); if (controllerAdvice != null) &#123; // Use the @ControllerAdvice annotation found by findAnnotationOnBean() // in order to avoid a subsequent lookup of the same annotation. adviceBeans.add(new ControllerAdviceBean(name, context, controllerAdvice)); &#125; &#125; &#125; OrderComparator.sort(adviceBeans); return adviceBeans;&#125; 获取到有@ControllerAdvice注解的类，然后遍历new ExceptionHandlerMethodResolver(beanType)，而ExceptionHandlerMethodResolver的构造方法在上边已经讲过，就是扫描注解@ExceptionHandler，然后建立&lt;异常class对象，Method&gt;这样的映射。 回到异常处理逻辑，还是更具异常class选择对应的方法，并把方法所在的对象和方法封装成ServletInvocableHandlerMethod，之后的流程还是一样。 ResponseStatusExceptionResolver这个就不看源码了，直接说怎么使用 123456789101112131415161718192021@ResponseStatus(code = HttpStatus.FORBIDDEN,reason = &quot;xyz error!&quot;)public class ResponseStatusEx extends RuntimeException &#123; public ResponseStatusEx(String x) &#123; super(x); &#125;&#125;@Controller@RequestMapping(&quot;/user&quot;)public class Controller &#123; @RequestMapping(&quot;/exceptionTest&quot;) public @ResponseBody String exceptionTest(String param) &#123; if(!param.equalsIgnoreCase(&quot;ok&quot;)) &#123; throw new ResponseStatusEx(&quot;xs&quot;); &#125; return &quot;ok&quot;; &#125;&#125; 当/exceptionTest?param=111调用后，就会把匹配到ResponseStatusEx，然后把注解的信息输出：","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"22-SpringMVC的视图解析","slug":"spring/5.2.8/22-SpringMVC的视图解析","date":"2021-11-20T12:00:31.000Z","updated":"2022-03-14T09:04:26.601Z","comments":true,"path":"blog/spring/5.2.8/22-SpringMVC的视图解析/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/22-SpringMVC%E7%9A%84%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"视图解析视图解析已经时边缘技术了，满足不了现在的应用了，这里只是简单的过下 12345678910111213141516public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //具体调用逻辑，重点看 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); ..... try &#123; //返回值处理 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; ..... &#125;&#125; 还是看 12345678910111213this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest);@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName()); &#125; handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; 对于视图解析，这里的HandlerMethodReturnValueHandler是ViewNameMethodReturnValueHandler，看这个类只需要看两个方法 supportsReturnType 12345@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; Class&lt;?&gt; paramType = returnType.getParameterType(); return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));&#125; handleReturnValue 12345678910111213141516@Overridepublic void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue instanceof CharSequence) &#123; String viewName = returnValue.toString(); mavContainer.setViewName(viewName); if (isRedirectViewName(viewName)) &#123; mavContainer.setRedirectModelScenario(true); &#125; &#125; else if (returnValue != null) &#123; //抛错 。。。。 &#125;&#125; 可以看到，这里还没有涉及到视图解析，只是拿到了viewName，然后放入到ModelAndViewContainer中了 这时invokeAndHandle方法返回，栈顶的栈帧变成了RequestMappingHandlerAdapter.invokeHandlerMethod方法的栈帧，所以看回RequestMappingHandlerAdapter方法： 看getModelAndView方法 12345678910111213141516171819202122private ModelAndView getModelAndView(ModelAndViewContainer mavContainer, ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123; modelFactory.updateModel(webRequest, mavContainer); //如果不需要响应视图，这里为true if (mavContainer.isRequestHandled()) &#123; return null; &#125; ModelMap model = mavContainer.getModel(); ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus()); if (!mavContainer.isViewReference()) &#123; mav.setView((View) mavContainer.getView()); &#125; if (model instanceof RedirectAttributes) &#123; Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes(); HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes); &#125; &#125; return mav;&#125; 这个方法只是把上边的viewName封装成了ModelAndView。方法继续返回，回到了DispatcherServlet.doDispatch: 方法processDispatchResult就是真正的进行视图解析的了。 Servlet的视图解析： 这里还是选择匹配的视图解析器，这个些视图解析器和参数解析器一样，都是在WebMvcConfigurationSupport中通过@Bean创建的。 可以看到，ViewResolver返回的是ViewResolverComposite。之后的解析只是把上边返回的ModelAndView进一步解析，把viewName解析成视图文件的目录，然后最后通过Servlet规范，也就是: 12RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/jsp/ok.jsp&quot;);requestDispatcher.forward(req,resp); 把视图的加载和编译交给Servlet容器（tomcat）来完成","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"21-SpringMVC中Controller调用","slug":"spring/5.2.8/21-SpringMVC中Controller调用","date":"2021-11-20T12:00:30.000Z","updated":"2022-03-14T09:04:26.581Z","comments":true,"path":"blog/spring/5.2.8/21-SpringMVC中Controller调用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/21-SpringMVC%E4%B8%ADController%E8%B0%83%E7%94%A8/","excerpt":"","text":"Controller的调用 以注解为例，也就是RequestMappingHandlerAdapter 上面讲了一个请求的处理过程，这里讲请求时怎么调用到对应的controller的。以 在DispatcherServlet的doDispatch方法中，请求匹配到一个HandlerMethod（以注解的为例），然后封装成HandlerExecutionChain，然后根据HandlerMethod匹配到一个HandlerAdapter，接着执行 12// DispatcherServlet.doDispatchModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()) 这里的返回值是RequestMappingHandlerAdapter，下面看HandlerAdapter的handle方法是怎么调用Controller的方法的。 这个方法在RequestMappingHandlerAdapter的父类AbstractHandlerMethodAdapter中实现的，看源码： 123456// AbstractHandlerMethodAdapterpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler);&#125; handleInternal是一个钩子方法，它在RequestMappingHandlerAdapter中实现，跟踪源码后，看invokeHandlerMethod： RequestMappingHandlerAdapter.invokeHandlerMethod——请求处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// RequestMappingHandlerAdapterprotected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; //获取数据绑定工厂 @InitBinder注解支持，没太多用 WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); //Model工厂,收集了@ModelAttribute注解的方法 ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); //可调用的方法对象 ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; //设置参数解析器 invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; //设置返回值解析器 invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; //设置参数绑定工厂 invocableMethod.setDataBinderFactory(binderFactory); //设置参数名称解析类 invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); //调用有@ModelAttribute注解的方法。每次请求都会调用有@ModelAttribute注解的方法 //把@ModelAttribute注解的方法的返回值存储到 ModelAndViewContainer对象的map中了 modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); //异步处理 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123; String formatted = LogFormatUtils.formatValue(result, !traceOn); return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;; &#125;); invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; //Controller方法调用，重点看看 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; 上面的方法有很多细枝的逻辑，我们这里只关注核心逻辑，把细枝的逻辑去掉后，代码变成这样 1234567891011121314151617181920212223242526272829private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; // 可调用的方法对象 // new ServletInvocableHandlerMethod(handlerMethod); ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); if (this.argumentResolvers != null) &#123; // 设置参数解析器 invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); &#125; if (this.returnValueHandlers != null) &#123; // 设置返回值解析器 invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); &#125; //设置参数绑定工厂 invocableMethod.setDataBinderFactory(binderFactory); // 设置参数名称解析类 invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); ModelAndViewContainer mavContainer = new ModelAndViewContainer(); // Controller方法调用，重点看看 invocableMethod.invokeAndHandle(webRequest, mavContainer); return getModelAndView(mavContainer, null, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; 简化后就简单多了。 参数解析器和参数解析器初始化在讲方法调用前先看这段代码 12345678if (this.argumentResolvers != null) &#123; //设置参数解析器 invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);&#125;if (this.returnValueHandlers != null) &#123; //设置返回值解析器 invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);&#125; 这段代码就是用来设置参数解析器和返回值解析器的。argumentResolvers和returnValueHandlers的值的初始化是在afterPropertiesSet方法内完成的 12345678910111213141516171819202122// RequestMappingHandlerAdapterpublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); // 初始化参数解析器 if (this.argumentResolvers == null) &#123; // getDefaultArgumentResolvers这里会返回很多默认的，就是直接new出来的 List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; // 初始化返回值解析器 if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125; getDefaultArgumentResolvers 12345678910111213141516171819202122232425262728293031323334353637383940414243// RequestMappingHandlerAdapterprivate List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;&gt;(30); // Annotation-based argument resolution resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new PathVariableMethodArgumentResolver()); resolvers.add(new PathVariableMapMethodArgumentResolver()); resolvers.add(new MatrixVariableMethodArgumentResolver()); resolvers.add(new MatrixVariableMapMethodArgumentResolver()); resolvers.add(new ServletModelAttributeMethodProcessor(false)); resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new SessionAttributeMethodArgumentResolver()); resolvers.add(new RequestAttributeMethodArgumentResolver()); // Type-based argument resolution resolvers.add(new ServletRequestMethodArgumentResolver()); resolvers.add(new ServletResponseMethodArgumentResolver()); resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new UriComponentsBuilderMethodArgumentResolver()); // Custom arguments if (getCustomArgumentResolvers() != null) &#123; resolvers.addAll(getCustomArgumentResolvers()); &#125; // Catch-all resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new ServletModelAttributeMethodProcessor(true)); return resolvers;&#125; getDefaultReturnValueHandlers 123456789101112131415161718192021222324252627282930313233343536373839404142// RequestMappingHandlerAdapterprivate List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList&lt;&gt;(20); // Single-purpose return value types handlers.add(new ModelAndViewMethodReturnValueHandler()); handlers.add(new ModelMethodProcessor()); handlers.add(new ViewMethodReturnValueHandler()); handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(), this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager)); handlers.add(new StreamingResponseBodyReturnValueHandler()); handlers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new HttpHeadersReturnValueHandler()); handlers.add(new CallableMethodReturnValueHandler()); handlers.add(new DeferredResultMethodReturnValueHandler()); handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory)); // Annotation-based return value types handlers.add(new ModelAttributeMethodProcessor(false)); handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); // Multi-purpose return value types handlers.add(new ViewNameMethodReturnValueHandler()); handlers.add(new MapMethodProcessor()); // Custom return value types if (getCustomReturnValueHandlers() != null) &#123; handlers.addAll(getCustomReturnValueHandlers()); &#125; // Catch-all if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123; handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers())); &#125; else &#123; handlers.add(new ModelAttributeMethodProcessor(true)); &#125; return handlers;&#125; 可以看到，Spring提供了很多的默认的解析器，这些解析器都有一个共同的特征，就是都用一个boolean supportsReturnType方法。这里明显就是用了策略模式，根据情况选择某一个策略。 参数解析器简单介绍注解类型 注解的都是用在参数上的，除了ModelAttribute RequestResponseBodyMethodProcessor 1用来处理@RequestBody注解 RequestParamMethodArgumentResolver 1用来处理@RequestParam注解 RequestParamMapMethodArgumentResolver 1用来处理@RequestParam注解，并把结果以Map的形式返回 RequestPartMethodArgumentResolver 123456789101112用来处理@RequestPart注解。@RequestPart这个注解用在multipart/form-data表单提交请求的方法上。 而且支持同时接收文件和json参数，比如：@PostMapping(&quot;/updateGoods&quot;)@ResponseBodypublic void updateGoods( @RequestPart(&quot;goods&quot;) Goods good, @RequestPart(&quot;file&quot;) MultipartFile file) &#123; System.out.println(&quot;good&quot;+good); System.out.println(&quot;file&quot;+file);&#125;@RequestParam和@RequestPart的区别是：@RequestParam适用于name-valueString类型的请求域，@RequestPart适用于复杂的请求域（像JSON，XML） PathVariableMethodArgumentResolver 123456用于解析@PathVariable注解，获取 URI 中的单个路径变量@PostMapping(&quot;/test/&#123;userId&#125;&quot;)@ResponseBodypublic void updateGoods(@PathVariable(&quot;userId&quot;) Long userId) &#123;&#125; PathVariableMapMethodArgumentResolver 12345678用于解析@PathVariable注解，获取 URI 中的单个路径变量，并把结果保存到Map&lt;String, String&gt;中@PostMapping(&quot;/test/&#123;userId&#125;/&#123;taskId&#125;&quot;)@ResponseBodypublic void updateGoods(@PathVariable Map&lt;String, String&gt; map) &#123;&#125;注意，该只能是Map&lt;String, String&gt; MatrixVariableMethodArgumentResolver 123456789101112131415161718192021用来处理处理@MatrixVariable注解，也就是解析矩阵数据的根据 URI 规范 RFC 3986 中 URL 的定义，路径片段中可以可以包含键值对。规范中没对对应的术语。一般 “URL 路径参数” 可以被应用，尽管更加独特的 “矩阵 URI” 也经常被使用并且相当有名。在 Spring MVC 它被成为矩阵变量矩阵变量可以出现在任何路径片段中，每一个矩阵变量都用分号（;）隔开。比如 “/cars;color=red;year=2012”。多个值可以用逗号隔开，比如 “color=red,green,blue”，或者分开写 “color=red;color=green;color=blue”。如果你希望一个 URL 包含矩阵变量，那么请求映射模式必须用 URI 模板来表示这些矩阵变量。这样的话，不管矩阵变量顺序如何，都能够保证请求可以正确的匹配。开启@Configurationpublic class WebConfig implements WebMvcConfigurer &#123; @Override public void configurePathMatch(PathMatchConfigurer configurer) &#123; UrlPathHelper urlPathHelper=new UrlPathHelper(); urlPathHelper.setRemoveSemicolonContent(false); configurer.setUrlPathHelper(urlPathHelper); &#125;&#125;使用看这https://blog.csdn.net/weixin_43808717/article/details/118771500 MatrixVariableMapMethodArgumentResolver 同上，但参数类型为Map ServletModelAttributeMethodProcessor 1处理@ModelAttribute注解，没啥用 RequestHeaderMethodArgumentResolver 12345678处理@RequestHeader注解，获取request对象的header， 比如 @RequestMapping(&quot;/requestHeaderTest&quot;)public void requestHeaderTest(@RequestHeader(&quot;User-Agent&quot;) String userAgent, @RequestHeader(value=&quot;Accept&quot;) String []accepts) &#123; &#125; RequestHeaderMapMethodArgumentResolver 12345678作用同上，只是参数的类型必须为Map的实现类，比如@RequestMapping(&quot;/requestHeaderTest&quot;)public void requestHeaderTest(@RequestHeadeString HttpHeaders headers, @RequestHeader Map&lt;String, String&gt; headerMap) &#123; &#125;HttpHeaders是MultiValueMap&lt;String, String&gt;的子类 ServletCookieValueMethodArgumentResolver 1234处理@CookieValue注解，获取cookie的值，比如public void requestCookieTest(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123;&#125; SessionAttributeMethodArgumentResolver 12345处理@SessionAttribute注解，获取session的值，比如public void requestCookieTest(@SessionAttribute(&quot;userId&quot;) String userId) &#123;&#125;等价于request.getAttribute(name, RequestAttributes.SCOPE_SESSION); RequestAttributeMethodArgumentResolver 1234处理@RequestAttribute注解，现在没啥用了， 等价于下面于request.getAttributerequest.setAttribute(&quot;name&quot;, &quot;baixue&quot;);request.getAttribute(&quot;name&quot;, &quot;baixue&quot;); ExpressionValueMethodArgumentResolver 1处理参数上的@Value注解，@Value的值需要符合spel表达式 spel表达式 基于类型 ServletRequestMethodArgumentResolver 看下该解析器的supportParameter方法 12345678910111213141516@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; paramType = parameter.getParameterType(); return (WebRequest.class.isAssignableFrom(paramType) || ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType) || HttpSession.class.isAssignableFrom(paramType) || (pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) || Principal.class.isAssignableFrom(paramType) || InputStream.class.isAssignableFrom(paramType) || Reader.class.isAssignableFrom(paramType) || HttpMethod.class == paramType || Locale.class == paramType || TimeZone.class == paramType || ZoneId.class == paramType);&#125; 这个解析器就是解析这些参数的 WebRequest，实际返回的是NativeWebRequest类型的对象 ServletResponseMethodArgumentResolver看下该解析器的supportParameter方法 1234567@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; paramType = parameter.getParameterType(); return (ServletResponse.class.isAssignableFrom(paramType) || OutputStream.class.isAssignableFrom(paramType) || Writer.class.isAssignableFrom(paramType));&#125; HttpEntityMethodProcessor 看下该解析器的supportParameter方法 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return (HttpEntity.class == parameter.getParameterType() || RequestEntity.class == parameter.getParameterType());&#125; RequestEntiry和HttpEntity为请求实体对象，内部封装了 请求行，请求头，请求体 。该对象可以用作 Controller 控制器中 处理方法的入参，SpringMVC会将请求解析成对象 12345@Override@GetMapping(&quot;/test&quot;)public String supportsParameter(RequestEntiry&lt;String&gt; entiry) &#123; return &quot;success&quot;&#125; RedirectAttributesMethodArgumentResolver 1234@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return RedirectAttributes.class.isAssignableFrom(parameter.getParameterType());&#125; RedirectAttributes是用来接收重定向的属性的，所以RedirectAttributes只会用在重新的情况中 ModelMethodProcessor 123public boolean supportsParameter(MethodParameter parameter) &#123; return Model.class.isAssignableFrom(parameter.getParameterType());&#125; 使用Model意味着就是后端渲染页面了，这已经过时了。 MapMethodProcessor 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return Map.class.isAssignableFrom(parameter.getParameterType()) &amp;&amp; parameter.getParameterAnnotations().length == 0;&#125; 用Map接收 UriComponentsBuilderMethodArgumentResolver 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; Class&lt;?&gt; type = parameter.getParameterType(); return (UriComponentsBuilder.class == type || ServletUriComponentsBuilder.class == type);&#125; spring mvc提供了一种机制，可以构造和编码URI，这这些功能就是由UriComponentsBuilder或ServletUriComponentsBuilder完成，其中UriComponentsBuilder是ServletUriComponentsBuilder的父类。 这两个类可以作为工具类使用，也可以作为一个请求方法的入参 第一种情况的话可以看这UriComponentsBuilder和UriComponents 而作为入参的话，会返回一个UriComponentsBuilder或ServletUriComponentsBuilder对象，里面包含了这个请求的url信息 自定义还自持自定义的参数解析器 项目中可以这样定义 1234567891011121314151617181920public class HandlerMethodArgumentResolverDemo implements HandlerMethodArgumentResolver &#123; @Override public boolean supportsParameter(MethodParameter parameter) &#123; return false; &#125; @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; return null; &#125;&#125;@Configurationpublic class WebMvcConfigurerConfig implements WebMvcConfigurer &#123; @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123; resolvers.add(new HandlerMethodArgumentResolverDemo()); &#125;&#125; 重要的结果解析器基于注解 RequestResponseBodyMethodProcessor 处理@ResponseBody 单一用途 ResponseBodyEmitterReturnValueHandler 看supportsReturnType方法 123456789@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; Class&lt;?&gt; bodyType = ResponseEntity.class.isAssignableFrom(returnType.getParameterType()) ? ResolvableType.forMethodParameter(returnType).getGeneric().resolve() : returnType.getParameterType(); return (bodyType != null &amp;&amp; (ResponseBodyEmitter.class.isAssignableFrom(bodyType) || this.reactiveHandler.isReactiveType(bodyType)));&#125; 就是处理ResponseEntity类型返回值 ResponseEntity标识整个http相应：状态码、头部信息以及相应体内容。因此我们可以使用其对http响应实现完整配置。 支持请求异步处理的返回值解析器支持请求异步处理的返回值解析器 自定义返回值解析器123456789101112131415161718192021public class HandlerMethodReturnValueHandlerDemo implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return false; &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; &#125;&#125;@Configurationpublic class WebMvcConfigurerConfig implements WebMvcConfigurer &#123; @Override public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123; handlers.add(new HandlerMethodReturnValueHandlerDemo()); &#125;&#125; 处理请求源码回到源码RequestMappingHandlerAdapter.invokeHandlerMethod 12345678910111213141516171819202122// handlerMethod 为HandlerMethodServletInvocableHandlerMethod invocableMethod = new ServletInvocableHandlerMethod(handlerMethod);ModelAndViewContainer mavContainer = new ModelAndViewContainer();invocableMethod.invokeAndHandle(webRequest, mavContainer);// ServletInvocableHandlerMethodpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //具体调用逻辑，重点看 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); ..... try &#123; //返回值处理 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; ..... &#125;&#125; 上面代码就是请求的Controller的调用过程，先看invokeForRequest方法 1234567891011// ServletInvocableHandlerMethodpublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //获取参数数组,重点看 Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Arguments: &quot; + Arrays.toString(args)); &#125; return doInvoke(args);&#125; 这个方法有两个逻辑 通过参数解析器获取方法的参数值 方法调用 方法调用很简单，就是一个反射调用，现在重点看第一点，获取方法的参数值getMethodArgumentValues 123456789101112131415161718192021222324252627282930313233343536373839protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //入参的包装类，里面包装了参数类型，参数名称，参数注解等等信息 MethodParameter[] parameters = getMethodParameters(); if (ObjectUtils.isEmpty(parameters)) &#123; return EMPTY_ARGS; &#125; Object[] args = new Object[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; //设置参数名称解析器 parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); args[i] = findProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; //典型的策略模式，根据parameter能否找到对应参数的处理类，能找到就返回true if (!this.resolvers.supportsParameter(parameter)) &#123; throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;)); &#125; try &#123; //具体参数值解析过程,重点看看 args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception ex) &#123; // Leave stack trace for later, exception may actually be resolved and handled... if (logger.isDebugEnabled()) &#123; String exMsg = ex.getMessage(); if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123; logger.debug(formatArgumentError(parameter, exMsg)); &#125; &#125; throw ex; &#125; &#125; return args;&#125; 这个方法的都有注释了，这里的难点就是参数的处理类和参数的解析过程，因为这些过程涉及到很多类，这些类在上边也截图了，在这里就看最常用的RequestResponseBodyMethodProcessor 解析JSON参数在Controller中这样定义了一个方法 12345@RequestMapping(&quot;/converter&quot;)@ResponseBodypublic ConsultConfigArea converter(@RequestBody ConsultConfigArea area) &#123; return area;&#125; 这样形式是最常用到的，在局部变量上加上@RequestBody就是把Request body中的json数据解析成对象ConsultConfigArea。完成这一工作的解析类是RequestResponseBodyMethodProcessor 先看supportsParameter方法： 1234@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class);&#125; 就是判断参数上是否有@RequestBody注解 最后看resolveArgument方法 1234567891011121314151617181920212223@Overridepublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); if (binderFactory != null) &#123; WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; if (mavContainer != null) &#123; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); &#125; &#125; return adaptArgumentIfNecessary(arg, parameter);&#125; 这个方法的核心方法是 1Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); 从这个方法从名字上看就用消息转换器（MessageConverters）这些转换器都实现了HttpMessageConverter接口，这个消息转换器就是在RequestMappingHandlerAdapter初始化参数解析器和结果解析器时，某些解析器通过getMessageConverters()获取到MessageConverters。 消息转换器——HttpMessageConverters 而对于参数解析器来说，用到MessageConverters的不多，就3个参数解析器用到，其中最常用的参数解析就时这节讲的RequestResponseBodyMethodProcessor解析器。而这个解析器是在启动过程设置进去的，回到SpringMVC的启动注解@EnableWebMvc。 123456789101112//WebMvcConfigurationSupportprotected final List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123; if (this.messageConverters == null) &#123; this.messageConverters = new ArrayList&lt;&gt;(); configureMessageConverters(this.messageConverters); if (this.messageConverters.isEmpty()) &#123; addDefaultHttpMessageConverters(this.messageConverters); &#125; extendMessageConverters(this.messageConverters); &#125; return this.messageConverters;&#125; configureMessageConverters是一个钩子方法，他的实现类DelegatingWebMvcConfiguration，之前已经讲过了，这个类是通过 123456789101112131415private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();@Autowired(required = false)public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125;&#125;@Overrideprotected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; this.configurers.configureMessageConverters(converters);&#125; 这样的方式，提供了灵活的扩展。 addDefaultHttpMessageConverters这个方法是在我们没有添加自己的HttpMessageConverters时，Spring帮我们添加一些默认的HttpMessageConverters。(Spring Boot不同了，因为有个WebMvcAutoConfiguration的存在) extendMessageConverters也是一个扩展方法，它和configureMessageConverters一样，但不同的是这两个方法假如都实现了，执行完后HttpMessageConverters的顺序会不同，configureMessageConverters会在前面，extendMessageConverters的会在后面，因为messageConverters是一个ArrayList，有顺序的，而顺序是很重要的，下面在看RequestResponseBodyMethodProcessor的readWithMessageConverters中会看到。而且还有一点，假如重写了configureMessageConverters这个方法，那么就不会有默认的HttpMessageConverters了，而重写extendMessageConverters不会有这个问题。所以一般的情况下都是重写extendMessageConverters这个方法的。 回到源码，RequestResponseBodyMethodProcessor的readWithMessageConverters方法最重要的就是这个地方。可以看到，就是对messageConverters进行遍历，而且只要有一个符合条件并执行完了，那么for就结束了。 返回JSON结果上边看了参数解析，结果解析也很简单 1234567891011121314151617// ServletInvocableHandlerMethodpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; //具体调用逻辑，重点看 Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); ..... try &#123; //返回值处理 this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; ..... &#125;&#125; 上边看了Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 这里看 12this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); 跟踪代码，最后： 可以看到和参数解析的逻辑基本是一样的。 这里最好debug跟踪下代码，入口类和方法通过上边的已经知道了，debug下代码可以时得印象更加深刻","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"20-SpringMVC中请求是怎么到达Controller的","slug":"spring/5.2.8/20-SpringMVC中请求是怎么到达Controller的","date":"2021-11-20T12:00:29.000Z","updated":"2022-03-14T09:04:26.551Z","comments":true,"path":"blog/spring/5.2.8/20-SpringMVC中请求是怎么到达Controller的/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/20-SpringMVC%E4%B8%AD%E8%AF%B7%E6%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%B0%E8%BE%BEController%E7%9A%84/","excerpt":"","text":"SpringMVC中请求是怎么到达Controller的注意：主要讲注解的形式 上节中讲了SpringMVC的启动流程，这节讲的就是主干流程，请求是怎么到达SpringMVC的Controller的。 SpringMVC中的Servlet是DispatcherServlet，SpringMVC中所有请求都会由DispatcherServlet来处理，而根据Servlet的规范，请求最先到达的方法是service(HttpServletRequest req, HttpServletResponse resp)。所以看DispatcherServlet的这个方法： 123456789101112// FrameworkServlet DispatcherServletprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (httpMethod == HttpMethod.PATCH || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125;&#125; super.service(request, response)这里是Servlet规范的方法，根据请求的HttpMethod来选择对应的do方法，比如doGet、doPost等，比如现在有一个Get请求，那看doGet方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// FrameworkServletprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;// FrameworkServletprotected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125;&#125; 这个方法最重要的就是调用了doService(request, response)，这是个钩子方法，在看这个方法前，先看调用之前做了什么： 看箭头的3行代码，这里3行的逻辑很简单，就是通过HttpServletRequest和HttpServletResponse创建ServletRequestAttributes对象，然后把对象放入到RequestContextHolder里面的一个ThreadLocal中。也就是说，在业务代码中可以通过 1234ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();HttpServletRequest request = servletRequestAttributes.getRequest();HttpServletResponse response = servletRequestAttributes.getResponse(); 这样的方式来获取到Reqeust和Respon对象，回到源码，现在看doService(request, response)，该方法是由DispatcherServlet重写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//DispatcherServletprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; try &#123; doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; &#125;&#125; 这里就是往request中设置属性，我们看最核心的方法doDispatch(request, response) 有一个request属性很有意思，就是 1234567// DispatcherServlet// String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + &quot;.CONTEXT&quot;;request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());public final WebApplicationContext getWebApplicationContext() &#123; return this.webApplicationContext;&#125; 通过这样设置后，在项目中就能通过request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE)这段代码获取到SpringMVC的上下，而该对象的的类型为AnnotationConfigWebApplicationContext。也就是说可以通过getParentBeanFactory方法到父BeanFactory，也就是Spring的上下文，该上下的类型也为AnnotationConfigWebApplicationContext。而且也能通过getServletContext()方法，获取到ServletContext，这样也就能做一些添加Servlet等操作，也可以通过ServletContext.getAttribute方法获取很多内置的对象。 DispatcherServlet.doDispatch这个是SpringMVC最核心的方法！这里包含了一个请求在SpringMVC中的完整的处理过程。看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// DispatcherServletprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; //异步管理器 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //文件上传 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); //这个方法很重要，重点看 // Determine handler for the current request. mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; //获取跟HandlerMethod匹配的HandlerAdapter对象 // Determine handler adapter for the current request. HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; //前置过滤器，如果为false则直接返回 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; //调用到Controller具体方法，核心方法调用，重点看看 // Actually invoke the handler. mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); //中置过滤器 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#x27;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; //视图渲染 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 从上面贴出的注释可以看到，这个方法很重要，直接包含了一个请求的整个处理过程。 DispatcherServlet#getHandler——确定当前请求的处理程序（HandlerExecutionChain） 这里以注解形式形式的controller讲解。还有BeanNameUrlHandlerMapping和SimpleUrlHandlerMapping。下面的SpringMVC中定义Controller就讲了这些HandlerMapping对于的controller定义方式，顺序就按这里的顺序来，BeanNameUrlHandlerMapping和SimpleUrlHandlerMapping对应两种使用场景，具体看SpringMVC中定义Controller 前置知识：SpringMVC中定义Controller 所以先看这块代码： 12345678910// DispatcherServletHandlerExecutionChain mappedHandler = null;.....// 这个方法很重要，重点看// Determine handler for the current request.mappedHandler = getHandler(processedRequest);if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 通过HandlerMapping获取Handler。看这块代码块的核心方法getHandler: 1234567891011121314// DispatcherServletprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //handlerMappering实例 if (this.handlerMappings != null) &#123; for (HandlerMapping mapping : this.handlerMappings) &#123; //获取HandlerMethod和过滤器链的包装类 HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; &#125; return null;&#125; 代码中handlerMappings在上一节已经说过了，它是在DispatcherServlet中的initHandlerMapper()方法中初始化的，触发过程就是当SpringMVC上下文初始化完毕后，会发布一个ContextRefreshEvent事件，而这个事件的监听器是ContextRefreshListener。 而initHandlerMappings方法只是在Spring的两个上下文中（父上下文和SpringMVC上下文）收集实现了HandlerMapping接口的类 而这些类是通过@EnableWebMVC注解@Import引入的DelegatingWebMvcConfiguration类@Bean进去到上下文的。@Bean的类有 RequestMappingHandlerMapping SimpleUrlHandlerMapping BeanNameUrlHandlerMapping RouterFunctionMapping beanName&#x3D;viewControllerHandlerMapping，类型为SimpleUrlHandlerMapping handlerMappings在SpringMVC的初始化完成后已经有值了，默认情况下有这些值： 上面这些类的作用就是根据request对象中的uri，去所有的HandlerMapping中的映射关系中查找对应的handler对象。而不同的HandlerMapping对象的作用都是一样的，就是建立uri和handler映射，然后通过uri获取handler。 看回源码看mapping.getHandler(request)。该方法会返回一个HandlerExecutionChain。HandlerExecutionChain就是一个Handler链，其中包含了拦截器和HandlerMethod。 看源码： 而这个AbstractHandlerMapping都是Spring中所有HandlerMapping的父类，这其实就是用了模版设计模式，其中整个请求getHandler也就是获取HandlerMethod的逻辑都定义在了AbstractHandlerMapping中，而其子类的作用就只是在这个这个基础了重写一些方法，用不同的逻辑进行URI和Handler的绑定。 AbstractHandlerMapping#getHandler——获取Handler的骨干方法1234567891011121314151617181920212223242526272829303132// AbstractHandlerMappingpublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; //根据请求的uri拿到对应的HandlerMethod对象 Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = obtainApplicationContext().getBean(handlerName); &#125; // 对拦截器链和HandlerMethod进行封装 HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); //是否是跨域请求,就是查看request请求头中是否有Origin属性 if (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123; //自定义的钩子方法获取跨域配置 CorsConfiguration config = (this.corsConfigurationSource != null ? this.corsConfigurationSource.getCorsConfiguration(request) : null); //注解获取跨域配置 CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); config = (config != null ? config.combine(handlerConfig) : handlerConfig); //这里添加了跨域的过滤器CorsInterceptor executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125; 这个方法中，只有getHandlerInternal是钩子方法，其他的方法都没有被重写。 而这个方法的逻辑也很简答，就是先通过getHandlerInternal获取到handler，然后把handler和项目定义的HandlerInterceptor通过getHandlerExecutionChain方法，包装成&#96;&#96;HandlerExecutionChain&#96;对象，最后添加跨域拦截器。 下面看不同的HandlerMapping是如何处理请求的。 RequestMappingHandlerMapping——处理@Controller注解或者@RequestMapping注解 getHandlerInternal该类没有重写该方，所以看父类。 跟踪代码： 123456789101112131415161718//AbstractHandlerMethodMapping@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; //从request对象中获取uri，/common/query2 String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); request.setAttribute(LOOKUP_PATH, lookupPath); // 获取读锁 this.mappingRegistry.acquireReadLock(); try &#123; //根据uri从映射关系中找到对应的HandlerMethod对象 HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); //把Controller类实例化 return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125; 这里看第一行代码： 1String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); 我通过浏览器访问了这个地址： 可以看到，这行代码的作用就是获取请求的uri，这个方法可以作为工具类在项目中使用，下面看下这个getUrlPathHelper： 1234public UrlPathHelper getUrlPathHelper() &#123; return this.urlPathHelper;&#125;UrlPathHelper urlPathHelper = new UrlPathHelper(); lookupHandlerMethod代码继续中，获取了读锁后，执行了这行代码： 1HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); 这行代码的作用就是根据uri从映射关系中找到对应的HandlerMethod对象，看源码： 1234567891011121314151617181920212223242526272829303132333435363738394041// AbstractHandlerMethodMappingprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;&gt;(); List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath); if (directPathMatches != null) &#123; addMatchingMappings(directPathMatches, matches, request); &#125; if (matches.isEmpty()) &#123; // No choice but to go through all mappings... addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request); &#125; if (!matches.isEmpty()) &#123; Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); matches.sort(comparator); bestMatch = matches.get(0); if (logger.isTraceEnabled()) &#123; logger.trace(matches.size() + &quot; matching mappings: &quot; + matches); &#125; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); String uri = request.getRequestURI(); throw new IllegalStateException( &quot;Ambiguous handler methods mapped for &#x27;&quot; + uri + &quot;&#x27;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod); handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod; &#125; else &#123; return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request); &#125;&#125; 看开头的代码。 12345678910// AbstractHandlerMethodMappingList&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);// AbstractHandlerMethodMappingprivate final MappingRegistry mappingRegistry = new MappingRegistry();// MappingRegistrypublic List&lt;T&gt; getMappingsByUrl(String urlPath) &#123; return this.urlLookup.get(urlPath);&#125; 这行代码就是根据请求的uri从urlLookup中取值，那问题来了，mappingRegistry.urlLookup这个值是什么时候初始化的？ url和方法的映射关系建立——RequestMappingHandlerMapping先看下urlLookup的定义: 12// MappingRegistryprivate final MultiValueMap&lt;String, T&gt; urlLookup = new LinkedMultiValueMap&lt;&gt;(); 可以看到，他就是一个map，不过这个map的值是一个List。现在的问题就是这个映射关系是什么时候建立的。或者这样说，在我们的项目中，我们都会写很多的Controller，比如： 而Controller中，在类上和方法上都有uri，这些uri肯定要拼凑起来的，接着通过拼凑起来的uri建立与方法的映射。上边建立的映射是： &#x2F;common&#x2F;index——commonController.index() &#x2F;common&#x2F;query1——commonController.query1() 好了，问题来了，就是这些映射是什么时候建立的。 现在看下RequestMappingHandlerMapping的类图： 可以发现，他实现了InitializingBean接口，也就是会执行afterPropertiesSet方法。 1234567891011121314151617// RequestMappingHandlerMappingpublic void afterPropertiesSet() &#123; this.config = new RequestMappingInfo.BuilderConfiguration(); this.config.setUrlPathHelper(getUrlPathHelper()); this.config.setPathMatcher(getPathMatcher()); this.config.setSuffixPatternMatch(useSuffixPatternMatch()); this.config.setTrailingSlashMatch(useTrailingSlashMatch()); this.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch()); this.config.setContentNegotiationManager(getContentNegotiationManager()); super.afterPropertiesSet();&#125;// AbstractHandlerMethodMappingpublic void afterPropertiesSet() &#123; initHandlerMethods();&#125; 重点看initHandlerMethods方法。 1234567891011// AbstractHandlerMethodMappingprotected void initHandlerMethods() &#123; for (String beanName : getCandidateBeanNames()) &#123; // 这里把以targetSource.开去的beanName去掉，因为这开头的对象，是不参与依赖注入的，而且这种对象在Spring中没有实例的作用，有用的是该对象的代理对象 // 具体看 11-Spring中多例TargetSource if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123; processCandidateBean(beanName); &#125; &#125; handlerMethodsInitialized(getHandlerMethods());&#125; 第一行getCandidateBeanNames()就是获取上下文中所有的beanNames。 现在看processCandidateBean方法: 12345678910111213141516// AbstractHandleMethodMappingprotected void processCandidateBean(String beanName) &#123; Class&lt;?&gt; beanType = null; try &#123; beanType = obtainApplicationContext().getType(beanName); &#125; catch (Throwable ex) &#123; // An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it. ... &#125; //如果类上面有@Controller注解或者@RequestMapping注解 if (beanType != null &amp;&amp; isHandler(beanType)) &#123; //建立uri和method的映射关系 detectHandlerMethods(beanName); &#125;&#125; 这段代码的重点就是isHandler(beanType)方法，这个方法是钩子方法，在RequestMappingHandlerMapping中的实现为： 12345// RequestMappingHandlerMapping protected boolean isHandler(Class&lt;?&gt; beanType) &#123; return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) || AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));&#125; 这个判断很简单，就是判断类上面是否有@Controller注解或者@RequestMapping注解，如果有，这个类就是要处理的类，就执行detectHandlerMethods方法。现在看detectHandlerMethods的源码： 123456789101112131415161718192021222324252627// AbstractHandlerMethodMappingprotected void detectHandlerMethods(Object handler) &#123; Class&lt;?&gt; handlerType = (handler instanceof String ? obtainApplicationContext().getType((String) handler) : handler.getClass()); if (handlerType != null) &#123; Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); // 这个在Spring初始化的收集注解阶段就看过类似的 //获取方法对象和方法上面的@RequestMapping注解属性封装对象的映射关系 Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); &#125; &#125;); methods.forEach((method, mapping) -&gt; &#123; Method invocableMethod = AopUtils.selectInvocableMethod(method, userType); //建立uri和方法的各种映射关系，反正一条，根据uri要能够找到method对象 registerHandlerMethod(handler, invocableMethod, mapping); &#125;); &#125;&#125; 这段代码在Bean初始化时，在@Autowire等注解的收集上讲过了，作用就是遍历类上的方法。所以这段代码只需要看getMappingForMethod方法就好了。这个方法时钩子方法，在RequestMappingHandlerMapping中实现了，RequestMappingHandlerMapping上的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// RequestMappingHandlerMappingprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; //寻找有@RequestMapping注解的方法，然后注解里面的内容封装成对象 RequestMappingInfo info = createRequestMappingInfo(method); if (info != null) &#123; //类上面的@RequestMapping注解也封装成对象 RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); if (typeInfo != null) &#123; //把方法上面的注解属性结合到类上面的RequestMappingInfo对象中 info = typeInfo.combine(info); &#125; String prefix = getPathPrefix(handlerType); if (prefix != null) &#123; info = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info); &#125; &#125; return info;&#125;// RequestMappingHandlerMappingprivate RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) &#123; RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class); RequestCondition&lt;?&gt; condition = (element instanceof Class ? getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element)); return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);&#125;// RequestMappingHandlerMappingprotected RequestMappingInfo createRequestMappingInfo( RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) &#123; RequestMappingInfo.Builder builder = RequestMappingInfo .paths(resolveEmbeddedValuesInPatterns(requestMapping.path())) .methods(requestMapping.method()) .params(requestMapping.params()) .headers(requestMapping.headers()) .consumes(requestMapping.consumes()) .produces(requestMapping.produces()) .mappingName(requestMapping.name()); if (customCondition != null) &#123; builder.customCondition(customCondition); &#125; return builder.options(this.config).build();&#125; RequestMappingInfo的创建使用了建造者模式 这段代码的意思就是： 将方法上的这些信息封装成RequestMappingInfo对象，然后将： 类上的@RequestMapping注解封装成RequestMappingInfo对象，然后把方法上面的注解属性结合到类上面的RequestMappingInfo对象中，最后返回。 回到detectHandlerMethods的源码，把类上的方法都遍历完后，就建立了这样的映射关系&lt;Method, RequestMappingInfo&gt;。看运行时的情况： 继续看detectHandlerMethods这块代码： 现在有了这个对应关系&lt;Method, RequestMappingInfo&gt;，比如&lt;CommonController.index(), RequestMappingInfo(&#x2F;common&#x2F;index)&gt;，现在回到最开始的问题，就是MappingRegistry.urlLookup这个属性的值是怎么初始化话的？答案就在，上边代码块的registerHandlerMethod方法中，看这个方法的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// RequestMappingHandlerMapping@Overrideprotected void registerHandlerMethod(Object handler, Method method, RequestMappingInfo mapping) &#123; super.registerHandlerMethod(handler, method, mapping); updateConsumesCondition(mapping, method);&#125;// super.registerHandlerMethod(handler, method, mapping);// AbstractHandlerMethodMappingprotected void registerHandlerMethod(Object handler, Method method, T mapping) &#123; this.mappingRegistry.register(mapping, handler, method);&#125;// MappingRegistrypublic void register(T mapping, Object handler, Method method) &#123; // Assert that the handler method is not a suspending one. if (KotlinDetector.isKotlinType(method.getDeclaringClass())) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if ((parameterTypes.length &gt; 0) &amp;&amp; &quot;kotlin.coroutines.Continuation&quot;.equals(parameterTypes[parameterTypes.length - 1].getName())) &#123; throw new IllegalStateException(&quot;Unsupported suspending handler method detected: &quot; + method); &#125; &#125; // 获取写锁 this.readWriteLock.writeLock().lock(); try &#123; //创建HandlerMethod对象，其实 HandlerMethod handlerMethod = createHandlerMethod(handler, method); //检验是否唯一 validateMethodMapping(handlerMethod, mapping); //建立uri对象和handlerMethod的映射关系 this.mappingLookup.put(mapping, handlerMethod); List&lt;String&gt; directUrls = getDirectUrls(mapping); for (String url : directUrls) &#123; //建立url和RequestMappingInfo映射关系 this.urlLookup.add(url, mapping); &#125; String name = null; if (getNamingStrategy() != null) &#123; name = getNamingStrategy().getName(handlerMethod, mapping); addMappingName(name, handlerMethod); &#125; //判断method上是否有CrossOrigin注解，把注解里面的属性封装成CorsConfiguration，这个是做跨域访问控制的 CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping); if (corsConfig != null) &#123; //建立映射关系 this.corsLookup.put(handlerMethod, corsConfig); &#125; this.registry.put(mapping, new MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name)); &#125; finally &#123; this.readWriteLock.writeLock().unlock(); &#125;&#125; 上边的MappingRegistry#register入参为 mapping：就是RequestMappingInfo handler：beanName，在运行时从上下文中获取对应的bean method：要执行的方法 好了，已经到建立映射的核心源码了，就是MappingRegistry的register！下面按步骤讲解 注意，MappingRegistry是AbstractHandlerMethodMapping的内部类 创建HandlerMethod对象 12345678910HandlerMethod handlerMethod = createHandlerMethod(handler, method);// AbstractHandlerMethodMappingprotected HandlerMethod createHandlerMethod(Object handler, Method method) &#123; if (handler instanceof String) &#123; return new HandlerMethod((String) handler, obtainApplicationContext().getAutowireCapableBeanFactory(), method); &#125; return new HandlerMethod(handler, method);&#125; HandlerMethod就是用来封装方法、方法的参数和执行方法的对象的，但在这里有可能会一种情况，就是传入的不是目标对象，而是目标对象的beanName的时候： 这时，这个HandlerMethod，就是用来封装beanName，beanFactory、方法和方法的参数的了。 通过validateMethodMapping(handlerMethod, mapping)方法来检查uri是否唯一 this.mappingLookup.put(mapping, handlerMethod);建立uri对象（RequestMappingInfo）和HandlerMethod的映射关系 这时已经有了&lt;RequestMappingInfo, HandlerMethod&gt;的对应关系了，但在上面的请求调用中，是通过uri从urlLookup中找某个对象的的（这里其实可以猜到，找的对象是RequestMappingInfo） 建立uri和HandlerMethod的映射 通过List&lt;String&gt; directUrls = getDirectUrls(mapping);获取到RequestMappingInfo上的uri，然后 1234for (String url : directUrls) &#123; //建立url和RequestMappingInfo映射关系 this.urlLookup.add(url, mapping);&#125; 通过this.urlLookup.add(url, mapping);建立了映射关系，而这个映射关系为 1&lt;uri, List&lt;RequestMappingInfo&gt; 这也就解答了开头的问题。 建立@CrossOrigin注解与HandlerMethod的映射 123456//判断method上是否有CrossOrigin注解，把注解里面的属性封装成CorsConfiguration，这个是做跨域访问控制的CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);if (corsConfig != null) &#123; //建立映射关系 this.corsLookup.put(handlerMethod, corsConfig);&#125; 上边的initCorsConfiguration在RequestMappingHandlerMapping重写，逻辑是检查类上和方法上的CrossOrigin注解，然后封装成CorsConfiguration对象，最后建立 1&lt;HandlerMethod, CorsConfiguration&gt; 这种映射，最后把这个映射保存到corsLookup中。 回到lookupHandlerMethodAbstractHandlerMethodMapping.lookupHandlerMethod List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);通过这行代码根据url就能找到匹配的RequestMappingInfo对象列表了，而之所以是一个List，是因为Controller中可以定义同一个url但是Method不同的，比如GET、POST。 继续看代码： 1234567891011121314// AbstractHandlerMethodMapping.lookupHandlerMethodif (directPathMatches != null) &#123; addMatchingMappings(directPathMatches, matches, request);&#125;private void addMatchingMappings(Collection&lt;T&gt; mappings, List&lt;Match&gt; matches, HttpServletRequest request) &#123; for (T mapping : mappings) &#123; //根据request对象来创建RequestMappingInfo对象 T match = getMatchingMapping(mapping, request); if (match != null) &#123; matches.add(new Match(match, this.mappingRegistry.getMappings().get(mapping))); &#125; &#125;&#125; getMatchingMapping方法被RequestMappingHandlerMapping重写了，源码为 1234// RequestMappingHandlerMappingprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) &#123; return info.getMatchingCondition(request);&#125; 这段代码的意思就是根据请求去匹配RequestMappingInfo的，看getMatchingMapping的方法就一目了然了 1234567891011121314151617181920212223242526272829303132333435363738//RequestMappingInfoHandlerMappingprotected RequestMappingInfo getMatchingMapping(RequestMappingInfo info, HttpServletRequest request) &#123; return info.getMatchingCondition(request);&#125;public RequestMappingInfo getMatchingCondition(HttpServletRequest request) &#123; RequestMethodsRequestCondition methods = this.methodsCondition.getMatchingCondition(request); if (methods == null) &#123; return null; &#125; ParamsRequestCondition params = this.paramsCondition.getMatchingCondition(request); if (params == null) &#123; return null; &#125; HeadersRequestCondition headers = this.headersCondition.getMatchingCondition(request); if (headers == null) &#123; return null; &#125; ConsumesRequestCondition consumes = this.consumesCondition.getMatchingCondition(request); if (consumes == null) &#123; return null; &#125; ProducesRequestCondition produces = this.producesCondition.getMatchingCondition(request); if (produces == null) &#123; return null; &#125; PatternsRequestCondition patterns = this.patternsCondition.getMatchingCondition(request); if (patterns == null) &#123; return null; &#125; RequestConditionHolder custom = this.customConditionHolder.getMatchingCondition(request); if (custom == null) &#123; return null; &#125; return new RequestMappingInfo(this.name, patterns, methods, params, headers, consumes, produces, custom.getCondition());&#125; 可以看到，就算通过url匹配到了RequestMappingInfo，但这个请需要满足RequestMappingInfo设置的条件才能完成匹配。看下面的例子。 例如：我在Controller中定义了这个请求： 1234567891011121314@Controller@RequestMapping(&quot;/common&quot;)public class CommonController &#123; @RequestMapping(value = &quot;/getUser&quot;, method = RequestMethod.GET, params = &quot;username=jack&quot;, consumes = &quot;application/json&quot;, //输入参数的格式 produces = &quot;application/json&quot;, //返回参数的格式 headers = &quot;Referer=http://www.com.jack.controller.xx.com/&quot;) public @ResponseBody String getUser(HttpSession session, OutputStream outputStream) &#123; return &quot;com.jack.controller.xx&quot;; &#125;&#125; 也就是说只有在请求都符合上边的条件，这个方法才会被调用成功。不符合条件是： 好了，回到匹配代码，比如匹配成功了，执行这样代码 1matches.add(new Match(match, this.mappingRegistry.getMappings().get(mapping))); mappingRegistry.getMappings()这返回的是mappingLookup，经过上边的分析，这个属性保存的是&lt;RequestMappingInfo, HandlerMethod&gt;这个映射关系的，所以get返回的就是HandlerMethod，而match就是通过getMatchingMapping匹配成功后创建的新的RequestMappingInfo。所以matches里放的就是新的RequestMappingInfo和HandlerMethod，代码继续走（这里都考虑匹配到的情况）： 如果没有匹配到，就只能从所有的RequestMappingInfo中查找了 1234567891011121314151617181920212223242526// AbstractHandlerMethodMapping.lookupHandlerMethodif (!matches.isEmpty()) &#123; Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); matches.sort(comparator); bestMatch = matches.get(0); if (logger.isTraceEnabled()) &#123; logger.trace(matches.size() + &quot; matching mappings: &quot; + matches); &#125; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); String uri = request.getRequestURI(); throw new IllegalStateException( &quot;Ambiguous handler methods mapped for &#x27;&quot; + uri + &quot;&#x27;: &#123;&quot; + m1 + &quot;, &quot; + m2 + &quot;&#125;&quot;); &#125; &#125; request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod); handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod;&#125; 这里代码就是如果匹配到多个，会重新排序后，取第一个为最佳匹配，然后用第一个和第二个比较，如果设置的条件都完全匹配，那么就报错了。获取到了最佳的匹配后往request中设置一些值然后就把匹配的HandlerMethod返回了。 找到最佳的匹配后，会把当前的HandlerMethod暴露到Request对象中。 12// HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTErequest.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod); 这样设置后，就能在项目中获取到HandlerMethod了。 handleMatch方法在RequestMappingHandlerMapping重写了，该方法也是去暴露一些属性而已，其中我觉得有用的是 12// HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTErequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, lookupPath); 这个暴露的是请求的地址。 lookupHandlerMethod方法最后就返回了匹配到的HandlerMethod（对象、方法）。 lookupHandlerMethod方法已经讲完了。 回到getHandlerInternal——通过BeanName获取Bean1234//根据uri从映射关系中找到对应的HandlerMethod对象HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);//把Controller类实例化return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); 现在返回了HandlerMethod后就执行了handlerMethod.createWithResolvedBean方法。看源码: 12345678910public HandlerMethod createWithResolvedBean() &#123; Object handler = this.bean; if (this.bean instanceof String) &#123; Assert.state(this.beanFactory != null, &quot;Cannot resolve bean name without BeanFactory&quot;); String beanName = (String) this.bean; handler = this.beanFactory.getBean(beanName); &#125; // 这里之每次调用都需要从beanFactory中获取对象，是因为在SpringMVC中有新增了一些Scope（比如Session） return new HandlerMethod(this, handler);&#125; 这个方法其实挺简单的，最终结果都会返回一个新的HandlerMethod，而如果旧的HandlerMethod中的bean是字符串，就会从BeanFactory中获取到Bean。而我们使用注解，也就是使用RequestMappingHandlerMapping去匹配请求时，这个HandlerMethod的bean就是beanName。 SimpleUrlHandlerMapping——处理HttpRequestHandler接口的实现在SpringMVC中定义Controller中讲了HttpRequestHandler接口是如何定义Controller的，这里看下在Spring中是如何实现的 getHandlerInternal 看AbstractUrlHandlerMapping.getHandlerInternal 1234567891011121314151617181920212223242526272829// AbstractUrlHandlerMapping@Override@Nullableprotected Object getHandlerInternal(HttpServletRequest request) throws Exception &#123; String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); request.setAttribute(LOOKUP_PATH, lookupPath); Object handler = lookupHandler(lookupPath, request); if (handler == null) &#123; // We need to care for the default handler directly, since we need to // expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well. Object rawHandler = null; if (&quot;/&quot;.equals(lookupPath)) &#123; rawHandler = getRootHandler(); &#125; if (rawHandler == null) &#123; rawHandler = getDefaultHandler(); &#125; if (rawHandler != null) &#123; // Bean name or resolved handler? if (rawHandler instanceof String) &#123; String handlerName = (String) rawHandler; rawHandler = obtainApplicationContext().getBean(handlerName); &#125; validateHandler(rawHandler, request); handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, null); &#125; &#125; return handler;&#125; 看lookupHandler 可以看到，这个方法其实就是从handleMap中拿handler，如果handler是String，也就是是beanName的话，就从beanFactory中拿。整个流程很简答， 这里有个问题，就是url什么时候和handler建立联系的 url与handler建立映射对项目中自定义的SimpleUrlHandlerMapping，比如： 123456789101112@Configurationpublic class SimpleUrlConfig &#123; @Bean public SimpleUrlHandlerMapping simpleUrlHandlerMapping() &#123; SimpleUrlHandlerMapping suhm = new SimpleUrlHandlerMapping(); Properties properties = new Properties(); properties.put(&quot;area/index&quot;,&quot;areaController&quot;); suhm.setMappings(properties); return suhm; &#125;&#125; 看setMappings 1234// SimpleUrlHandlerMappingpublic void setMappings(Properties mappings) &#123; CollectionUtils.mergePropertiesIntoMap(mappings, this.urlMap);&#125; 这个方法只是把路径和baenName保存到SimpleUrlHandlerMapping的urlMap集合中。现在看下SimpleUrlHandlerMapping的类图，该类实现了一个接口ApplicationContextAware接口，所以看setApplicationContext方法，该方法在ApplicationObjectSupport中实现了 这里调用initApplicationContext方法，跟踪代码： 1234567ApplicationObjectSupport.initApplicationContext// ApplicationObjectSupportprotected void initApplicationContext(ApplicationContext context) throws BeansException &#123; initApplicationContext();&#125; 方法initApplicationContext()被SimpleUrlHandlerMapping重写了 123456// SimpleUrlHandlerMapping@Overridepublic void initApplicationContext() throws BeansException &#123; super.initApplicationContext(); registerHandlers(this.urlMap);&#125; 方法registerHandlers就是把SimpleUrlHandlerMapping的urlMap的添加到AbstractUrlHandlerMapping的handlerMap中。 看回AbstractUrlHandlerMapping#lookupHandler方法 获取了handler后，应为handler有可能只是一个beanName，所以这里会有从获取bean的逻辑。最后会调用buildPathExposingHandler方法来创建一个HandlerExecutionChain对象。 12345678910protected Object buildPathExposingHandler(Object rawHandler, String bestMatchingPattern, String pathWithinMapping, @Nullable Map&lt;String, String&gt; uriTemplateVariables) &#123; HandlerExecutionChain chain = new HandlerExecutionChain(rawHandler); chain.addInterceptor(new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping)); if (!CollectionUtils.isEmpty(uriTemplateVariables)) &#123; chain.addInterceptor(new UriTemplateVariablesHandlerInterceptor(uriTemplateVariables)); &#125; return chain;&#125; 回到AbstractHandlerMapping.getHandler通过返回的handler构建HandlerExecutionChain现在通过 1Object handler = getHandlerInternal(request); 已经获取到HandlerMethod了，代码继续走，走到 12345678910111213141516171819202122//获取HandlerMethod和过滤器链的包装类HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);//AbstractHandlerMappingprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) &#123; HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ? (HandlerExecutionChain) handler : new HandlerExecutionChain(handler)); String lookupPath = this.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH); for (HandlerInterceptor interceptor : this.adaptedInterceptors) &#123; if (interceptor instanceof MappedInterceptor) &#123; MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor; if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) &#123; chain.addInterceptor(mappedInterceptor.getInterceptor()); &#125; &#125; else &#123; chain.addInterceptor(interceptor); &#125; &#125; return chain;&#125; 这里就是把拦截器和HandlerMethod封装成一个HandlerExecutionChain对象，这个对象的作用就是使得方法调用变成了这样 1Interceptor.preHandle——&gt; HandlerMethod——&gt; Interceptor.postHandle 这段代码在SpringMVC拦截器 回到DispatcherServlet.doDispatch方法获取跟HandlerMethod匹配的HandlerAdapter对象通过 12345678// DispatcherServlet.doDispatch// 这个方法很重要，重点看// Determine handler for the current request.HandlerExecutionChain mappedHandler = getHandler(processedRequest);if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 获取到了HandlerExecutionChain后，接着执行了： 123456789101112131415161718// DispatcherServlet.doDispatch// 获取跟HandlerMethod匹配的HandlerAdapter对象// Determine handler adapter for the current request.HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());// DispatcherServletprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123; // 根据handlerMethod对象，找到合适的HandlerAdapter对象，这里用到了策略模式 if (this.handlerAdapters != null) &#123; for (HandlerAdapter adapter : this.handlerAdapters) &#123; if (adapter.supports(handler)) &#123; return adapter; &#125; &#125; &#125; // 抛出错误 ......&#125; 去获取HandlerAdapter，而HandlerAdapter是用来做参数解析、方法调用的和结果解析的。这里的handlerAdapters就是在SpringMvc的上下文初始化后，调用的 initHandlerAdapters(context);方法初始化的，而这个方法只是去BeanFactory拿对象而已，HandlerAdapter类型的对象的添加是在@EnableWebMvc注解引入的DelegatingWebMvcConfiguration对象通过@Bean添加的。这里添加的对象有 HandlerFunctionAdapter SimpleServletHandlerAdapter SimpleControllerHandlerAdapter RequestMappingHandlerAdapter HandlerFunctionAdapter 这里是RequestMappingHandlerAdapter 前置拦截器执行获取完HandlerAdapter后（这里是RequestMappingHandlerAdapter），就调用过滤器链的前置方法preHandle 1234567891011121314151617181920212223// DispatcherServlet.doDispatch// 前置过滤器，如果为false则直接返回if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;// HandlerExecutionChainboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = 0; i &lt; interceptors.length; i++) &#123; HandlerInterceptor interceptor = interceptors[i]; // 这里的handler是HandlerMethod if (!interceptor.preHandle(request, response, this.handler)) &#123; // 最后都会执行拦截器的afterCompletion方法 triggerAfterCompletion(request, response, null); return false; &#125; this.interceptorIndex = i; &#125; &#125; return true;&#125; 可以看到，只要其中一个前置过滤器返回false了就会执行拦截器的afterCompletion方法，而且调用结束了。 调用到具体Controller的具体方法1234// DispatcherServlet.doDispatch// 调用到Controller具体方法，核心方法调用，重点看看// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 这个是SpringMVC中一个核心的方法，在SpringMVC中Controller调用，现在只关注一个请求的处理过程 后置拦截器调用 注意，这个方法只有在目标方法没有报错时才会执行，所以如果要做一些资源释放的操作，不要在HandlerInterceptor#postHandle中做，而是要在 HandlerInterceptor#afterCompletion中完成 123456789101112131415// DispatcherServlet.doDispatch// 后置拦截器mappedHandler.applyPostHandle(processedRequest, response, mv);void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception &#123; HandlerInterceptor[] interceptors = getInterceptors(); if (!ObjectUtils.isEmpty(interceptors)) &#123; for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123; HandlerInterceptor interceptor = interceptors[i]; interceptor.postHandle(request, response, this.handler, mv); &#125; &#125;&#125; 最后就是结果的处理12// DispatcherServlet.doDispatchprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException) 在这个方法中主要有3个作用 异常处理 视图渲染，响应视图 过滤器afterCompletion方法执行 12345//后置过滤器if (mappedHandler != null) &#123; // Exception (if any) is already handled.. mappedHandler.triggerAfterCompletion(request, response, null);&#125; 总结在Servlet启动时，Spring上文初始化完成，接着触发了DispatcherServlet的init方法来完成SpringMVC上下文的初始化，当SpringMVC上下文初始化时，通过@EnableWebMVC注解@Import的DelegatingWebMvcConfiguration对象@Bean进了HandlerMapping和HandlerAdapth；接着HandlerMapping对象初始化完成后，会触发afterPropertiesSet方法调用，完成MappingRegistry对象的初始化，也就是建立如下映射关系： 123&lt;uri, List&lt;RequestMappingInfo&gt;&gt;&lt;RequestMappingInfo, HandlerMethod&gt;..... 最后，SpringMVC上下文refresh方法完成后，会通过一个ContextRefreshedEvent事件来触发DispatcherServlet的onRefresh的方法来完成对HandlerMapping、HandlerAdapth实现类的收集； 当发起一个请求时，请求会进入到DispatcherServlet（默认情况下），最后通过doDispatch方法来处理这个请求： 根据不同的HandlerMapping对象，调用HandlerMapping的getHandler方法获取HandlerExecutionChain对象 根据Request对象获取uri 从MappingRegister的uriMapping映射中，通过uri获取到RequestMappingInfo列表。（根据注解匹配） 然后匹配最合适的RequestMappingInfo对象后，获取对应的HandlerMethod 根据匹配到的HandlerMethod和定义的拦截器，生成HandlerExecutionChain对象。 更具匹配到的HandlerMethod获取HandlerAdapter 拦截器链的前置方法执行——preHandle 通过HandlerAdapter来调用目标方法（SpringMVC中Controller调用） 拦截器链的后置方法执行——postHandle 如果第4步的处理出错了，这一步是不会执行的，所以一些资源释放的操作要放到拦截器的afterCompletion方法中 错误处理（可能需要） 响应视图（如果需要） 拦截器链的afterCompletion方法执行","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"20-SpringMVC中定义Controller","slug":"spring/5.2.8/20-SpringMVC中定义Controller","date":"2021-11-20T12:00:28.000Z","updated":"2022-03-14T09:04:26.466Z","comments":true,"path":"blog/spring/5.2.8/20-SpringMVC中定义Controller/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/20-SpringMVC%E4%B8%AD%E5%AE%9A%E4%B9%89Controller/","excerpt":"","text":"SpringMVC中定义Controller主流的定义Controller12345678910//@RestController@Controller@ResponseBody@RequestMapping(&quot;/common&quot;)public class CommonController &#123; @RequestMapping(&quot;/index&quot;) public void index() &#123; System.out.println(applicationContext.getBean(&quot;requestSessionBean&quot;)); &#125;&#125; 实现Controller接口1234567891011// 这种模式是需要相应视图的@Component(&quot;/order/index&quot;)public class BeanNameController extends AbstractController &#123; @Override protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(&quot;====/order/index&quot;); ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;ok&quot;); return modelAndView; &#125;&#125; 实现HttpRequestHandler接口123456789101112131415161718192021222324252627282930313233// 不需要相应视图的用这种模式@Componentpublic class AreaController implements HttpRequestHandler, CorsConfigurationSource &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;======AreaController&quot;); PrintWriter writer = response.getWriter(); writer.println(&quot;&lt;h1&gt;==========Jack&lt;/h1&gt;&quot;); writer.flush(); writer.close(); &#125; // 定义跨域配置 @Override public CorsConfiguration getCorsConfiguration(HttpServletRequest request) &#123; return null; &#125;&#125;@Configurationpublic class SimpleUrlConfig &#123; @Bean public SimpleUrlHandlerMapping simpleUrlHandlerMapping() &#123; SimpleUrlHandlerMapping suhm = new SimpleUrlHandlerMapping(); Properties properties = new Properties(); properties.put(&quot;area/index&quot;,&quot;areaController&quot;); suhm.setMappings(properties); return suhm; &#125;&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"19-springMVC启动讲解","slug":"spring/5.2.8/19-springMVC启动讲解","date":"2021-11-20T12:00:27.000Z","updated":"2022-03-14T09:04:26.464Z","comments":true,"path":"blog/spring/5.2.8/19-springMVC启动讲解/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/19-springMVC%E5%90%AF%E5%8A%A8%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"springMVC启动讲解在上一节中讲了Spring是怎么和tomcat集合的和怎么利用servlet规范进行扩展，而且也讲了SpringMVC的入口方法这里讲tomcat在启动时，spring做了什么。这里作下总结。 在spring web中，是tomcat先启动，创建了ServletContext后通过java SPI加载并实例化了org.springframework.web.SpringServletContainerInitializer类型额对象， 接着执行了该对象的onStartup方法，而通过这个对象又引入了实现了WebApplicationInitializer接口的类，接着实例化后遍历执行了该接口的onStartup方法。通过这种方式可以很简单的实现功能的扩展。 在上一节中讲了SpringMVC的入口方法为WebAppInitializer的onStartup方法。跟踪下代码后入口方法在AbstractDispatcherServletInitializer类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //父容器 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;SpringContainer.class&#125;; &#125; //SpringMVC配置子容器 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;MvcContainer.class&#125;; &#125; //获取DispatcherServlet的映射信息 @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; @Override protected Filter[] getServletFilters() &#123; MyFilter myFilter = new MyFilter(); CorsFilter corsFilter = new CorsFilter(); CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceEncoding(true); return new Filter[]&#123;myFilter/*,corsFilter*/, characterEncodingFilter&#125;; &#125; @Override protected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) &#123; return super.registerServletFilter(servletContext, filter); &#125;&#125;// AbstractDispatcherServletInitializer@Overridepublic void onStartup(ServletContext servletContext) throws ServletException &#123; //创建根上下文，创建servletListener super.onStartup(servletContext); //创建mvc上下文，注册DispatcherServlet registerDispatcherServlet(servletContext);&#125; 这个类会被SpringServletContainerInitializer实例化并执行，onStartup方法在AbstractDispatcherServletInitializer中，看该类的onStartup方法： 12345678910111213141516//AbstractDispatcherServletInitializer.onStartup@Overridepublic void onStartup(ServletContext servletContext) throws ServletException &#123; //创建根上下文，创建servletListener super.onStartup(servletContext); //创建mvc上下文，注册DispatcherServlet registerDispatcherServlet(servletContext);&#125;//super.onStartup(servletContext);//AbstractContextLoaderInitializer.onStartup//AbstractContextLoaderInitializer是AbstractDispatcherServletInitializer父类@Overridepublic void onStartup(ServletContext servletContext) throws ServletException &#123; registerContextLoaderListener(servletContext);&#125; 可以看到，onStratup方法有两个核心的方法方法，分别是： AbstractContextLoaderInitializer#registerContextLoaderListener(servletContext) AbstractDispatcherServletInitializer#registerDispatcherServlet(servletContext) 按顺序看，先看方法AbstractContextLoaderInitializer.registerContextLoaderListener(servletContext) registerContextLoaderListener(servletContext)——Spring容器的创建12345678910111213141516171819202122232425//AbstractContextLoaderInitializerprotected void registerContextLoaderListener(ServletContext servletContext) &#123; //创建spring上下文，注册了SpringContainer WebApplicationContext rootAppContext = createRootApplicationContext(); if (rootAppContext != null) &#123; //创建监听器 /* 形如这种配置 * &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;!--&lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;--&gt; &lt;/listener&gt; * * */ ContextLoaderListener listener = new ContextLoaderListener(rootAppContext); listener.setContextInitializers(getRootApplicationContextInitializers()); servletContext.addListener(listener); &#125; else &#123; logger.debug(&quot;No ContextLoaderListener registered, as &quot; + &quot;createRootApplicationContext() did not return an application context&quot;); &#125;&#125; Spring容器的创建可以看到，第一步就是创建一个上下文对象WebApplicationContext，而这个创建WebApplicationContext的方法源码如下： 12345678910111213//AbstractAnnotationConfigDispatcherServletInitializerprotected WebApplicationContext createRootApplicationContext() &#123; //钩子方法，调用子类的方法 Class&lt;?&gt;[] configClasses = getRootConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(configClasses); return context; &#125; else &#123; return null; &#125;&#125; 可以看到，该方法中有一个钩子方法getRootConfigClasses()，这是我们自定义类重写的方法： 通过这个方法，引入配置类，然后创建了AnnotationConfigWebApplicationContext这个上下文对象，接着执行context.register(configClasses)，这个方法只是注册一个类而已，这个类在Spring容器启动时会处理。 注意，这时这个上下对象还没有启动的，也就是还没执行ApplicationContext.refresh()方法 ServletContextListener的创建和添加创建完Spring容器的创建后会，把刚刚创建的AnnotationConfigWebApplicationContext作为入参创建ContextLoaderListener对象。 可以看到该类实现ServletContextListener接口。而且这里也有一个扩展方法getRootApplicationContextInitializers，这个是扩展方法，如果有需要可以重写，作用在后面讲。最后后执行servletContext.addListener(listener)。 1234// AbstractContextLoaderInitializerContextLoaderListener listener = new ContextLoaderListener(rootAppContext);listener.setContextInitializers(getRootApplicationContextInitializers());servletContext.addListener(listener); Spring容器的启动现在看回ContextLoaderListener类，它实现了ServletContextListener接口，在servlet的规范中，在servlet的启动时会调用ServletContextListener接口的contextInitialized方法，Web应用关闭时会调用contextDestroyed方法。所以下现在看ContextLoaderListener的contextInitialized方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// ContextLoaderListenerpublic void contextInitialized(ServletContextEvent event) &#123; //在这里初始化了spring容器 initWebApplicationContext(event.getServletContext());&#125;// ContextLoaderpublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) &#123; ..... long startTime = System.currentTimeMillis(); try &#123; .... if (this.context instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context; if (!cwac.isActive()) &#123; if (cwac.getParent() == null) &#123; ApplicationContext parent = loadParentContext(servletContext); cwac.setParent(parent); &#125; //启动spring上下文 configureAndRefreshWebApplicationContext(cwac, servletContext); &#125; &#125; //把spring的上下文对象设置到servlet上下文对象中去了 servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); ClassLoader ccl = Thread.currentThread().getContextClassLoader(); if (ccl == ContextLoader.class.getClassLoader()) &#123; currentContext = this.context; &#125; else if (ccl != null) &#123; currentContextPerThread.put(ccl, this.context); &#125; .... return this.context; &#125; catch (RuntimeException | Error ex) &#123; ...... &#125;&#125;// ContextLoaderprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123; ..... wac.setServletContext(sc); String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM); if (configLocationParam != null) &#123; wac.setConfigLocation(configLocationParam); &#125; ..... ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(sc, null); &#125; customizeContext(sc, wac); wac.refresh();&#125; 从上边的源码可以看到，它最重要的只完成两件事 执行Spring上下文对象的refresh()方法来启动上下文。 把spring的上下文对象设置到servlet属性中 123String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + &quot;.ROOT&quot;;// context =AnnotationConfigWebApplicationContextservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context); 好了，这个上下文对象只是用来启动了Spring容器（初始化看这），SpringMVC容器还需要看下一个方法。 Spring的上下文启动前提提供了扩展——ApplicationContextInitializer看回启动spring容器启动的方法： 12345678910111213141516171819protected void customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) &#123; // 通过Servlet启动参数引入`ApplicationContextInitializer，这个我们不会用，我们使用最下边的 List&lt;Class&lt;ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt;&gt;&gt; initializerClasses = determineContextInitializerClasses(sc); for (Class&lt;ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt;&gt; initializerClass : initializerClasses) &#123; Class&lt;?&gt; initializerContextClass = GenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class); if (initializerContextClass != null &amp;&amp; !initializerContextClass.isInstance(wac)) &#123; throw new ApplicationContextException(。。。。。。); &#125; this.contextInitializers.add(BeanUtils.instantiateClass(initializerClass)); &#125; AnnotationAwareOrderComparator.sort(this.contextInitializers); for (ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; initializer : this.contextInitializers) &#123; initializer.initialize(wac); &#125;&#125; 最核心的就看最下面的代码 这里的contextInitializers参数就是ApplicationContextInitializer列表。而这个列表的值在Spring中为我们提供了一个扩展方法，在ContextLoaderListener的创建时会调用AbstractContextLoaderInitializer#getRootApplicationContextInitializers()的方法，这个方法默认情况下返回null，但这个方法能被子类重写。 而这个接口的作用其实也很明显，就是对ApplicationContext做一些定制处理，比如这样 12345678910111213141516171819public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; .... @Override protected ApplicationContextInitializer&lt;?&gt;[] getRootApplicationContextInitializers() &#123; return new ApplicationContextInitializer[]&#123;new ApplicationContextInitializerDemo()&#125;; &#125;&#125;public class ApplicationContextInitializerDemo implements ApplicationContextInitializer &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123;// applicationContext.addApplicationListener();// applicationContext.registerShutdownHook();// applicationContext.addProtocolResolver(); &#125;&#125; 但有一点需要注意，这个接口的initialize方法由于是在AbstractApplicationContext.refresh方法执行前执行的，所以该ApplicationContext有些属性还没有初始化，所以在initialize方法中，applicationContext的有些方法不是能调用的。除非在initialize中调用refresh()， 多次调用refresh()是允许的，Spring对这做了保证。 registerDispatcherServlet(servletContext)——SpringMVC容器的创建12345678910111213141516171819202122232425262728293031323334353637// AbstractDispatcherServletInitializerprotected void registerDispatcherServlet(ServletContext servletContext) &#123; String servletName = getServletName(); Assert.hasLength(servletName, &quot;getServletName() must not return null or empty&quot;); //创建mvc的上下文 WebApplicationContext servletAppContext = createServletApplicationContext(); Assert.notNull(servletAppContext, &quot;createServletApplicationContext() must not return null&quot;); //创建DispatcherServlet对象，把springmvc上下文设置到DispatcherServlet中 FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext); Assert.notNull(dispatcherServlet, &quot;createDispatcherServlet(WebApplicationContext) must not return null&quot;); dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers()); //把DispatcherServlet丢到servlet上下文中 ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet); if (registration == null) &#123; throw new IllegalStateException(&quot;Failed to register servlet with name &#x27;&quot; + servletName + &quot;&#x27;. &quot; + &quot;Check if there is another servlet registered under the same name.&quot;); &#125; registration.setLoadOnStartup(1); //钩子方法 registration.addMapping(getServletMappings()); registration.setAsyncSupported(isAsyncSupported()); //定义拦截器 Filter[] filters = getServletFilters(); if (!ObjectUtils.isEmpty(filters)) &#123; for (Filter filter : filters) &#123; registerServletFilter(servletContext, filter); &#125; &#125; customizeRegistration(registration);&#125; SpringMVC的上下文对象创建还是先通过createServletApplicationContext创建了Spring的上下文对象——AnnotationConfigWebApplicationContext. 1234567891011WebApplicationContext servletAppContext = createServletApplicationContext();// AbstractAnnotationConfigDispatcherServletInitializerprotected WebApplicationContext createServletApplicationContext() &#123; AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); Class&lt;?&gt;[] configClasses = getServletConfigClasses(); if (!ObjectUtils.isEmpty(configClasses)) &#123; context.register(configClasses); &#125; return context;&#125; getServletConfigClasses这个方法是钩子方法，是交给子类实现的，这是我们自定义的类实现的： 注意，这里只是创建了AnnotationConfigWebApplicationContext还没有执行refresh方法。 DispatcherServlet类的创建接着执行，去创建了一个DispatcherServlet类，这个类是真正的符合Servlet规范的Servlet类，这也是SpringMVC请求过程中的核心类 123456FrameworkServlet dispatcherServlet = createDispatcherServlet(servletAppContext);// AbstractDispatcherServletInitializerprotected FrameworkServlet createDispatcherServlet(WebApplicationContext servletAppContext) &#123; return new DispatcherServlet(servletAppContext);&#125; 注意，DispatcherServlet包含了SpringMVC的Spring上下文对象。 这里的createDispatcherServlet方法也可以被子类重写，这样可以扩展下DispatcherServlet。 ApplicationContextInitializer类添加到DispatcherServlet中然后添加ApplicationContextInitializer类 1dispatcherServlet.setContextInitializers(getServletApplicationContextInitializers()); 这个方法只是往DispatchServlet的contextInitializers列表添加值。这个列表的是用了Spring的事件监听器的。 把DispatcherServlet添加到servlet上下文中接着把DispatcherServlet丢到servlet上下文中 12345678910String servletName = getServletName();//AbstractDispatcherServletInitializerprotected String getServletName() &#123; return DEFAULT_SERVLET_NAME;&#125;public static final String DEFAULT_SERVLET_NAME = &quot;dispatcher&quot;;ServletRegistration.Dynamic registration = servletContext.addServlet(servletName, dispatcherServlet); 为DispatcherServle指定路径接着为DispatcherServlet添加拦截的url 12// registration = DispatchServletregistration.addMapping(getServletMappings()); 这个getServletMappings()方法是钩子方法，是子类实现的，这是我自定义的类实现的： 也就是后面的所有路径都会进入到该DispatchServlet中。比如这样写后： 路径为&#x2F;xyz&#x2F;**这些路径会走到该DispatchServlet中。 接着设置DispatchServlet是否支持异步12// registration = DispatchServletregistration.setAsyncSupported(isAsyncSupported()); isAsyncSupported方法默认会返回true 1234// AbstractDispatcherServletInitializerprotected boolean isAsyncSupported() &#123; return true;&#125; 添加自定义过滤器最后是添加自定义的过滤器 12345678// AbstractDispatcherServletInitializer// registration = DispatchServletFilter[] filters = getServletFilters();if (!ObjectUtils.isEmpty(filters)) &#123; for (Filter filter : filters) &#123; registerServletFilter(servletContext, filter); &#125;&#125; getServletFilters()也是一个钩子方法，这是自定义类重写的方法： 1234567891011121314151617181920212223242526272829@Overrideprotected Filter[] getServletFilters() &#123; MyFilter myFilter = new MyFilter(); CorsFilter corsFilter = new CorsFilter(); CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceEncoding(true); return new Filter[]&#123;myFilter/*,corsFilter*/, characterEncodingFilter&#125;;&#125;public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;======&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;======doFilter&quot;); //放行 chain.doFilter(request, response); &#125; @Override public void destroy() &#123; &#125;&#125; 在方法的最后，spring为我们提供了一个扩展方法customizeRegistration(ServletRegistration.Dynamic)，这个方法是用来扩展使用的。 最后对DIspatchServlet做定制Spring为我们提供了一个扩展发方法customizeRegistration，它的默认实现为空方法。这个我们可以通过重写该方法做一些定制操作。 12// registration = DispatchServletcustomizeRegistration(registration); SpringMVC上下文启动（SpringMVC上下问启动）DispatcherServlet的初始化已经看了，但上边创建的SpringMVC上下文是在什么时候启动的？ 在Servlet的规范中Servlet的启动都会执行init()方法，而DispatcherServlet就是一个Servlet，而且在创建的时候会传入一个SpringMVC的上下对象。 看DispatcherServlet的init方法前，先看下类图： DispatcherServlet的init方法是在HttpServletBean中的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// HttpServletBeanpublic final void init() throws ServletException &#123; ..... //钩子方法 initServletBean();&#125;// FrameworkServletprotected final void initServletBean() throws ServletException &#123; ..... try &#123; //初始化springmvc上下文 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; ......&#125;// FrameworkServletprotected WebApplicationContext initWebApplicationContext() &#123; //从servlet下午文中获取spring的上下文对象 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; if (cwac.getParent() == null) &#123; //把spring的上下文设置成springmvc上下文的父 cwac.setParent(rootContext); &#125; //启动容器 configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; synchronized (this.onRefreshMonitor) &#123; onRefresh(wac); &#125; &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; 好了，看FrameworkServlet#initWebApplicationContext的第一行代码 123456789WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());....ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;cwac.setParent(rootContext);public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123; return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);&#125; 在第一个Spring上下文创建后，会把该Spring上下文作为值，以WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE为key，添加到Servlet的上下问的属性中。所以在这段代码中，最后会从Servlet的上下中获取第一次创建的Spring上下，然后作为SpringMVC上下文的父上下文。 而SpringMVC上下文启动也很简单，就是调用SpringMVC上下文的refresh()方法而已。看源码： refresh()前有个applyInitializers方法，这个方法和父Spring上下文启动前执行的customizeContext一样，都是用来执行加入到上下文的 ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; ，而这里是使用getServletApplicationContextInitializers方法来初始化的，这也是能被子类重写的。 这里除了refresh()外，还有一行代码需要关注，就是： 12// 添加ApplicationListener接口wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener())); 往上下文中添加了一个事件SourceFilteringListener，注意SourceFilteringListener从设计上看只是一个代理对象，被代理对象为ContextRefreshListener。 123456789101112131415161718192021222324252627// SourceFilteringListenerpublic SourceFilteringListener(Object source, ApplicationListener&lt;?&gt; delegate) &#123; this.source = source; this.delegate = (delegate instanceof GenericApplicationListener ? (GenericApplicationListener) delegate : new GenericApplicationListenerAdapter(delegate));&#125;@Overridepublic void onApplicationEvent(ApplicationEvent event) &#123; if (event.getSource() == this.source) &#123; if (this.delegate == null) &#123; throw new IllegalStateException( &quot;Must specify a delegate object or override the onApplicationEventInternal method&quot;); &#125; this.delegate.onApplicationEvent(event); &#125;&#125;// ContextRefreshListenerprivate class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; //容器启动完成后触发 FrameworkServlet.this.onApplicationEvent(event); &#125;&#125; 事件监听的详情看这里[registerListeners()](.&#x2F;Spring Event事件通知机制) 注意，这个类实现了ApplicationListener，也就是是一个事件监听器，而监听的事件类型为ContextRefreshedEvent，这个事件是在Spring上下文启动完毕后发布的事件： FrameworkServlet.this.onApplicationEvent(event)方法当SpringMVC的上下问refresh方法执行完成后，就会发布一个ContextRefreshedEvent事件，那么此时就会触发该方法。 跟踪代码： 12345678910111213141516171819202122232425// FrameworkServletpublic void onApplicationEvent(ContextRefreshedEvent event) &#123; this.refreshEventReceived = true; synchronized (this.onRefreshMonitor) &#123; onRefresh(event.getApplicationContext()); &#125;&#125;// DispatcherServletprotected void onRefresh(ApplicationContext context) &#123; initStrategies(context);&#125;// DispatcherServletprotected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 这里有很多初始化方法，重点的只有4个： initHandlerMappings(context); HandlerMapping，是做controller的映射的 initHandlerAdapters(context); HandlerAdapter是负责去调用具体的controller以及完成参数解析和返回值参数解析 initViewResolvers(context); ViewResolver是负责视图解析、响应视图的 initRequestToViewNameTranslator(context) 把请求转化为视图名 initHandlerMappings——@EnableWebMvc讲解先看其中一个源码 123456789101112131415161718192021222324252627282930private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we&#x27;ll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); .... &#125;&#125; 代码很简单，就是从上下文中拿实现了HandlerMapping接口的类，但问题是在springMVC使用和扩展中，并没有配置HandlerMapping类，那么这里的这行代码会获取为空吗？ 12Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); 结果是并不为空，而是有值的，那么这些是从哪里引入到Spring的容器中的？ 要使用SpringMVC就需要加上这个注解@EnableWebMvc，看下这个注解的定义： 它Import了DelegatingWebMvcConfiguration，先看类图就： DelegatingWebMvcConfiguration并不负责@Bean，这个工作它的父类WebMvcConfigurationSupport完成的。 不过这里有个问题，就是通过这样帮我们默认配置了，但我们怎么改默认的配置呢？也就是要怎么进行扩展呢？ 看上边红框的代码： 12345678910111213141516171819// WebMvcConfigurationSupportgetInterceptors(conversionService, resourceUrlProvider) protected final Object[] getInterceptors( FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; if (this.interceptors == null) &#123; InterceptorRegistry registry = new InterceptorRegistry(); // 钩子方法 addInterceptors(registry); registry.addInterceptor(new ConversionServiceExposingInterceptor(mvcConversionService)); registry.addInterceptor(new ResourceUrlProviderExposingInterceptor(mvcResourceUrlProvider)); this.interceptors = registry.getInterceptors(); &#125; return this.interceptors.toArray();&#125;protected void addInterceptors(InterceptorRegistry registry) &#123;&#125; 可以看到，在这里提供了一个钩子方法addInterceptors来对配置进行拓展 在SpringMVC中引入的的是DelegatingWebMvcConfiguration，而它的父类就是WebMvcConfigurationSupport看源码： 12345678910111213141516171819202122232425@Configuration(proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125; ...... @Override protected void addInterceptors(InterceptorRegistry registry) &#123; this.configurers.addInterceptors(registry); &#125; @Override protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; this.configurers.configureMessageConverters(converters); &#125; ......&#125; 可以看到，在类重写了这个钩子方法，也就是说在@Bean时调用的钩子方法就是这个类中的方法。而这个addInterceptors方法很简单，只有一行代码，但却有很强的扩展性！在DelegatingWebMvcConfiguration中，通过注入实现了WebMvcConfigurer接口的类来实现功能的扩展，也就是说只要在项目中实现WebMvcConfigurer这个接口重写对应方法就能对SpringMVC中一些对应的配置进行修改了，下面看下我自定义的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Configuration@EnableWebMvcpublic class AppConfig implements WebMvcConfigurer &#123; @Autowired private UserInterceptor userInterceptor; @Autowired private ApplicationContext applicationContext; @Bean public FreeMarkerConfigurer freeMarkerConfigurer() &#123; FreeMarkerConfigurer freeMarkerConfigurer = new FreeMarkerConfigurer(); freeMarkerConfigurer.setTemplateLoaderPath(&quot;classpath:/ftl/&quot;); freeMarkerConfigurer.setDefaultEncoding(&quot;UTF-8&quot;); freeMarkerConfigurer.setConfigLocation(applicationContext.getResource(&quot;classpath:ftl/ftl.properties&quot;)); return freeMarkerConfigurer; &#125; @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; registry.enableContentNegotiation(new MappingJackson2JsonView()); registry.freeMarker(); registry.jsp(&quot;/jsp/&quot;, &quot;.jsp&quot;); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/view/ok&quot;).setViewName(&quot;ok&quot;); registry.addViewController(&quot;/view/index&quot;).setViewName(&quot;index&quot;); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;// configurer.enable(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(userInterceptor).addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;/user/query/**&quot;); registry.addInterceptor(new UserInterceptor1()).addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;&quot;); &#125; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;// registry.addResourceHandler(&quot;/image/**&quot;)// .addResourceLocations(&quot;classpath:/img/&quot;); &#125;/* @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/user/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;PATCH&quot;) .maxAge(3600); &#125;*/ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;// converters.add(new FastJsonHttpMessageConverter()); &#125; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); //设置日期格式 ObjectMapper objectMapper = new ObjectMapper(); SimpleDateFormat smt = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); objectMapper.setDateFormat(smt); mappingJackson2HttpMessageConverter.setObjectMapper(objectMapper); //设置中文编码格式 List&lt;MediaType&gt; list = new ArrayList&lt;MediaType&gt;(); list.add(MediaType.APPLICATION_JSON); mappingJackson2HttpMessageConverter.setSupportedMediaTypes(list); converters.add(mappingJackson2HttpMessageConverter); &#125;&#125; 看回WebMvcConfigurationSupport类 在这个类中@Bean了这类 RequestMappingHandlerMapping UrlPathHelper的一个实例 SimpleUrlHandlerMapping BeanNameUrlHandlerMapping RouterFunctionMapping ResourceUrlProvider DefaultServletHandlerConfigurer RequestMappingHandlerAdapter HandlerFunctionAdapter HttpRequestHandlerAdapter SimpleControllerHandlerAdapter HandlerExceptionResolver 另外两个方法另外两个都一样，这里贴下源码： 这3个init方法都是收集对应的类，然后把收集到的类赋值给DispatcherServlet中的对应的属性。而这些对象可以是通过@Componetn标记的，或者使用@EnabelWebMvc默认引入的。 现在已经知道这些类是由@EnabelWebMvc 注解中 @Import的类所@Bean的。而这个类是DelegatingWebMvcConfiguration。好了SpringMVC的启动就完了，下面将看请求是怎么到SpringMVC的Controller中的","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"18-springMVC使用和扩展","slug":"spring/5.2.8/18-springMVC使用和扩展","date":"2021-11-20T12:00:26.000Z","updated":"2022-03-14T09:04:26.406Z","comments":true,"path":"blog/spring/5.2.8/18-springMVC使用和扩展/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/18-springMVC%E4%BD%BF%E7%94%A8%E5%92%8C%E6%89%A9%E5%B1%95/","excerpt":"","text":"springMVC使用传统XML配置：spring-dispatcher.xml spring中的配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Configuration@EnableWebMvcpublic class AppConfig implements WebMvcConfigurer &#123; @Autowired private UserInterceptor userInterceptor; @Autowired private ApplicationContext applicationContext; @Bean public FreeMarkerConfigurer freeMarkerConfigurer() &#123; FreeMarkerConfigurer freeMarkerConfigurer = new FreeMarkerConfigurer(); freeMarkerConfigurer.setTemplateLoaderPath(&quot;classpath:/ftl/&quot;); freeMarkerConfigurer.setDefaultEncoding(&quot;UTF-8&quot;); freeMarkerConfigurer.setConfigLocation(applicationContext.getResource(&quot;classpath:ftl/ftl.properties&quot;)); return freeMarkerConfigurer; &#125; @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; registry.enableContentNegotiation(new MappingJackson2JsonView()); registry.freeMarker(); registry.jsp(&quot;/jsp/&quot;, &quot;.jsp&quot;); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/view/ok&quot;).setViewName(&quot;ok&quot;); registry.addViewController(&quot;/view/index&quot;).setViewName(&quot;index&quot;); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;// configurer.enable(); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(userInterceptor).addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;/user/query/**&quot;); registry.addInterceptor(new UserInterceptor1()).addPathPatterns(&quot;/user/**&quot;).excludePathPatterns(&quot;&quot;); &#125; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;// registry.addResourceHandler(&quot;/image/**&quot;)// .addResourceLocations(&quot;classpath:/img/&quot;); &#125;/* @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/user/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;PATCH&quot;) .maxAge(3600); &#125;*/ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;// converters.add(new FastJsonHttpMessageConverter()); &#125; @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); //设置日期格式 ObjectMapper objectMapper = new ObjectMapper(); SimpleDateFormat smt = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); objectMapper.setDateFormat(smt); mappingJackson2HttpMessageConverter.setObjectMapper(objectMapper); //设置中文编码格式 List&lt;MediaType&gt; list = new ArrayList&lt;MediaType&gt;(); list.add(MediaType.APPLICATION_JSON); mappingJackson2HttpMessageConverter.setSupportedMediaTypes(list); converters.add(mappingJackson2HttpMessageConverter); &#125;&#125; spring与tomcat结合123456789101112131415161718192021222324252627282930313233343536373839public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; //父容器 @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; System.out.println(&quot;-------调用了getRootConfigClasses---------&quot;); return new Class&lt;?&gt;[]&#123;SpringContainer.class&#125;; &#125; //SpringMVC配置子容器 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; System.out.println(&quot;-------调用了getServletConfigClasses---------&quot;); return new Class&lt;?&gt;[]&#123;MvcContainer.class&#125;; &#125; //获取DispatcherServlet的映射信息 @Override protected String[] getServletMappings() &#123; System.out.println(&quot;-------调用了getServletMappings---------&quot;); return new String[]&#123;&quot;/&quot;&#125;; &#125; @Override protected Filter[] getServletFilters() &#123; System.out.println(&quot;-------调用了getServletFilters---------&quot;); MyFilter myFilter = new MyFilter(); CorsFilter corsFilter = new CorsFilter(); CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter(); characterEncodingFilter.setEncoding(&quot;UTF-8&quot;); characterEncodingFilter.setForceEncoding(true); return new Filter[]&#123;myFilter/*,corsFilter*/, characterEncodingFilter&#125;; &#125; @Override protected FilterRegistration.Dynamic registerServletFilter(ServletContext servletContext, Filter filter) &#123; return super.registerServletFilter(servletContext, filter); &#125;&#125; 启动 下面的代码不是必须的，可以把项目打成war包后，放到tomcat中运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SpringApplication &#123; public static void main(String[] args) &#123; run(SpringApplication.class, args); &#125; public static void run(Object source, String... args) &#123;// return run(new Object[] &#123; source &#125;, args); try &#123; // 创建Tomcat容器 Tomcat tomcatServer = new Tomcat(); // 端口号设置 tomcatServer.setPort(9090); // 读取项目路径 加载静态资源// StandardContext ctx = (StandardContext) tomcatServer.addWebapp(&quot;/&quot;, new File(&quot;spring-source/src/main&quot;).getAbsolutePath()); String basePath = System.getProperty(&quot;user.dir&quot;) + File.separator; tomcatServer.getHost().setAppBase(basePath);//// Connector connector = tomcatServer.getConnector();// connector.setURIEncoding(&quot;UTF-8&quot;); //改变文件读取路径，从resources目录下去取文件// StandardContext ctx = (StandardContext) tomcatServer.addWebapp(&quot;/&quot;, basePath + &quot;src&quot; + File.separator + &quot;main&quot; + File.separator + &quot;resources&quot;); StandardContext ctx = (StandardContext)tomcatServer.addWebapp(&quot;/&quot;, basePath + &quot;src&quot; + File.separator + &quot;main&quot; + File.separator + &quot;resources&quot;);// tomcatServer.addWebapp(&quot;/&quot;, basePath + &quot;src&quot; + File.separator + &quot;main&quot; + File.separator + &quot;resources&quot;);// ctx.addServletMappingDecoded(&quot;*.jpg&quot;, &quot;default&quot;); // 禁止重新载入 ctx.setReloadable(false); // class文件读取地址 File additionWebInfClasses = new File(&quot;target/classes&quot;); // 创建WebRoot WebResourceRoot resources = new StandardRoot(ctx); // tomcat内部读取Class执行 resources.addPreResources( new DirResourceSet(resources, &quot;/WEB-INF/classes&quot;, additionWebInfClasses.getAbsolutePath(), &quot;/&quot;)); ctx.setResources(resources); tomcatServer.start(); // 异步等待请求执行 tomcatServer.getServer().await(); &#125; catch (LifecycleException e) &#123; e.printStackTrace(); &#125; catch (ServletException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在启动的时候打印了如下内容，也就意味着WebAppInitializer里面的方法被执行了！ 解析上边的WebAppInitializer类没有使用任何注解，也就是活，从类的定义上看，该类的对象创建是不会交给Spring管理的。但是在启动过时候，却调用了这个类的方法。所以到底怎么样创建WebAppInitializer对象的了？下面分析。 上面这种启动方式之所以是可行的，是因为tomcat提供了一个扩展，而这个扩展通过java的SPI，给使用者进行扩展。在spring-web模块中定义这样一个文件： tomcat在启动的时候会调用java的API实例化这个文件上定义的类，看下这个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * Servlet 3.0 &#123;@link ServletContainerInitializer&#125; designed to support code-based * configuration of the servlet container using Spring&#x27;s &#123;@link WebApplicationInitializer&#125; * SPI as opposed to (or possibly in combination with) the traditional * &#123;@code web.xml&#125;-based approach. * * &lt;h2&gt;Mechanism of Operation&lt;/h2&gt; * This class will be loaded and instantiated and have its &#123;@link #onStartup&#125; * method invoked by any Servlet 3.0-compliant container during container startup assuming * that the &#123;@code spring-web&#125; module JAR is present on the classpath. This occurs through * the JAR Services API &#123;@link ServiceLoader#load(Class)&#125; method detecting the * &#123;@code spring-web&#125; module&#x27;s &#123;@code META-INF/services/javax.servlet.ServletContainerInitializer&#125; * service provider configuration file. See the * &lt;a href=&quot;https://download.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider&quot;&gt; * JAR Services API documentation&lt;/a&gt; as well as section &lt;em&gt;8.2.4&lt;/em&gt; of the Servlet 3.0 * Final Draft specification for complete details. * * &lt;h3&gt;In combination with &#123;@code web.xml&#125;&lt;/h3&gt; * A web application can choose to limit the amount of classpath scanning the Servlet * container does at startup either through the &#123;@code metadata-complete&#125; attribute in * &#123;@code web.xml&#125;, which controls scanning for Servlet annotations or through an * &#123;@code &lt;absolute-ordering&gt;&#125; element also in &#123;@code web.xml&#125;, which controls which * web fragments (i.e. jars) are allowed to perform a &#123;@code ServletContainerInitializer&#125; * scan. When using this feature, the &#123;@link SpringServletContainerInitializer&#125; * can be enabled by adding &quot;spring_web&quot; to the list of named web fragments in * &#123;@code web.xml&#125; as follows: * * &lt;pre class=&quot;code&quot;&gt; * &amp;lt;absolute-ordering&amp;gt; * &amp;lt;name&gt;some_web_fragment&amp;lt;/name&amp;gt; * &amp;lt;name&gt;spring_web&amp;lt;/name&amp;gt; * &amp;lt;/absolute-ordering&amp;gt; * &lt;/pre&gt; * * &lt;h2&gt;Relationship to Spring&#x27;s &#123;@code WebApplicationInitializer&#125;&lt;/h2&gt; * Spring&#x27;s &#123;@code WebApplicationInitializer&#125; SPI consists of just one method: * &#123;@link WebApplicationInitializer#onStartup(ServletContext)&#125;. The signature is intentionally * quite similar to &#123;@link ServletContainerInitializer#onStartup(Set, ServletContext)&#125;: * simply put, &#123;@code SpringServletContainerInitializer&#125; is responsible for instantiating * and delegating the &#123;@code ServletContext&#125; to any user-defined * &#123;@code WebApplicationInitializer&#125; implementations. It is then the responsibility of * each &#123;@code WebApplicationInitializer&#125; to do the actual work of initializing the * &#123;@code ServletContext&#125;. The exact process of delegation is described in detail in the * &#123;@link #onStartup onStartup&#125; documentation below. * * &lt;h2&gt;General Notes&lt;/h2&gt; * In general, this class should be viewed as &lt;em&gt;supporting infrastructure&lt;/em&gt; for * the more important and user-facing &#123;@code WebApplicationInitializer&#125; SPI. Taking * advantage of this container initializer is also completely &lt;em&gt;optional&lt;/em&gt;: while * it is true that this initializer will be loaded and invoked under all Servlet 3.0+ * runtimes, it remains the user&#x27;s choice whether to make any * &#123;@code WebApplicationInitializer&#125; implementations available on the classpath. If no * &#123;@code WebApplicationInitializer&#125; types are detected, this container initializer will * have no effect. * * &lt;p&gt;Note that use of this container initializer and of &#123;@code WebApplicationInitializer&#125; * is not in any way &quot;tied&quot; to Spring MVC other than the fact that the types are shipped * in the &#123;@code spring-web&#125; module JAR. Rather, they can be considered general-purpose * in their ability to facilitate convenient code-based configuration of the * &#123;@code ServletContext&#125;. In other words, any servlet, listener, or filter may be * registered within a &#123;@code WebApplicationInitializer&#125;, not just Spring MVC-specific * components. * * &lt;p&gt;This class is neither designed for extension nor intended to be extended. * It should be considered an internal type, with &#123;@code WebApplicationInitializer&#125; * being the public-facing SPI. * * &lt;h2&gt;See Also&lt;/h2&gt; * See &#123;@link WebApplicationInitializer&#125; Javadoc for examples and detailed usage * recommendations.&lt;p&gt; * * @author Chris Beams * @author Juergen Hoeller * @author Rossen Stoyanchev * @since 3.1 * @see #onStartup(Set, ServletContext) * @see WebApplicationInitializer */@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; /** * Delegate the &#123;@code ServletContext&#125; to any &#123;@link WebApplicationInitializer&#125; * implementations present on the application classpath. * &lt;p&gt;Because this class declares @&#123;@code HandlesTypes(WebApplicationInitializer.class)&#125;, * Servlet 3.0+ containers will automatically scan the classpath for implementations * of Spring&#x27;s &#123;@code WebApplicationInitializer&#125; interface and provide the set of all * such types to the &#123;@code webAppInitializerClasses&#125; parameter of this method. * &lt;p&gt;If no &#123;@code WebApplicationInitializer&#125; implementations are found on the classpath, * this method is effectively a no-op. An INFO-level log message will be issued notifying * the user that the &#123;@code ServletContainerInitializer&#125; has indeed been invoked but that * no &#123;@code WebApplicationInitializer&#125; implementations were found. * &lt;p&gt;Assuming that one or more &#123;@code WebApplicationInitializer&#125; types are detected, * they will be instantiated (and &lt;em&gt;sorted&lt;/em&gt; if the @&#123;@link * org.springframework.core.annotation.Order @Order&#125; annotation is present or * the &#123;@link org.springframework.core.Ordered Ordered&#125; interface has been * implemented). Then the &#123;@link WebApplicationInitializer#onStartup(ServletContext)&#125; * method will be invoked on each instance, delegating the &#123;@code ServletContext&#125; such * that each instance may register and configure servlets such as Spring&#x27;s * &#123;@code DispatcherServlet&#125;, listeners such as Spring&#x27;s &#123;@code ContextLoaderListener&#125;, * or any other Servlet API componentry such as filters. * @param webAppInitializerClasses all implementations of * &#123;@link WebApplicationInitializer&#125; found on the application classpath * @param servletContext the servlet context to be initialized * @see WebApplicationInitializer#onStartup(ServletContext) * @see AnnotationAwareOrderComparator */ @Override public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) ReflectionUtils.accessibleConstructor(waiClass).newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;); return; &#125; servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;); AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 从上边的类中的注释可以了解到这个类的作用 ServletContainerInitializer接口是Servlet3.0提出的一个接口，spring通过这个接口和使用SPI来实现servlet容器基于代码的扩展。而该接口的方法onStartup方法从该注解可以了解到调用的时机。 Servlet容器在启动阶段会调用java的ServiceProvider（java SPI）去加载项目所有jar包中的 1META-INF/services/javax.servlet.ServletContainerInitializer 配置文件，然后去加载并实例化该配置文件中指定的类。然后在调用这些对象的onStartup方法。 而且在SpringMVC提供的这个配置文件锁定义的类上有这一个注解@HandlesTypes。这也是Servlet3.0的注解。看下该注解的作用 Servlet容器发现有@HandlesTypes注解后，会扫描应用中实现了WebApplicationInitializer接口的类，把这些类的Class对象封装成一个集合后，把该集合作为onStartup方法的入参。 所以这也就是解析了WebAppInitializer对象为什么会被实例化了，因为该类实现了WebApplicationInitializer接口 看SpringServletContainerInitializer的onStartup，逻辑很简单就是遍历项目中实现WebApplicationInitializer接口的类的class对象，实例化这些对象后，然后遍历执行这些对象的onStartup方法。所以现在可以确定了，SpringMVC的入口方法为WebAppInitializer的onStartup方法。跟踪下代码后入口方法在AbstractDispatcherServletInitializer类中 12345678// AbstractDispatcherServletInitializer@Overridepublic void onStartup(ServletContext servletContext) throws ServletException &#123; //创建根上下文，创建servletListener super.onStartup(servletContext); //创建mvc上下文，注册DispatcherServlet registerDispatcherServlet(servletContext);&#125; 在spring中使用Servlet规范进行扩展项目中提供这个文件： 实现类为： 12345678910111213141516171819202122232425public interface LoadServlet &#123; void loadOnstarp(ServletContext servletContext);&#125;@HandlesTypes(LoadServlet.class)public class MyServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123; Iterator&lt;Class&lt;?&gt;&gt; iterator; if (set != null) &#123; iterator = set.iterator(); while (iterator.hasNext()) &#123; Class&lt;?&gt; clazz = iterator.next(); if (!clazz.isInterface() &amp;&amp; !Modifier.isAbstract(clazz.getModifiers()) &amp;&amp; LoadServlet.class.isAssignableFrom(clazz)) &#123; try &#123; ((LoadServlet) clazz.newInstance()).loadOnstarp(servletContext); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 意思就是加载实现了LoadServlet这个接口的类，然后把这些类实例化后执行方法。 这里我提供一个实现了LoadServlet的类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LoadServletImpl implements LoadServlet &#123; @Override public void loadOnstarp(ServletContext servletContext) &#123; ServletRegistration.Dynamic initServlet = servletContext.addServlet(&quot;initServlet&quot;, InitServlet.class); initServlet.setLoadOnStartup(1); initServlet.addMapping(&quot;/init&quot;); ServletRegistration aDefault = servletContext.getServletRegistration(&quot;default&quot;); aDefault.addMapping(&quot;*.css&quot;,&quot;*.gif&quot;,&quot;*.jpg&quot;,&quot;*.js&quot;,&quot;*.JPG&quot;);// ServletRegistration.Dynamic defaults = servletContext.addServlet(&quot;default&quot;, DefaultServlet.class);// defaults.setLoadOnStartup(1);// defaults.addMapping(&quot;*.css&quot;,&quot;*.gif&quot;,&quot;*.jpg&quot;,&quot;*.js&quot;,&quot;*.JPG&quot;); &#125;&#125;public class InitServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;=====doget===&quot;); PrintWriter writer = resp.getWriter(); writer.print(&quot;&lt;h1&gt;Jack&lt;/h1&gt;&quot;); RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/jsp/ok.jsp&quot;); requestDispatcher.forward(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; super.init(config); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.service(req, resp); &#125;&#125; tomcat启动后，会加入一个名为initServlet的Servlet。 tomcat启动时答应如下内容","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"17-Spring异步注解","slug":"spring/5.2.8/17-Spring异步注解","date":"2021-11-20T12:00:25.000Z","updated":"2022-03-14T09:04:26.381Z","comments":true,"path":"blog/spring/5.2.8/17-Spring异步注解/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/17-Spring%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Spring异步注解@Async12345678910111213141516171819202122232425@Component//@EnableScheduling@EnableAsync(proxyTargetClass = true)public class EnableAsyncBean &#123; private int corePoolSize = 10; private int maxPoolSize = 200; private int queueCapacity = 10; private String ThreadNamePrefix = &quot;JackExecutor-&quot;; @Bean public Executor executor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setQueueCapacity(queueCapacity); executor.setThreadNamePrefix(ThreadNamePrefix); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; 然后加上这个注解@Async就好了。看@EnableAsync的定义 123456789101112131415161718@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(AsyncConfigurationSelector.class)public @interface EnableAsync &#123; Class&lt;? extends Annotation&gt; annotation() default Annotation.class; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE;&#125; 作用就是要引入AsyncConfigurationSelector.class这个类。 12345678910public String[] selectImports(AdviceMode adviceMode) &#123; switch (adviceMode) &#123; case PROXY: return new String[] &#123;ProxyAsyncConfiguration.class.getName()&#125;; case ASPECTJ: return new String[] &#123;ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME&#125;; default: return null; &#125;&#125; 看ProxyAsyncConfiguration 1234567891011121314151617181920@Configuration@Role(BeanDefinition.ROLE_INFRASTRUCTURE)public class ProxyAsyncConfiguration extends AbstractAsyncConfiguration &#123; @Bean(name = TaskManagementConfigUtils.ASYNC_ANNOTATION_PROCESSOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public AsyncAnnotationBeanPostProcessor asyncAdvisor() &#123; Assert.notNull(this.enableAsync, &quot;@EnableAsync annotation metadata was not injected&quot;); AsyncAnnotationBeanPostProcessor bpp = new AsyncAnnotationBeanPostProcessor(); bpp.configure(this.executor, this.exceptionHandler); Class&lt;? extends Annotation&gt; customAsyncAnnotation = this.enableAsync.getClass(&quot;annotation&quot;); if (customAsyncAnnotation != AnnotationUtils.getDefaultValue(EnableAsync.class, &quot;annotation&quot;)) &#123; bpp.setAsyncAnnotationType(customAsyncAnnotation); &#125; bpp.setProxyTargetClass(this.enableAsync.getBoolean(&quot;proxyTargetClass&quot;)); bpp.setOrder(this.enableAsync.&lt;Integer&gt;getNumber(&quot;order&quot;)); return bpp; &#125;&#125; 这里就是为了要实例化AsyncAnnotationBeanPostProcessor这个对象，看类图 我们都知道，既然异步了，那也要使用代理类来实现的，而代理类是在类初始化的最后里会调用BeanPostProcessor#postProcessAfterInitialization这个方法的，那我们看这个类的postProcessAfterInitialization方法。 123456789101112131415161718192021222324252627282930313233public Object postProcessAfterInitialization(Object bean, String beanName) &#123; if (this.advisor == null || bean instanceof AopInfrastructureBean) &#123; // Ignore AOP infrastructure such as scoped proxies. return bean; &#125; if (bean instanceof Advised) &#123; Advised advised = (Advised) bean; if (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123; // Add our local Advisor to the existing proxy&#x27;s Advisor chain... if (this.beforeExistingAdvisors) &#123; advised.addAdvisor(0, this.advisor); &#125; else &#123; advised.addAdvisor(this.advisor); &#125; return bean; &#125; &#125; if (isEligible(bean, beanName)) &#123; ProxyFactory proxyFactory = prepareProxyFactory(bean, beanName); if (!proxyFactory.isProxyTargetClass()) &#123; evaluateProxyInterfaces(bean.getClass(), proxyFactory); &#125; proxyFactory.addAdvisor(this.advisor); customizeProxyFactory(proxyFactory); return proxyFactory.getProxy(getProxyClassLoader()); &#125; // No proxy needed. return bean;&#125; 上边代码中的isEligible方法最后会调用这块代码 12345678910111213public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; if (advisor instanceof IntroductionAdvisor) &#123; return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); &#125; else if (advisor instanceof PointcutAdvisor) &#123; PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); &#125; else &#123; // It doesn&#x27;t have a pointcut so we assume it applies. return true; &#125;&#125; 可以看到，就是通过切面来判断否匹配。而且，创建代理类的时候加入了一个切面。而这个切面时对象的一个属性，但是这个异步的切面是在哪里放到Spring 容器中的？可以看到，这里面有个advisor属性，看名字就知道，它是一个切面，但问题是它是怎么初始化的。我们看会哪个类图，发现它还实现了一个接口BeanFactoryAware，我们都知道，Spring Bean在IOC和DI完成后就会执行一些接口的方法，而这个接口就是在这时调用的，也就是在创建代理对象之前调用的。看这个接口的setBeanFactory方法 1234567891011@Overridepublic void setBeanFactory(BeanFactory beanFactory) &#123; super.setBeanFactory(beanFactory); AsyncAnnotationAdvisor advisor = new AsyncAnnotationAdvisor(this.executor, this.exceptionHandler); if (this.asyncAnnotationType != null) &#123; advisor.setAsyncAnnotationType(this.asyncAnnotationType); &#125; advisor.setBeanFactory(beanFactory); this.advisor = advisor;&#125; 可以看到，在这里创建了一个AsyncAnnotationAdvisor的切面，看下它的构造方法。 123456789101112131415public AsyncAnnotationAdvisor( @Nullable Supplier&lt;Executor&gt; executor, @Nullable Supplier&lt;AsyncUncaughtExceptionHandler&gt; exceptionHandler) &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; asyncAnnotationTypes = new LinkedHashSet&lt;&gt;(2); asyncAnnotationTypes.add(Async.class); try &#123; asyncAnnotationTypes.add((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.ejb.Asynchronous&quot;, AsyncAnnotationAdvisor.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; // If EJB 3.1 API not present, simply ignore. &#125; this.advice = buildAdvice(executor, exceptionHandler); this.pointcut = buildPointcut(asyncAnnotationTypes);&#125; Advice是AnnotationAsyncExecutionInterceptor，而pointcut比较特殊ComposablePointcut里面有两个 ComposablePointcut虽然看起来和之前的不同的，但是这个pointcut无非就是做两件事，进行类的匹配和方法匹配，匹配的依据就是@Async 这个注解。这里就不看了。重点看Advice吧 AnnotationAsyncExecutionInterceptor1234567891011121314151617181920212223242526272829public Object invoke(final MethodInvocation invocation) throws Throwable &#123; Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); Method specificMethod = ClassUtils.getMostSpecificMethod(invocation.getMethod(), targetClass); final Method userDeclaredMethod = BridgeMethodResolver.findBridgedMethod(specificMethod); AsyncTaskExecutor executor = determineAsyncExecutor(userDeclaredMethod); if (executor == null) &#123; throw new IllegalStateException( &quot;No executor specified and no default executor set on AsyncExecutionInterceptor either&quot;); &#125; Callable&lt;Object&gt; task = () -&gt; &#123; try &#123; Object result = invocation.proceed(); if (result instanceof Future) &#123; return ((Future&lt;?&gt;) result).get(); &#125; &#125; catch (ExecutionException ex) &#123; handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments()); &#125; catch (Throwable ex) &#123; handleError(ex, userDeclaredMethod, invocation.getArguments()); &#125; return null; &#125;; return doSubmit(task, executor, invocation.getMethod().getReturnType());&#125; 先看是怎么获取TaskExecutor的，获取的方法为determineAsyncExecutor() 1234567891011121314151617181920protected AsyncTaskExecutor determineAsyncExecutor(Method method) &#123; AsyncTaskExecutor executor = this.executors.get(method); if (executor == null) &#123; Executor targetExecutor; String qualifier = getExecutorQualifier(method); if (StringUtils.hasLength(qualifier)) &#123; targetExecutor = findQualifiedExecutor(this.beanFactory, qualifier); &#125; else &#123; targetExecutor = this.defaultExecutor.get(); &#125; if (targetExecutor == null) &#123; return null; &#125; executor = (targetExecutor instanceof AsyncListenableTaskExecutor ? (AsyncListenableTaskExecutor) targetExecutor : new TaskExecutorAdapter(targetExecutor)); this.executors.put(method, executor); &#125; return executor;&#125; 代码的意思就是去获取执行器的（可以理解为线程池）。 先通过getExecutorQualifier方法获取，该方法AnnotationAsyncExecutionInterceptor重写了，看源码 12345678910//AnnotationAsyncExecutionInterceptorprotected String getExecutorQualifier(Method method) &#123; // Maintainer&#x27;s note: changes made here should also be made in // AnnotationAsyncExecutionAspect#getExecutorQualifier Async async = AnnotatedElementUtils.findMergedAnnotation(method, Async.class); if (async == null) &#123; async = AnnotatedElementUtils.findMergedAnnotation(method.getDeclaringClass(), Async.class); &#125; return (async != null ? async.value() : null);&#125; 可以看到，就是通返回注解的value值 通过@Async注解的value从beanFactory中获取bean 如果第的value为空或获取不到对象，那就通过defaultExecutor去获取，该defaultExecutor类型为SingletonSupplier，在初始化时创建的 1234public AsyncExecutionAspectSupport(@Nullable Executor defaultExecutor) &#123; this.defaultExecutor = new SingletonSupplier&lt;&gt;(defaultExecutor, () -&gt; getDefaultExecutor(this.beanFactory)); this.exceptionHandler = SingletonSupplier.of(SimpleAsyncUncaughtExceptionHandler::new);&#125; 这里先说下SingletonSupplier的get方法逻辑为先通过defaultExecutor去获取，如果没有在通过() -&gt; getDefaultExecutor(this.beanFactory)获取。而第二步的获取其实就是在beanFactory中获取实现了Executor接口的bean。 这里的defaultExecutor是可以在项目中指定的，比如在代码中实现了接口AsyncConfigurer来执行的 123456789101112@Componentpublic class AsyncConfigurerDemo implements AsyncConfigurer &#123; // 指定@Async 注解使用的TaskExecutor public Executor getAsyncExecutor() &#123; return null; &#125; // 设置错误处理器 public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return null; &#125;&#125; 这样写后，在使用@EnableCaching注解后，就会在ProxyAsyncConfiguration中的 123456789101112@Autowired(required = false)void setConfigurers(Collection&lt;AsyncConfigurer&gt; configurers) &#123; if (CollectionUtils.isEmpty(configurers)) &#123; return; &#125; if (configurers.size() &gt; 1) &#123; throw new IllegalStateException(&quot;Only one AsyncConfigurer may exist&quot;); &#125; AsyncConfigurer configurer = configurers.iterator().next(); this.executor = configurer::getAsyncExecutor; this.exceptionHandler = configurer::getAsyncUncaughtExceptionHandler;&#125; 这段代码设置对应的值，而这些值会在创建Advisor的时候传入。 获取到Executor后，就是执行逻辑代码了，而这里时进行火炬传递 invoke代码中接着会对执行方法包装成一个Callable对象。 12345678910111213141516Callable&lt;Object&gt; task = () -&gt; &#123; try &#123; // 火炬传递 Object result = invocation.proceed(); if (result instanceof Future) &#123; return ((Future&lt;?&gt;) result).get(); &#125; &#125; catch (ExecutionException ex) &#123; handleError(ex.getCause(), userDeclaredMethod, invocation.getArguments()); &#125; catch (Throwable ex) &#123; handleError(ex, userDeclaredMethod, invocation.getArguments()); &#125; return null;&#125;; 接着就执行了doSubmit，看代码： 1234567891011121314151617181920212223protected Object doSubmit(Callable&lt;Object&gt; task, AsyncTaskExecutor executor, Class&lt;?&gt; returnType) &#123; if (CompletableFuture.class.isAssignableFrom(returnType)) &#123; return CompletableFuture.supplyAsync(() -&gt; &#123; try &#123; return task.call(); &#125; catch (Throwable ex) &#123; throw new CompletionException(ex); &#125; &#125;, executor); &#125; else if (ListenableFuture.class.isAssignableFrom(returnType)) &#123; return ((AsyncListenableTaskExecutor) executor).submitListenable(task); &#125; else if (Future.class.isAssignableFrom(returnType)) &#123; return executor.submit(task); &#125; else &#123; //没返回值就走这里 executor.submit(task); return null; &#125;&#125; 这里就是根据放回值类型走不同的逻辑。 这个好像是响应式编程的，其他的都很好理解。 和@Transactional配合使用的一些问题 正常来说这样写是没问题的，不过这样会设计到一个执行顺序的问题。也就是如果先执行了 但如果在类中出现循环依赖了，那么这样写后启动会报错，比如这样 分析下这个原因 TransationServiceImpl在实例话完成后会在三级缓存中放入一个ObjectFactory。然后在依赖注入时，由于依赖了自己，所以会调用beanFactory(TransationServiceImpl.class)，这个调用会从三级缓存中拿到ObjectFactory后，接着会执行了这个方法 在这里面，在事务的启动类InfrastructureAdvisorAutoProxyCreator中重写了这个方法 所以在这里会生成一个代理对象。最后把这个代理对象升级为二级缓存，最后赋值给了 这个属性。TransationServiceImpl类的依赖注入完成后，他的初始化流程继续，走到 这里后他又会在InfrastructureAdvisorAutoProxyCreator这个类的postProcessAfterInitialization判断下是否有代理对象 因为依赖注入的时候就生成一个了 所以它不会再生成了，直接返回。但是这时又有个@Async这个注解，所以又会到 AsyncAnnotationBeanPostProcessor的postProcessAfterInitialization方法中，这里面不会考虑什么缓存，会又生成一个代理对象。所以这里会有两个bean 接着代码继续走到这里 也就是，包括在二级缓存中的bean，这时候这个类中，有3个不同的实例。所以最后 走到了else if里了。解决的办法也很简单，就是让allowRawInjectionDespiteWrapping这个属性为true。而这个属性是在beanFactory中，所以只要实现个BeanDefinitionRegistryPostProcessor这个接口，在postProcessBeanFactory方法中修改值就好了 但是并不推荐，还是以刚刚的例子，如果这样操作的话，就会导致 这里又一个对象了。对于一个单例的对象，却出现了两个对象，这是Spring不允许的 还有一种就是加个@Lazy，还有也可以用applicationContext对象获取，推荐这两种，上面那种不要使用。 @Scheduled使用这个的话要这样 1234567891011121314151617181920212223242526@Component@EnableScheduling//这个不是必须的@EnableAsync(proxyTargetClass = true)public class EnableAsyncBean &#123; private int corePoolSize = 10; private int maxPoolSize = 200; private int queueCapacity = 10; private String ThreadNamePrefix = &quot;JackExecutor-&quot;; @Bean public Executor executor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(corePoolSize); executor.setMaxPoolSize(maxPoolSize); executor.setQueueCapacity(queueCapacity); executor.setThreadNamePrefix(ThreadNamePrefix); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); return executor; &#125;&#125; 老套路，看注解@EnableScheduling定义 1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Import(SchedulingConfiguration.class)@Documentedpublic @interface EnableScheduling &#123;&#125; 看SchedulingConfiguration这个类 12345678910@Configuration@Role(BeanDefinition.ROLE_INFRASTRUCTURE)public class SchedulingConfiguration &#123; @Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() &#123; return new ScheduledAnnotationBeanPostProcessor(); &#125;&#125; ScheduledAnnotationBeanPostProcessor这个类是真的负责（指实现的接口是真的多） 可以看到，这个不是用AOP了。看postProcessAfterInitialization这个方法， 首先收集收集对象上有@Scheduled的方法，如果有就遍历这个集合，然后执行processScheduled这个方法。这个方法很长，我就概括下吧，首先会把对象和方法包装成一个Runnable对象。然后对注解中的属性解析（cron、fixedDelay等），接着就是调用JDK的定时任务线程池的API。 注意，这个注解的在Spring项目中使用时，需要想项目中创建一个TaskScheduler，然后交给Spring管理，不然会报错。但在Spring boot中不需要","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"16-Spring缓存切面","slug":"spring/5.2.8/16-Spring缓存切面","date":"2021-11-20T12:00:24.000Z","updated":"2022-03-14T09:04:26.325Z","comments":true,"path":"blog/spring/5.2.8/16-Spring缓存切面/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/16-Spring%E7%BC%93%E5%AD%98%E5%88%87%E9%9D%A2/","excerpt":"","text":"Spring缓存切面缓存切面在有了AOP和事务的知识后就觉得很简单了。 先说使用。加上这个注解@EnableCaching，还是老套路，看注解的定义 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE;&#125; 这个注解就是为了引入CachingConfigurationSelector.class这个启动类。老套路了，我就不细说了，注解看核心代码。 123456789private String[] getProxyImports() &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(3); result.add(AutoProxyRegistrar.class.getName()); result.add(ProxyCachingConfiguration.class.getName()); if (jsr107Present &amp;&amp; jcacheImplPresent) &#123; result.add(PROXY_JCACHE_CONFIGURATION_CLASS); &#125; return StringUtils.toStringArray(result);&#125; 还是一样的套路啊，通过AutoProxyRegistrar.class加上生成代理功能。ProxyCachingConfiguration.class这个不看都知道就是为了创建切面的。 1234567891011121314151617181920212223242526272829303132@Configuration@Role(BeanDefinition.ROLE_INFRASTRUCTURE)public class ProxyCachingConfiguration extends AbstractCachingConfiguration &#123; @Bean(name = CacheManagementConfigUtils.CACHE_ADVISOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public BeanFactoryCacheOperationSourceAdvisor cacheAdvisor() &#123; BeanFactoryCacheOperationSourceAdvisor advisor = new BeanFactoryCacheOperationSourceAdvisor(); advisor.setCacheOperationSource(cacheOperationSource()); advisor.setAdvice(cacheInterceptor()); if (this.enableCaching != null) &#123; advisor.setOrder(this.enableCaching.&lt;Integer&gt;getNumber(&quot;order&quot;)); &#125; return advisor; &#125; @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public CacheOperationSource cacheOperationSource() &#123; return new AnnotationCacheOperationSource(); &#125; @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public CacheInterceptor cacheInterceptor() &#123; CacheInterceptor interceptor = new CacheInterceptor(); interceptor.configure(this.errorHandler, this.keyGenerator, this.cacheResolver, this.cacheManager); interceptor.setCacheOperationSource(cacheOperationSource()); return interceptor; &#125;&#125; 切面是BeanFactoryCacheOperationSourceAdvisor，pointcut是CacheOperationSourcePointcut，Advice是CacheInterceptor，通知切面和Advice中包含AnnotationCacheOperationSource。这是真的和事务很像啊。功事务切面的经验猜测AnnotationCacheOperationSource的作用就是解析缓存注解的。 CacheOperationSourcePointcut12345@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; CacheOperationSource cas = getCacheOperationSource(); return (cas != null &amp;&amp; !CollectionUtils.isEmpty(cas.getCacheOperations(method, targetClass)));&#125; 老实说，这个和事务是一个套路，我在这重点说下解析那部分，代码 123AbstractFallbackCacheOperationSource#getCacheOperations --&gt;AbstractFallbackCacheOperationSource#computeCacheOperations --&gt;AnnotationCacheOperationSource#findCacheOperations 123protected Collection&lt;CacheOperation&gt; findCacheOperations(Method method) &#123; return determineCacheOperations(parser -&gt; parser.parseCacheAnnotations(method));&#125; 12345678910111213141516171819@Nullableprotected Collection&lt;CacheOperation&gt; determineCacheOperations(CacheOperationProvider provider) &#123; Collection&lt;CacheOperation&gt; ops = null; for (CacheAnnotationParser parser : this.annotationParsers) &#123; Collection&lt;CacheOperation&gt; annOps = provider.getCacheOperations(parser); if (annOps != null) &#123; if (ops == null) &#123; ops = annOps; &#125; else &#123; Collection&lt;CacheOperation&gt; combined = new ArrayList&lt;&gt;(ops.size() + annOps.size()); combined.addAll(ops); combined.addAll(annOps); ops = combined; &#125; &#125; &#125; return ops;&#125; this.annotationParsers是在构造函数中传入的。 provider的入参是parser -&gt; parser.parseCacheAnnotations(method)，所以看 SpringCacheAnnotationParser#parseCacheAnnotations，跟踪代码到 这里会把不同的注解解析成不同的对象，下面汇总下对应关系： Cacheable——CacheableOperation CacheEvict——CacheEvictOperation CachePut——CachePutOperation CacheInterceptor12345678910111213141516171819public Object invoke(final MethodInvocation invocation) throws Throwable &#123; Method method = invocation.getMethod(); CacheOperationInvoker aopAllianceInvoker = () -&gt; &#123; try &#123; return invocation.proceed(); &#125; catch (Throwable ex) &#123; throw new CacheOperationInvoker.ThrowableWrapper(ex); &#125; &#125;; try &#123; return execute(aopAllianceInvoker, invocation.getThis(), method, invocation.getArguments()); &#125; catch (CacheOperationInvoker.ThrowableWrapper th) &#123; throw th.getOriginal(); &#125;&#125; 这里先记下CacheOperationInvoker的作用就是进行火炬传递的。 12345678910111213141516protected Object execute(CacheOperationInvoker invoker, Object target, Method method, Object[] args) &#123; // Check whether aspect is enabled (to cope with cases where the AJ is pulled in automatically) if (this.initialized) &#123; Class&lt;?&gt; targetClass = getTargetClass(target); CacheOperationSource cacheOperationSource = getCacheOperationSource(); if (cacheOperationSource != null) &#123; Collection&lt;CacheOperation&gt; operations = cacheOperationSource.getCacheOperations(method, targetClass); if (!CollectionUtils.isEmpty(operations)) &#123; return execute(invoker, method, new CacheOperationContexts(operations, method, args, target, targetClass)); &#125; &#125; &#125; return invoker.invoke();&#125; execute的入参是CacheOperationInvoker，被代理对象，执行的方法，方法参数 initialized这个参数在afterSingletonsInstantiated后就变成true了。 这行的作用就是通过方法和class对象生成一个MethodClassKey对象，然后用这个对象从缓存中获取到之前解析得到对象。 接着在执行下一个execute方法前会把必须信息包装成CacheOperationContexts对象。看第二个execute方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private Object execute(final CacheOperationInvoker invoker, Method method, CacheOperationContexts contexts) &#123; //非关键代码 ..... //先处理@CacheEvicts的逻辑,,其实就是掉clear方法 // Process any early evictions processCacheEvicts(contexts.get(CacheEvictOperation.class), true, CacheOperationExpressionEvaluator.NO_RESULT); //处理@Cacheable的逻辑,,其实就是掉get方法 // Check if we have a cached item matching the conditions Cache.ValueWrapper cacheHit = findCachedItem(contexts.get(CacheableOperation.class)); // Collect puts from any @Cacheable miss, if no cached item is found List&lt;CachePutRequest&gt; cachePutRequests = new LinkedList&lt;&gt;(); //如果缓存没命中或者不是使用的@Cacheable注解 if (cacheHit == null) &#123; //处理@Cacheable的逻辑，收集插入请求,插入缓存的值需要调用被代理方法 collectPutRequests(contexts.get(CacheableOperation.class), CacheOperationExpressionEvaluator.NO_RESULT, cachePutRequests); &#125; Object cacheValue; Object returnValue; //如果缓存命中了 if (cacheHit != null &amp;&amp; !hasCachePut(contexts)) &#123; // If there are no put requests, just use the cache hit cacheValue = cacheHit.get(); //直接返回缓存中的值 returnValue = wrapCacheValue(method, cacheValue); &#125; else &#123; //在这里调用被代理方法 // Invoke the method if we don&#x27;t have a cache hit returnValue = invokeOperation(invoker); cacheValue = unwrapReturnValue(returnValue); &#125; //处理@CachePut注解,收集put请求 // Collect any explicit @CachePuts collectPutRequests(contexts.get(CachePutOperation.class), cacheValue, cachePutRequests); //处理put请求，其实就是掉put方法 // Process any collected put requests, either from @CachePut or a @Cacheable miss for (CachePutRequest cachePutRequest : cachePutRequests) &#123; cachePutRequest.apply(cacheValue); &#125; // Process any late evictions processCacheEvicts(contexts.get(CacheEvictOperation.class), false, cacheValue); return returnValue;&#125; 我们重点看Cacheable注解的。 获取方法方法上的Cacheable对应的操作类CacheableOperation。 12345678910111213141516171819202122232425262728293031323334353637private Cache.ValueWrapper findCachedItem(Collection&lt;CacheOperationContext&gt; contexts) &#123; Object result = CacheOperationExpressionEvaluator.NO_RESULT; for (CacheOperationContext context : contexts) &#123; if (isConditionPassing(context, result)) &#123; Object key = generateKey(context, result); Cache.ValueWrapper cached = findInCaches(context, key); if (cached != null) &#123; return cached; &#125; else &#123; 。。。 &#125; &#125; &#125; return null;&#125;private Cache.ValueWrapper findInCaches(CacheOperationContext context, Object key) &#123; for (Cache cache : context.getCaches()) &#123; Cache.ValueWrapper wrapper = doGet(cache, key); if (wrapper != null) &#123; 。。。 return wrapper; &#125; &#125; return null;&#125;protected Cache.ValueWrapper doGet(Cache cache, Object key) &#123; try &#123; return cache.get(key); &#125; catch (RuntimeException ex) &#123; getErrorHandler().handleCacheGetError(ex, cache, key); return null; // If the exception is handled, return a cache miss &#125;&#125; 然后从Cache对象中遍历获取，找到就返回。如果缓存没命中呢？流程代码接着走， 如果缓存没命中，这时就需要执行业务代码，获取值了，而Spring是先收集下@Cacheable的需要设置值的缓存，并生成对应的CachePutRequest对象。接着会就执行这段代码 这个invokeOperation()就是进行火炬传递，执行目标方法的，有值了，Spring这时还没有去往缓存中放值，而是好要收集下@CachePut的CachePutRequest。 最后 这了就是真正的往缓存中设置值的代码了。apply方法只是调用了Cache.put方法而已。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"15-Spring缓存注解的使用","slug":"spring/5.2.8/15-Spring缓存注解的使用","date":"2021-11-20T12:00:23.000Z","updated":"2022-03-14T09:04:26.302Z","comments":true,"path":"blog/spring/5.2.8/15-Spring缓存注解的使用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/15-Spring%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Spring缓存注解的使用配置123456789101112131415161718192021222324252627282930@Component@Configuration@EnableCachingpublic class CacheBean &#123; @Bean public RedisCache redisCache(RedisTemplate redisTemplate) &#123; RedisCache redisCache = new RedisCache(); redisCache.setName(&quot;redisCache&quot;); redisCache.setRedisTemplate(redisTemplate); return redisCache; &#125; @Bean public FactoryBean&lt;ConcurrentMapCache&gt; mapCache() &#123; ConcurrentMapCacheFactoryBean bean = new ConcurrentMapCacheFactoryBean(); bean.setName(&quot;mapCache&quot;); return bean; &#125; @Bean public CacheManager simpleCacheManager(Cache redisCache, Cache mapCache) &#123; SimpleCacheManager simpleCacheManager = new SimpleCacheManager(); List&lt;Cache&gt; list = new ArrayList&lt;&gt;(); list.add(redisCache); list.add(mapCache); simpleCacheManager.setCaches(list); return simpleCacheManager; &#125;&#125; RedisCache是实现了Spring的Cache接口的一个类。现在要配置下RedisTemplate RedisTemplate: 1234567891011121314151617181920212223242526272829303132333435@Component@PropertySource(&quot;classpath:core/redis.properties&quot;)@Configurationpublic class RedisConfig &#123; @Value(&quot;$&#123;redis.host&#125;&quot;) private String hostName; @Value(&quot;$&#123;redis.port&#125;&quot;) private int port; private JedisPoolConfig jedisPoolConfig() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();// jedisPoolConfig.setMaxIdle(maxIdle);// jedisPoolConfig.setMaxWaitMillis(maxWaitMillis);// jedisPoolConfig.setTestOnBorrow(testOnBorrow); return jedisPoolConfig; &#125; public JedisConnectionFactory jedisConnectionFactory()&#123; JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(); jedisConnectionFactory.setHostName(hostName); jedisConnectionFactory.setPort(port);// jedisConnectionFactory.setPassword(password); jedisConnectionFactory.setPoolConfig(jedisPoolConfig()); return jedisConnectionFactory; &#125; @Bean public RedisTemplate&lt;String, String&gt; redisTemplate() &#123; RedisTemplate&lt;String, String&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(jedisConnectionFactory()); return template; &#125;&#125; 使用养成习惯，先创建接口 12345678public interface CacheService &#123; String redisGetData(String id); String redisPutData(String id); String mapGetData(String id); String mapPutData(String id);&#125; 实现 12345678910111213141516171819202122232425262728@Service@Slf4jpublic class CacheServiceImpl implements CacheService &#123; @Cacheable(cacheNames = &quot;redisCache&quot;,key = &quot;&#x27;xyz&#x27; + #id&quot;) @Override public String redisGetData(String id) &#123; System.out.println(&quot;======CacheServiceImpl.queryData&quot;); return &quot;测试-redis-Cacheable&quot;; &#125; @CachePut(cacheNames = &quot;redisCache&quot;, key = &quot;&#x27;xyz&#x27; + #id&quot;) @Override public String redisPutData(String id) &#123; System.out.println(&quot;======CacheServiceImpl.queryData&quot;); return &quot;测试-redis-CachePut&quot;; &#125; @Override public String mapGetData(String id) &#123; return null; &#125; @Override public String mapPutData(String id) &#123; return null; &#125;&#125; 还有很多的，但是我就常用@Cacheable和@CachePut","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"14-Spring中使用事物编程","slug":"spring/5.2.8/14-Spring中使用事物编程","date":"2021-11-20T12:00:22.000Z","updated":"2022-03-14T09:04:26.300Z","comments":true,"path":"blog/spring/5.2.8/14-Spring中使用事物编程/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/14-Spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8B%E7%89%A9%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Spring中使用事物声明式事物的弊端 其实PROPAGATION_REQUIRES_NEW这个传播级别最明显，就是会获取多个链接对象。 声明试事物只能作用于方法； 而且如果在方法那调用还有限制，不然会使@Transaction失效。 比如： 12345678910class A &#123; @Transactional() void fun1() &#123; // something do &#125; void fun2() &#123; fun1(); &#125;&#125; 这样定义了一个类，在项目中如果发生这样的调用 12345678Class B &#123; @Autowire A a; void fun1() &#123; a.fun2(); &#125;&#125; 那么A的fun1的注解就会失效。因为A的fun2没有注解。就算B中的a对象是代理对象，由于A的fun2没有注解，所以不会走到事物切面，而是直接使用真实对象调用了fun1。 如果A改成 12345678910111213class A &#123; @Autowire A a; @Transactional() void fun1() &#123; // something do &#125; void fun2() &#123; a.fun1(); &#125;&#125; 这样事物注解就会生效。 如果在使用时不注意，会导致事务传播得很深，也就是会导致事务的流程过长了，而且在优化代码时，过深也会导致很难下手。 声明式事物所以我不喜欢用声明式事物，更喜欢用编程式事物 编程式事物我是喜欢用这中方式 123456789101112131415161718@Beanpublic TransactionTemplate transactionTemplate(PlatformTransactionManager platformTransactionManager) &#123; TransactionTemplate transactionTemplate = new TransactionTemplate(); // 可以设置只读 transactionTemplate.setTransactionManager(platformTransactionManager); return transactionTemplate;&#125;@Autowiredprivate TransactionTemplate transactionTemplate;public void txt() &#123; transactionTemplate.execute(status -&gt; &#123; addArea(&quot;xyz&quot;); addGoods(&quot;xyzGoods&quot;); return 1; &#125;);&#125; 这样使用。 看这个源码: 1234567891011121314151617181920212223242526public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123; Assert.state(this.transactionManager != null, &quot;No PlatformTransactionManager set&quot;); if (this.transactionManager instanceof CallbackPreferringPlatformTransactionManager) &#123; return ((CallbackPreferringPlatformTransactionManager) this.transactionManager).execute(this, action); &#125; else &#123; TransactionStatus status = this.transactionManager.getTransaction(this); T result; try &#123; result = action.doInTransaction(status); &#125; catch (RuntimeException | Error ex) &#123; // Transactional code threw application exception -&gt; rollback rollbackOnException(status, ex); throw ex; &#125; catch (Throwable ex) &#123; // Transactional code threw unexpected exception -&gt; rollback rollbackOnException(status, ex); throw new UndeclaredThrowableException(ex, &quot;TransactionCallback threw undeclared checked exception&quot;); &#125; this.transactionManager.commit(status); return result; &#125;&#125; 代码就和注解的一样。 甚至可以使用PlatformTransactionManager 123456789101112131415161718@AutowiredPlatformTransactionManager platformTransactionManager;public void xxx() &#123; DefaultTransactionDefinition defaultTransactionDefinition = new DefaultTransactionDefinition(); defaultTransactionDefinition.setPropagationBehavior(0); TransactionStatus transaction = platformTransactionManager.getTransaction(defaultTransactionDefinition); try &#123; System.out.println(&quot;业务代码&quot;); &#125; catch (Exception e) &#123; platformTransactionManager.rollback(transaction); &#125; platformTransactionManager.commit(transaction);&#125; TransactionSynchronizationManager 只有使用声明式事物才有效 TransactionSynchronizationManager这个类在Spring的事物中处理处理链接资源的绑定和一些状态的记录，还有一个就是触发器。 在源码中，比如事物提交了，都有执行一些方法 还有很多，但它们这些方法都是在不同的阶段执行的，而且这些都是Spring提供出来的扩展点。我们看一个方法就知道了。 1234567891011121314protected final void triggerBeforeCommit(DefaultTransactionStatus status) &#123; if (status.isNewSynchronization()) &#123; if (status.isDebug()) &#123; logger.trace(&quot;Triggering beforeCommit synchronization&quot;); &#125; TransactionSynchronizationUtils.triggerBeforeCommit(status.isReadOnly()); &#125;&#125;public static void triggerBeforeCommit(boolean readOnly) &#123; for (TransactionSynchronization synchronization : TransactionSynchronizationManager.getSynchronizations()) &#123; synchronization.beforeCommit(readOnly); &#125;&#125; 也就是，只要我们在方法中调用TransactionSynchronizationManager.registerSynchronization()方法传入一个对应的对象，我们就能在对应的阶段做一些额外的业务操作。而这个对象的类Spring也为我们提供了一个适配器，我们只要继承它然后重写自己的关注的方法就好了，这个适配器是TransactionSynchronization 123456789101112131415161718192021222324252627282930313233343536public abstract class TransactionSynchronizationAdapter implements TransactionSynchronization, Ordered &#123; @Override public int getOrder() &#123; return Ordered.LOWEST_PRECEDENCE; &#125; @Override public void suspend() &#123; &#125; @Override public void resume() &#123; &#125; @Override public void flush() &#123; &#125; @Override public void beforeCommit(boolean readOnly) &#123; &#125; @Override public void beforeCompletion() &#123; &#125; @Override public void afterCommit() &#123; &#125; @Override public void afterCompletion(int status) &#123; &#125;&#125; 比如我定义这样一个类 1234567public class XyzTransactionCommitAfter extends TransactionSynchronizationAdapter &#123; @Override public void afterCommit() &#123; System.out.println(&quot;做一些其他事情&quot;); &#125;&#125; 然后在业务代码中 12345678public void transation() throws JamesException &#123; TransactionSynchronizationManager.registerSynchronization(new XyzTransactionCommitAfter()); try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; &#125;&#125; 那么在事物提交后就能执行到System.out.println(&quot;做一些其他事情&quot;);这行代码。 注意了，不要想用多线程来玩这个，这个是放在一个ThreadLocal中的。 还有 12ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); 可以获取到链接对象，然后做一些骚操作。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"13-Spring的事务传播属性","slug":"spring/5.2.8/13-Spring的事务传播属性","date":"2021-11-20T12:00:21.000Z","updated":"2022-03-14T09:04:26.292Z","comments":true,"path":"blog/spring/5.2.8/13-Spring的事务传播属性/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/13-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E5%B1%9E%E6%80%A7/","excerpt":"","text":"Spring的事务传播属性先看下这里简单介绍事务传播属性 重点讲这三个 PROPAGATION_REQUIRED PROPAGATION_REQUIRES_NEW PROPAGATION_NESTED 在这先定义下伪代码： 123456789101112131415class fake &#123; @Transactional fun1() @Transactional fun2(); @Transactional fun4() &#123; fun1() fun2() &#125;&#125;fake.fun4(); 在TransactionManager.setGlobalRollbackOnParticipationFailure(false);这个前提下，下面的伪代码才成立，原因看调试时发现了一个问题 fun1()和fun2()的执行过程分别用process1和process2表示，从上节的知识，可以得出fun4()的执行过程伪代码。 123456789101112131415161718192021222324252627282930313233343536373839404142info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=true); // 该if会返回ture if (txObject.connectionHolder == null || txObject.connectionHolder.transactionActive == false) &#123; // 获取链接 transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; &#125; return status; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun4() &#123; process1 process2 &#125;&#125; catch &#123; if info.status.newTransaction &#123; transactionManager.doRollback(); threadLocal.remove(dataSource) &#125; throw e&#125;if info.status.newTransaction &#123; transactionManager.doCommit(); threadLocal.remove(dataSource)&#125; 而process1，的大致执行流程如下： 12345678910111213141516171819202122232425262728info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; // 该if会返回ture if (txObject.connectionHolder != null &amp;&amp; txObject.connectionHolder.transactionActive != false) &#123; return handleExistingTransaction(txObject) &#123; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=false); //do something; return status; &#125; &#125; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun1();&#125; catch &#123; if info.status.newTransaction transactionManager.doRollback(); throw e&#125;if info.status.newTransaction transactionManager.doCommit(); process2一样。 上边的process1中的handleExistingTransaction就是今天重点代码！ 下面分情况讲该代码 PROPAGATION_REQUIRED这个是@Transactional默认的传播级别。 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。也就是在有方法的嵌套时，使用的都是同一个链接。这是最常见的选择。 我有个service，里面有几个方法： 123456789101112131415161718192021222324@Transactional@Overridepublic void transation() throws JamesException &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;);&#125;@Transactional()public int addArea(String name) &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); int i = areaService.insertOne(name); return i;&#125;@Transactionalpublic void addGoods(String name) &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;);&#125; TransactionSynchronizationManager.getResource(dataSource);这个在前面就已经讲过了，获取链接后会建立&lt;dataSource,ConnectionHolder&gt;这种关系，并保存到一个threadLocal中。这个方法就是从threadLocal中获取通过dataSource获取链接。 代码很简单，最主要还是打印了Connection对象。 看下答应结果： 可以看到，Connection对象是一样的。完全符合它的定义。现在分析下源码。回到createTransactionIfNecessary 跟踪代码： 12TransactionAspectSupport#createTransactionIfNecessary ---&gt;AbstractPlatformTransactionManager#getTransaction 先debug，看这个transaction打印的值。 第一次： 第二次： 第三次： 从上节就已经知道，在第一次进来这个方法的时候connectionHolder对象是空的，因为： 这个时候这行代码TransactionSynchronizationManager.getResource(obtainDataSource())中从ThreadLocal获取不到数据。所以返回为空。在第一次开启了事物后就创建了一个connectionHolder对象了，并开启事物的最后会把这个对象放到ThreadLocal中。而且，第一次调用的方法的对象是代理对象，而且被调用的方法有@Transactional注解，所以在第二次调用方法的时候就能匹配到事务切面，而且也会走到getTransactino方法，也就是说，在doGetTransaction的时候就可以从这个ThreadLocal中获取的第一次创建的connectionHolder对象，而且下面的isExistingTransaction方法会返回true。第三次也一样。接着执行到这里 因为 第二次和第三次的时候connectionHolder对象不为空，而且transactionActive&#x3D;&#x3D;true。所以重点看 handleExistingTransaction方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private TransactionStatus handleExistingTransaction( TransactionDefinition definition, Object transaction, boolean debugEnabled) throws TransactionException &#123; //不允许有事务，直接异常 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( &quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;); &#125; //以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction&quot;); &#125; //挂起当前事务 Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); //修改事务状态信息，把事务的一些信息存储到当前线程中，ThreadLocal中 return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources); &#125; if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; if (debugEnabled) &#123; logger.debug(&quot;Suspending current transaction, creating new transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; //挂起 SuspendedResourcesHolder suspendedResources = suspend(transaction); try &#123; return startTransaction(definition, transaction, debugEnabled, suspendedResources); &#125; catch (RuntimeException | Error beginEx) &#123; resumeAfterBeginException(transaction, suspendedResources, beginEx); throw beginEx; &#125; &#125; if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (!isNestedTransactionAllowed()) &#123; throw new NestedTransactionNotSupportedException( &quot;Transaction manager does not allow nested transactions by default - &quot; + &quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;); &#125; if (debugEnabled) &#123; logger.debug(&quot;Creating nested transaction with name [&quot; + definition.getName() + &quot;]&quot;); &#125; //默认是可以嵌套事务的 if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. //这里的newTransaction 为 false DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); //创建回滚点 status.createAndHoldSavepoint(); return status; &#125; else &#123; // Nested transaction through nested begin and commit/rollback calls. // Usually only for JTA: Spring synchronization might get activated here // in case of a pre-existing JTA transaction. return startTransaction(definition, transaction, debugEnabled, null); &#125; &#125; // Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED. if (debugEnabled) &#123; logger.debug(&quot;Participating in existing transaction&quot;); &#125; if (isValidateExistingTransaction()) &#123; ..... &#125; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); //如果第二次进来还是PROPAGATION_REQUIRED，走这里，newTransaction为false return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);&#125; 这个代码就是对事物传播级别做不同的处理的。从代码可知PROPAGATION_REQUIRED，这个级别会走到这里： 这代码块的重点就是在prepareTransactionStatus，这个方法的重点就是创建DefaultTransactionStatus对象的，而且这个对象的newTransaction设置为false。从上一节的知识可以知DefaultTransactionStatus.newTransaction是用来判断事务是否需要提交和回滚的。为false意思就是不提交事物不执行回滚。也就是说，对于伪代码process1，do something就是什么都不做，就变成了如下： 123456789101112131415161718192021222324252627info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; // 该if会返回ture if (txObject.connectionHolder != null &amp;&amp; txObject.connectionHolder.transactionActive != false) &#123; return handleExistingTransaction(txObject) &#123; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=false); return status; &#125; &#125; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun1();&#125; catch &#123; if info.status.newTransaction transactionManager.doRollback(); throw e&#125;if info.status.newTransaction transactionManager.doCommit(); process2一样。整个fun4()的流程就变成了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=true); // 该if会返回ture if (txObject.connectionHolder == null || txObject.connectionHolder.transactionActive == false) &#123; transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; &#125; return status; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun4() &#123; process1: &#123; info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; // 该if会返回ture if (txObject.connectionHolder != null &amp;&amp; txObject.connectionHolder.transactionActive != false) &#123; return handleExistingTransaction(txObject) &#123; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=false); return status; &#125; &#125; &#125; return new TransactionInfo(status); &#125; try &#123; fake.fun1(); // 因为status.newTransaction为false，所以提交和回顾代码去掉了 &#125; catch &#123; throw e &#125; &#125; &#123; process2 &#125; &#125;&#125; catch &#123; transactionManager.doRollback(); throw e&#125;transactionManager.doCommit(); 这样了。也就是，整个调用过程都是在一个事物中，因为整个调用过程都是使用同一个链接对象。从这个伪代码中可以看到，提交是在栈尾的栈帧代表的方法提交的，事务回滚也是，如果process1或process2其中一个抛出异常，都会被栈尾的栈帧代表的方法捕获，从而执行真正的事务回滚，然后向外层抛出异常。 调试时发现了一个问题在上边说的是fun4能抛出异常的情况，那如果fun4捕获了异常，但不抛出异常，那会回滚吗？下面研究这个问题。 代码这样定义： 12345678910111213141516171819202122232425@Transactional@Overridepublic void transation() throws JamesException &#123; try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;@Transactional()public int addArea(String name) &#123; int i = areaService.insertOne(name); return i;&#125;@Transactionalpublic void addGoods(String name) &#123; int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;);&#125;测试：transation(); 这代码有个特点，就是调用的方法会吞了异常，而被包含的方法不会吞异常。 如果按伪代码的流程就会走到doCommit()，也就是事物提交了。但是真的是这样吗？现在TransactionAspectSupport#invokeWithinTransaction方法的最后打个断点： 最后会走到这里 执行回滚了。现在分析原因。 看下源码就知道shouldCommitOnGlobalRollbackOnly()这个方法是默认情况是返回false的，所以看defStatus.isGlobalRollbackOnly()这个。这个defStatus是DefaultTransactionStatus。看这个源码 12345@Overridepublic boolean isGlobalRollbackOnly() &#123; return ((this.transaction instanceof SmartTransactionObject) &amp;&amp; ((SmartTransactionObject) this.transaction).isRollbackOnly());&#125; (this.transaction instanceof SmartTransactionObject)这个肯定为true的，因为 而且 问题就出现在(SmartTransactionObject) this.transaction).isRollbackOnly()这段代码了。看isRollbackOnly()源码 也就是说看ConnectionHolder就好了： 可以看到默认值为false的，只要调用了setRollbackOnly的时候才会为true。跟踪下，这个又会被DataSourceTransactionObject调用 再跟踪，会被这里调用 先记住方法doSetRollbackOnly。现在回想下流程。就是process2那里抛出异常了。我们可以看下catch的语句块，跟踪下这里代码。 由于TransactionStatus.newTransaction &#x3D; false，所以最终会走到else代码块： 走到回滚代码的else代码块了，也就是，现在造成这种原因有两个 DefaultTransactionStatus#isLocalRollbackOnly AbstractPlatformTransactionManager#isGlobalRollbackOnParticipationFailure() 这两个方法。 DefaultTransactionStatus#isLocalRollbackOnly先看第一个方法 这个rollbackOnly默认值是false的，而这个setRollbackOnly()方法，在源码中没有调用，这个方法是给给业务代码调用的（编程式事务）。所以排除这个看第二个原因 AbstractPlatformTransactionManager#isGlobalRollbackOnParticipationFailure() 这个是TransactionManager的一个成员属性，翻译为“在发生部分错误后进行全局回滚”，从名字就知道这个属性的作用了。那是不是我只要TransactionManager.setGlobalRollbackOnParticipationFailure(false)，那某个嵌套方法错误，主方法捕捉错误，这种情况下不就不会发生回滚了？ 继续跟踪代码 没有执行那段代码了！！！问题真的出现在这个属性上！！最后会执行到提交代码。不过并不建议设置修改这个值，因为这样如果开发人员代码有问题，那就容易导致数据库的数据异常了。因为这有部分代码提交代码了！ 回到源码，这时代码没有执行doSetRollbackOnly方法，报错然后被调用方捕捉到，接着调用方就执行了TransactionManager.commit方法。最后看源码 由于没有把ConnectionHolder的rollback属性设置为true，所以会走到processCommit方法。所以会提交事务。 总结出现这个问题的原因是因为，最外层的方法把异常吞了，而里面的方法会抛出异常，这样才会出现了上面出现的现象——Spring 帮我们回滚了。也就是说只要最外层方法的内部中，有方法调用了 这个方法，而且TransactionManager没有setGlobalRollbackOnParticipationFailure(false)执行这行代码，才会出现这样的现象。 老实说，这样的设计挺合理的，只要方法里面的方法抛出异常了，就算外层的方法不抛出异常，都会帮我们回滚。这样就可以减少人为代码的错误，而导致数据错误了。这样设置后，由于fun4捕捉了错误，那就会执行打TransactionManager.commit方法。 结论对于事物，只要一个方法的异常被Spring捕捉到，那在默认的情况下Spring都会帮我们回滚。除非我们通过在新建事务管理器TransactionManager的时候setGlobalRollbackOnParticipationFailure(false)来取消这一特性 经典问题12345678910111213141516171819202122@Transactional@Overridepublic void transation() throws JamesException &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;);&#125;@Transactional()public int addArea(String name) &#123; int i = areaService.insertOne(name); return i;&#125;@Transactionalpublic void addGoods(String name) &#123; try &#123; int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 如果这样设计的话，从之前的伪代码可以得出，这个事物是会提交的。因为没有走到 TransactionAspectSupport#invokeWithinTransaction的catch语句快。 PROPAGATION_REQUIRES_NEW新建事务，如果当前存在事务，把当前事务挂起。 其实从jdbc中的事物就可以猜到，这个传播级别的实现方式就是拿一个新的Condition对象。这样定义: 1234567891011121314151617181920212223@Transactional@Overridepublic void transation() throws JamesException &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;);&#125;@Transactional(propagation = Propagation.REQUIRES_NEW)public int addArea(String name) &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); int i = areaService.insertOne(name); return i;&#125;@Transactional(propagation = Propagation.REQUIRES_NEW)public void addGoods(String name) &#123; ConnectionHolder resource = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); System.out.println(&quot;-----------------&quot; + resource.getConnection()); int i = goodsService.insertOne(name);&#125; 和猜侧的一样。还是回到AbstractPlatformTransactionManager#getTransaction方法 第一次过程和上面一样 第二次还是会获取到第一次创建的connection对象还会走到handleExistingTransaction方法，但在由于隔离级别是 PROPAGATION_REQUIRES_NEW没，所以在handleExistingTransaction方法中会走到这里： 先看 1SuspendedResourcesHolder suspendedResources = suspend(transaction); 1234567891011121314151617181920212223242526272829303132333435protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException &#123; if (TransactionSynchronizationManager.isSynchronizationActive()) &#123; List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization(); try &#123; Object suspendedResources = null; if (transaction != null) &#123; suspendedResources = doSuspend(transaction); &#125; String name = TransactionSynchronizationManager.getCurrentTransactionName(); TransactionSynchronizationManager.setCurrentTransactionName(null); boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly(); TransactionSynchronizationManager.setCurrentTransactionReadOnly(false); Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel(); TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null); boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive(); TransactionSynchronizationManager.setActualTransactionActive(false); return new SuspendedResourcesHolder( suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive); &#125; catch (RuntimeException | Error ex) &#123; // doSuspend failed - original transaction is still active... doResumeSynchronization(suspendedSynchronizations); throw ex; &#125; &#125; else if (transaction != null) &#123; // Transaction active but no synchronization active. Object suspendedResources = doSuspend(transaction); return new SuspendedResourcesHolder(suspendedResources); &#125; else &#123; // Neither transaction nor synchronization active. return null; &#125;&#125; 先看doSuspend，而这个是在DataSourceTransactionManager中实现的 DataSourceTransactionManager#suspend: 这段代码的的意思就是先txObject.setConnectionHolder(null);，然后执行了解除资源绑定方法（可以理解为threadLocal.remove(connectionHolder)），返回第一次的链接对象。 接着在suspend方法中，把这个第一次链接对象作为参数，传入新建的SuspendedResourcesHolder对象中，接着返回，然后执行了startTransaction方法，然后又开启了一次事物（因为DataSourceTransactionObject.connectionHolder属性为null了） 那么第二次执行到最后，由于DefaultTransactionStatus.newTransaction&#x3D;&#x3D;true，所以第二次的调用时肯定会提交事物的。现在看提交的方法AbstractPlatformTransactionManager#processCommit，在这个方法中有个finally，看里面的方法： 12345678910111213141516171819private void cleanupAfterCompletion(DefaultTransactionStatus status) &#123; status.setCompleted(); if (status.isNewSynchronization()) &#123; TransactionSynchronizationManager.clear(); &#125; //释放连接 if (status.isNewTransaction()) &#123; doCleanupAfterCompletion(status.getTransaction()); &#125; //如果存在挂起的事务 if (status.getSuspendedResources() != null) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Resuming suspended transaction after completion of inner transaction&quot;); &#125; Object transaction = (status.hasTransaction() ? status.getTransaction() : null); //恢复绑定关系 resume(transaction, (SuspendedResourcesHolder) status.getSuspendedResources()); &#125;&#125; 这里： 在第二次的时候这个SuspendedResources是不为null的，里面包含了第一次的链接对象。跟踪resume方法： 12AbstractPlatformTransactionManager#resume --&gt;DataSourceTransactionManager#doResume(第一次的链接对象) 又重新建立绑定关系了。回滚都一样，最后都会调用cleanupAfterCompletion方法，这里就不跟了。 也就是，对于伪代码process1，就变成了如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; // 该if会返回ture if (txObject.connectionHolder != null &amp;&amp; txObject.connectionHolder.transactionActive != false) &#123; return handleExistingTransaction(txObject) &#123; // 解除旧链接绑定 txObject.connectionHolder = null; oldConnectionHolder = threadLocal.remove(dataSource); SuspendedResourcesHolder suspendedResources = new SuspendedResourcesHolder(oldConnectionHolder) DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=true, suspendedResources); // 获取新的链接，并重新绑定 transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; return status; &#125; &#125; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun1();&#125; catch &#123; if info.status.newTransaction &#123; transactionManager.doRollback(); threadLocal.set&lt;dataSource,info.status.suspendedResources.oldConnectionHolder&gt; &#125; throw e&#125;if info.status.newTransaction &#123; transactionManager.doCommit(); threadLocal.set&lt;dataSource,info.status.suspendedResources.oldConnectionHolder&gt;&#125; 整个就变成了: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=true); // 该if会返回ture if (txObject.connectionHolder == null || txObject.connectionHolder.transactionActive == false) &#123; // 获取链接 transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; &#125; return status; &#125; return new TransactionInfo(status);&#125;try &#123; fake.fun4() &#123; process1: &#123; info = createTransactionIfNecessary &#123; DefaultTransactionStatus status = transactionManager.getTransaction &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); ConnectionHolder connectionHolder = threadLocal.get(); txObject.setConnectionHolder(connectionHolder) return txObject; &#125; // 该if会返回ture if (txObject.connectionHolder != null &amp;&amp; txObject.connectionHolder.transactionActive != false) &#123; return handleExistingTransaction(txObject) &#123; // 解除旧链接绑定 txObject.connectionHolder = null; oldConnectionHolder = threadLocal.remove(dataSource); SuspendedResourcesHolder suspendedResources = new SuspendedResourcesHolder(oldConnectionHolder) DefaultTransactionStatus status = newTransactionStatus(txObject, newTransaction=true, suspendedResources); // 获取新的链接，并重新绑定 transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; return status; &#125; &#125; &#125; return new TransactionInfo(status); &#125; try &#123; fake.fun2(); &#123; 套娃 &#125; &#125; catch &#123; if info.status.newTransaction &#123; transactionManager.doRollback(); threadLocal.set&lt;dataSource, info.status.suspendedResources.oldConnectionHolder&gt; &#125; throw e &#125; if info.status.newTransaction &#123; transactionManager.doCommit(); threadLocal.set&lt;dataSource, info.status.suspendedResources.oldConnectionHolder&gt; &#125; &#125; &#123; process2 &#125; &#125;&#125; catch &#123; if info.status.newTransaction &#123; transactionManager.doRollback(); threadLocal.remove(dataSource) &#125; throw e&#125;if info.status.newTransaction &#123; transactionManager.doCommit(); threadLocal.remove(dataSource)&#125; 简化的伪代码: 1234567891011begin a; //a do something // 解除a的绑定 suspend a; begin b; //b do something commit b; // 恢复a的绑定 resume a; //a do somethingcommit a; PROPAGATION_NESTED如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 在说这个的时候先看下jdbc的回滚点。 先看下这段伪代码 123456Connection connection = ...;insert1connection.setSavepoint(&quot;a1&quot;);insert2connection.setSavepoint(&quot;a2&quot;);connection.commit(); 如果代码变成了这样 1234567Connection connection = ...;insert1connection.setSavepoint(&quot;a1&quot;);insert2connection.setSavepoint(&quot;a2&quot;);connection.rollback(&quot;a1&quot;);connection.commit(); 也就是说执行了connection.rollback(“a1”);这行后，就把insert2给回滚了。 现在回到Spring的事物传播级别，老实说，如果是正常不报错的情况下，它的表现和PROPAGATION_REQUIRED一样的。所以就看下抛出错误的情况。 我定义了下面的代码。调用了transation()，还是看答应的链接对象。 1234567891011121314151617181920@Transactional@Overridepublic void transation() throws JamesException &#123; try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; &#125;&#125;public int addArea(String name) &#123; int i = areaService.insertOne(name); return i;&#125;@Transactional(propagation = Propagation.NESTED)public void addGoods(String name) &#123; int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;);&#125; 默认情况下： 如果是PROPAGATION_REQUIRED这个传播级别，在默认情况下最后两张表还是没数据(前面已经说过原因了)。现在先看下PROPAGATION_NESTED这个隔离级别的效果。也就是如下代码： 123456789101112131415161718192021@Transactional(propagation = Propagation.NESTED)@Overridepublic void transation() throws JamesException &#123; try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; &#125;&#125;@Transactional()public int addArea(String name) &#123; int i = areaService.insertOne(name); return i;&#125;@Transactional()public void addGoods(String name) &#123; int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;);&#125; 现在有数据了。为什么会这样，我们看下代码。 还是看AbstractPlatformTransactionManager#getTransaction方法。第一次和之前的一样，第二次还会获取到第一次的链接对象，而且会执行到handleExistingTransaction方法中的这段代码块： 12345678910111213141516//去掉一些打印日志的和抛错的if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; ... //默认是可以嵌套事务的 if (useSavepointForNestedTransaction()) &#123; //这里的newTransaction 为 false DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); //创建回滚点 status.createAndHoldSavepoint(); return status; &#125; else &#123; return startTransaction(definition, transaction, debugEnabled, null); &#125;&#125; 先看useSavepointForNestedTransaction()这个方法。 默认为true的，也就说默认是允许嵌套事务的，所以看看if的代码块就好了。在这代码块中先做了 1DefaultTransactionStatus status = newTransactionStatus(newTransaction=false) 然后status.createAndHoldSavepoint(); 12345678910111213141516171819202122// AbstractTransactionStatuspublic void createAndHoldSavepoint() throws TransactionException &#123; setSavepoint(getSavepointManager().createSavepoint());&#125;// JdbcTransactionObjectSupport@Overridepublic Object createSavepoint() throws TransactionException &#123; ConnectionHolder conHolder = getConnectionHolderForSavepoint(); try &#123; return conHolder.createSavepoint(); &#125; catch (SQLException ex) &#123; ...... &#125;&#125;// ConnectionHolderpublic Savepoint createSavepoint() throws SQLException &#123; this.savepointCounter++; return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);&#125; 也就是说，现在这个DefaultTransactionStatus持有了一个Savepoint对象，而且是在调用目标方法之前创建的Savepoint，也就是说只要执行rollback(savepoint)就能把这次的操作回滚掉 接着执行完目标方法后由于DefaultTransactionStatus.newTransaction&#x3D;&#x3D;false所以在此方法调用中不会真正的提交事物。 我们看下提交代码。TransactionAspectSupport#commitTransactionAfterReturning跟踪代码到AbstractPlatformTransactionManager#processCommit，在这代码中有这段代码： 重点看status.releaseHeldSavepoint(): 也就是说，执行第二次执行到这里后，由于这个if符合条件就执行了releaseHeldSavepoint方法。也就是去释放savepoint方法. 注意，这种释放是不会提交代码的，只是删除了具体的一个savepoint。 也就是说这行代码的意思就是释放连接点。第二次的调用完毕了，看第三次的。 第三次还是一样，不同的就 第三次抛错了。所以看回滚代码:TransactionAspectSupport#completeTransactionAfterThrowing，跟踪代码到AbstractPlatformTransactionManager#processRollback，执行到这里了： 这块代码这提交那里的很像，只是多了getSavepointManager().rollbackToSavepoint(savepoint);，跟踪代码到 第一行就是回滚到savepoint的位置，第二行就是： 这一步很关键，会使得事物得以提交，而不是整个回滚掉，原因可以看上边 也就是说，process1流程的伪代码在这种传播级别下变成了这样: 12345678910DefaultTransactionStatus status = newTransactionStatus(newTransaction=false);savepoint = transactionManager.savePoint(&quot;savepoint_&quot; + ++i)status.setSavepoint(savepoint);try &#123; fun1();&#125; catch &#123; transactionManager.rollback(status.savepoint); status.rollbackOnly = false; throw ex;&#125; Fun4()的伪代码变成了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647status = createTransactionIfNecessary &#123; DataSourceTransactionObject txObject = transactionManager.doGetTransaction() &#123; connectionHolder = threadLocal.get(); &#125; DefaultTransactionStatus status = null; if (txObject.connectionHolder == null || txObject.connectionHolder.transactionActive == false) &#123; status = newTransactionStatus(newTransaction=true); transactionManager.doBegin() &#123; if (txObject.connectionHolder == null) &#123; txObject.connectionHolder = new ConnectionHolder(dataSource.getConnection); &#125; txObject.connectionHolder.connection.autoCommit = false; threadLocal.set(&lt;dataSource,txObject.connectionHolder&gt;); txObject.connectionHolder.transactionActive = true; &#125; &#125; return status;&#125;try &#123; fake.fun4() &#123; // 这里在方法内捕捉了错误，就不会回滚 &#123; DefaultTransactionStatus status = newTransactionStatus(newTransaction=false); savepoint = transactionManager.savePoint(&quot;savepoint_&quot; + ++i) status.setSavepoint(savepoint); try &#123; fun1(); &#125; catch &#123; transactionManager.rollback(status.savepoint); status.rollbackOnly = false; throw ex; &#125; &#125; &#123;....&#125; &#125;&#125; catch &#123; if status.newTransaction transactionManager.doRollback(); throw e&#125;if status.rollbackOnly &#123; transactionManager.doRollback();&#125; else &#123; if status.newTransaction transactionManager.doCommit();&#125; 对于这段代码 @Transactional public void transation() throws JamesException &#123; try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; &#125; &#125; 这段代码根据上边的伪代码，变成了这样 12345678910111213141516171819begin; try&#123; transation() &#123; //transationService.addArea(&quot;xyz&quot;); savepoint1 = con.savePoint(..) transationService.addArea(&quot;xyz&quot;); con.releaseSavePoing(savepoint1); savepoint2 = con.savePoint(..) try &#123; transationService.addGoods(&quot;xyzGoods&quot;); throw ex; &#125; catch &#123; con.rollback(savepoint2); throw ex; &#125; &#125; &#125; catch &#123; &#125;commit; 所以最后transationService.addArea(&quot;xyz&quot;);的数据提交了。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"12-Spring的事物","slug":"spring/5.2.8/12-Spring的事物","date":"2021-11-20T12:00:20.000Z","updated":"2022-03-14T09:04:26.170Z","comments":true,"path":"blog/spring/5.2.8/12-Spring的事物/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/12-Spring%E7%9A%84%E4%BA%8B%E7%89%A9/","excerpt":"","text":"Spring的事物先复习下jdbc的事物管理123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; Connection connection = null; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); connection = DriverManager.getConnection(DB_URL, USER, PASS); //开启事务 /* * * */ connection.setAutoCommit(false); insertTest(connection); insertTest1(connection); connection.commit(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; connection.rollback(); System.out.println(&quot;JDBC Transaction rolled back successfully&quot;); &#125; catch (SQLException e1) &#123; System.out.println(&quot;JDBC Transaction rolled back fail&quot; + e1.getMessage()); &#125; &#125; finally &#123; if (connection != null) &#123; try &#123; selectAll(connection); connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面就是jdbc事务开启和提交（回滚）的代码。要使两次insert都在一个事务中，那必须要把自动提交关闭。而判断两次insert是否在一个同一个事务的依据就是是否为同一个Connection对象，而且这个Connection对象必须关闭自动提交！ Spring中的式事务管理声明式事务就是使用@Transactional定义的方法。 在这里说明下@Transactional这里面的超时属性，这个超时是指sql执行的超时。 开启的方法也很简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155@Configuration@EnableTransactionManagement// &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;@MapperScan(basePackages = &#123;&quot;com.xyz.dao&quot;&#125;)public class EnableTransactionManagementBean &#123; /** &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; */ //这是mybatis @Bean public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean; &#125; // Spring的事务管理器 @Bean public PlatformTransactionManager annotationDrivenTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager dtm = new DataSourceTransactionManager(); dtm.setDataSource(dataSource); return dtm; &#125; //编程式事务使用 @Bean public TransactionTemplate transactionTemplate(PlatformTransactionManager platformTransactionManager) &#123; TransactionTemplate transactionTemplate = new TransactionTemplate(); transactionTemplate.setTransactionManager(platformTransactionManager); return transactionTemplate; &#125;&#125;@Configuration@PropertySource(&quot;classpath:core/core.properties&quot;)public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;) private String driverClass; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String jdbcUrl; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String user; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String jdbcUrl1; @Resource Environment environment; @Bean public DataSource comboPooledDataSource() &#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); try &#123; comboPooledDataSource.setDriverClass(driverClass); comboPooledDataSource.setJdbcUrl(jdbcUrl); comboPooledDataSource.setUser(user); comboPooledDataSource.setPassword(password); comboPooledDataSource.setMinPoolSize(10); comboPooledDataSource.setMaxPoolSize(100); comboPooledDataSource.setMaxIdleTime(1800); comboPooledDataSource.setAcquireIncrement(3); comboPooledDataSource.setMaxStatements(1000); comboPooledDataSource.setInitialPoolSize(10); comboPooledDataSource.setIdleConnectionTestPeriod(60); comboPooledDataSource.setAcquireRetryAttempts(30); comboPooledDataSource.setBreakAfterAcquireFailure(false); comboPooledDataSource.setTestConnectionOnCheckout(false); comboPooledDataSource.setAcquireRetryDelay(100); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; return comboPooledDataSource; &#125;&#125;//使用也能简单，用@Transactional注解就好了@Service(&quot;transationServiceImpl&quot;)public class TransationServiceImpl implements TransationService &#123; @Autowired private AreaNameMapper areaService; @Autowired private GoodsNameMapper goodsService; @Autowired private UserNameMapper userMapper; @Autowired @Qualifier(&quot;transationServiceImpl&quot;) private TransationService transationService; @Autowired private DataSource dataSource; @Autowired private TransactionTemplate transactionTemplate; public void txt() &#123; transactionTemplate.execute(status -&gt; &#123; addArea(&quot;xyz&quot;); addGoods(&quot;xyzGoods&quot;); return 1; &#125;); &#125; @Transactional// @Async @Override public void transation() throws JamesException &#123; TransactionSynchronizationManager.registerSynchronization(new XyzTransactionCommitAfter()); ConnectionHolder connectionHolder = (ConnectionHolder)TransactionSynchronizationManager.getResource(dataSource); try &#123; transationService.addArea(&quot;xyz&quot;); transationService.addGoods(&quot;xyzGoods&quot;); &#125; catch (Exception e) &#123; &#125; &#125; @Transactional() public int addArea(String name) &#123; int i = areaService.insertOne(name); return i; &#125; @Transactional(propagation = Propagation.NESTED) public void addGoods(String name) &#123; int i = goodsService.insertOne(name); if (true) throw new RuntimeException(&quot;ssf&quot;); &#125; @Autowired private PlatformTransactionManager platformTransactionManager; public void xxx() &#123; DefaultTransactionDefinition defaultTransactionDefinition = new DefaultTransactionDefinition(); defaultTransactionDefinition.setPropagationBehavior(0); TransactionStatus transaction = platformTransactionManager.getTransaction(defaultTransactionDefinition); try &#123; System.out.println(&quot;业务代码&quot;); &#125; catch (Exception e) &#123; platformTransactionManager.rollback(transaction); &#125; platformTransactionManager.commit(transaction); &#125;&#125; 入口回想下Spring要使用AOP需要什么？需要一个入口类，这个入口类是通过注解@EnableAspectJAutoProxy()引入的。在Spring中要使用事物注解的话就要加上@EnableTransactionManagement注解。看下这个注解的定义： 1234567891011@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(&#123;TransactionManagementConfigurationSelector.class&#125;)public @interface EnableTransactionManagement &#123; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default 2147483647;&#125; 所以事物的入口类是TransactionManagementConfigurationSelector，看下类图 它实现了ImportSelector接口，也就是说，在BeanDefinition的创建阶段，会执行selectImports方法。看源码： 12345678910111213141516171819202122232425262728293031//AdviceModeImportSelectorpublic final String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; Class&lt;?&gt; annType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class); Assert.state(annType != null, &quot;Unresolvable type argument for AdviceModeImportSelector&quot;); AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType); if (attributes == null) &#123; throw new 。。。。。 &#125; AdviceMode adviceMode = attributes.getEnum(getAdviceModeAttributeName()); String[] imports = selectImports(adviceMode); if (imports == null) &#123; throw new IllegalArgumentException(&quot;Unknown AdviceMode: &quot; + adviceMode); &#125; return imports;&#125;//TransactionManagementConfigurationSelector@Overrideprotected String[] selectImports(AdviceMode adviceMode) &#123; switch (adviceMode) &#123; case PROXY: return new String[] &#123;AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()&#125;; case ASPECTJ: return new String[] &#123;determineTransactionAspectClass()&#125;; default: return null; &#125;&#125; 默认值是：AdviceMode mode() default AdviceMode.PROXY; 所以向Spring中注入了两个类，AutoProxyRegistrar和ProxyTransactionManagementConfiguration AutoProxyRegistrarAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar，所以registerBeanDefinitions方法一定会被执行的，看源码： 12345678910111213141516171819202122232425262728//AutoProxyRegistrar@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; boolean candidateFound = false; Set&lt;String&gt; annTypes = importingClassMetadata.getAnnotationTypes(); for (String annType : annTypes) &#123; AnnotationAttributes candidate = AnnotationConfigUtils.attributesFor(importingClassMetadata, annType); if (candidate == null) &#123; continue; &#125; Object mode = candidate.get(&quot;mode&quot;); // 设置是否使用Cglib，默认为false，表示使用jdk的动态代理，但如果目标类没有实现接口，那只能使用cglib了 Object proxyTargetClass = candidate.get(&quot;proxyTargetClass&quot;); if (mode != null &amp;&amp; proxyTargetClass != null &amp;&amp; AdviceMode.class == mode.getClass() &amp;&amp; Boolean.class == proxyTargetClass.getClass()) &#123; candidateFound = true; if (mode == AdviceMode.PROXY) &#123; //注册aop的入口类InfrastructureAdvisorAutoProxyCreator AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry); if ((Boolean) proxyTargetClass) &#123; //把属性设置到入口类中，最终会copy到proxyFactory中 AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); return; &#125; &#125; &#125; &#125;&#125; 最重要的代码为 1AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry); 跟踪代码 12345@Nullablepublic static BeanDefinition registerAutoProxyCreatorIfNecessary( BeanDefinitionRegistry registry, @Nullable Object source) &#123; return registerOrEscalateApcAsRequired(InfrastructureAdvisorAutoProxyCreator.class, registry, source);&#125; 也就是注册了InfrastructureAdvisorAutoProxyCreator，看下它的类图： 可以看到，它的父类为AbstractAdvisorAutoProxyCreater，这个类在AOP中讲过。它的作用就是收集切面、切面匹配和代理类的生成。其实@Transactional就是需要为对象生成一个切面，这是AOP的一个运用。ProxyTransactionManagementConfiguration就是引入事务切面的。如果项目中有使用AOP，也就是引入了AnnotationAwareAspectJAutoProxyCreater，那也是能收集到这个事务切面的。而在@EnableTransactionManagement注解引入这个类的目的就是在没用使用AOP的时候，能收集到事务注解。但收集的切面范围不同，AOP的AnnotationAwareAspectJAutoProxyCreator这个类能收集全部切面，而InfrastructureAdvisorAutoProxyCreator只能收集到事务切面。这个限制的代码为： 123456// InfrastructureAdvisorAutoProxyCreator@Overrideprotected boolean isEligibleAdvisorBean(String beanName) &#123; return (this.beanFactory != null &amp;&amp; this.beanFactory.containsBeanDefinition(beanName) &amp;&amp; this.beanFactory.getBeanDefinition(beanName).getRole() == BeanDefinition.ROLE_INFRASTRUCTURE);&#125; 这块代码是在收集切面的代码中调用的，也就是BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans方法，调用的地方就是 这个isEligibleBean最终会调用isEligibleAdvisorBean。这个方法的默认实现为 123protected boolean isEligibleBean(String beanName) &#123; return true;&#125; 回到isEligibleAdvisorBean,方法中的 1this.beanFactory.getBeanDefinition(beanName).getRole() == BeanDefinition.ROLE_INFRASTRUCTURE) 这个就是用来判断是否系统的事务切面的。这至于为什么这么说，往下看。 ProxyTransactionManagementConfiguration1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configuration(proxyBeanMethods = false)@Role(BeanDefinition.ROLE_INFRASTRUCTURE)public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration &#123; @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME) // 设置这个BeanDefinition的Role属性为BeanDefinition.ROLE_INFRASTRUCTURE @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor( TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor) &#123; //创建事务切面 BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor(); //切面里面设置处理事务属性对象 advisor.setTransactionAttributeSource(transactionAttributeSource); //设置切面的advice advisor.setAdvice(transactionInterceptor); //设置切面排序 if (this.enableTx != null) &#123; advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;)); &#125; return advisor; &#125; @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionAttributeSource transactionAttributeSource() &#123; //创建事务属性处理器 return new AnnotationTransactionAttributeSource(); &#125; @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public TransactionInterceptor transactionInterceptor(TransactionAttributeSource transactionAttributeSource) &#123; //创建事务切面，MethodInterceptor的实现 TransactionInterceptor interceptor = new TransactionInterceptor(); //事务属性处理器设置到advice中 interceptor.setTransactionAttributeSource(transactionAttributeSource); //把事务管理器设置到advice中 if (this.txManager != null) &#123; interceptor.setTransactionManager(this.txManager); &#125; return interceptor; &#125;&#125; 可以看到，这个类的作用就简单明了，就是引入一个Bean而已，而这些Bean就是一个事物切面。 看transactionInterceptor，有个txManager，看下这个txManager是怎么注入的，跟踪代码，在它的父类中： 1234567891011@Autowired(required = false)void setConfigurers(Collection&lt;TransactionManagementConfigurer&gt; configurers) &#123; if (CollectionUtils.isEmpty(configurers)) &#123; return; &#125; if (configurers.size() &gt; 1) &#123; throw new IllegalStateException(&quot;Only one TransactionManagementConfigurer may exist&quot;); &#125; TransactionManagementConfigurer configurer = configurers.iterator().next(); this.txManager = configurer.annotationDrivenTransactionManager();&#125; 这里的代码意思就是，比如我定义一个类： 12345678910111213@Componentpublic class TransactionManagementConfigurerBean implements TransactionManagementConfigurer &#123; @Autowired private DataSource dataSource; @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; DataSourceTransactionManager dtm = new DataSourceTransactionManager(); dtm.setDataSource(dataSource); return dtm; &#125;&#125; 它实现了TransactionManagementConfigurer接口，那么在上一段代码中就能通过我们自定义的TransactionManagementConfigurer拿到事务管理器。不过这种方式不是必须的，就算在txManager&#x3D;&#x3D;null，在调用过程中也能拿到事务管理器。 总之，ProxyTransactionManagementConfiguration这个类的主要作用就是注册一个BeanFactoryTransactionAttributeSourceAdvisor切面。这个切面的Pointcut需要看BeanFactoryTransactionAttributeSourceAdvisor。从源码可值，pointcut的创建如下： 12345678//定义事务切面的pointCutprivate final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() &#123; @Override @Nullable protected TransactionAttributeSource getTransactionAttributeSource() &#123; return transactionAttributeSource; &#125;&#125;; Advice是：TransactionInterceptor。而且还包含一个AnnotationTransactionAttributeSource。而且这些@Bean进来的bean有加了一个Role注解，而且值为BeanDefinition.ROLE_INFRASTRUCTURE。所以在上节中，最后的问题的答案就在这了。 在Spring Bean的初始化最后都会去检查这个类是否匹配到切面的，判断是否匹配的依据就是pointcut。而切面的逻辑又封装在Advice中。 所以只要看BeanFactoryTransactionAttributeSourceAdvisor的TransactionAttributeSourcePointcut和TransactionInterceptor就好了。 TransactionAttributeSourcePointcut这里先回忆下Pointcut的作用，有3个 用ClassFilter接口进行类匹配 用MethodMatcher接口进行方法匹配 当MethodMatcher的isRunntime方法返回true时在增强方法调用时进行参数匹配 现在看这个类的类图： 从类图可知，这个类既是Pointcut也是MethodMatcher。看这个类的构造方法 ClassFilter是TransactionAttributeSourceClassFilter，而这个类是内部类，看定义： 12345678910111213private class TransactionAttributeSourceClassFilter implements ClassFilter &#123; @Override public boolean matches(Class&lt;?&gt; clazz) &#123; if (TransactionalProxy.class.isAssignableFrom(clazz) || TransactionManager.class.isAssignableFrom(clazz) || PersistenceExceptionTranslator.class.isAssignableFrom(clazz)) &#123; return false; &#125; TransactionAttributeSource tas = getTransactionAttributeSource(); return (tas == null || tas.isCandidateClass(clazz)); &#125;&#125; 在这里说下这ClassFilter的作用吧，其实跟踪源码就可以知道，这个ClassFilter其实没什么卵用，它会进行一些不痛不痒的判断，判断下class对象是否是java.开头的的。所以判断是否匹配的还是看MethodMatcher。看matches方法。 1234567// TransactionAttributeSourcePointcut@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; TransactionAttributeSource tas = getTransactionAttributeSource(); //只要方法上面能拿到事务属性就返回true，就生成代理 return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);&#125; 从上面的分析中getTransactionAttributeSource()方法会返回AnnotationTransactionAttributeSource对象。其实这个不用分析都可以知道，只要某个方法上有@Transactional这个注解就放回true了。跟踪源码，由于AnnotationTransactionAttributeSource没有重写getTransactionAttribute这个方法，所以看他的父类 AbstractFallbackTransactionAttributeSource 1234567891011121314151617181920212223242526272829303132333435363738394041public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; if (method.getDeclaringClass() == Object.class) &#123; return null; &#125; // First, see if we have a cached value. Object cacheKey = getCacheKey(method, targetClass); TransactionAttribute cached = this.attributeCache.get(cacheKey); if (cached != null) &#123; // Value will either be canonical value indicating there is no transaction attribute, // or an actual transaction attribute. if (cached == NULL_TRANSACTION_ATTRIBUTE) &#123; return null; &#125; else &#123; return cached; &#125; &#125; else &#123; // We need to work it out. TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass); // Put it in the cache. if (txAttr == null) &#123; this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE); &#125; else &#123; String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass); if (txAttr instanceof DefaultTransactionAttribute) &#123; ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification); &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Adding transactional method &#x27;&quot; + methodIdentification + &quot;&#x27; with attribute: &quot; + txAttr); &#125; this.attributeCache.put(cacheKey, txAttr); &#125; return txAttr; &#125;&#125;protected Object getCacheKey(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; return new MethodClassKey(method, targetClass);&#125; 这段代码，先生成cacheKey，然后从缓存中，缓存没有就调用computeTransactionAttribute方法，看这个方法。 123456789101112131415161718192021222324252627282930313233343536373839404142protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) &#123; // Don&#x27;t allow no-public methods as required. // 如果是非public方法，则返回null不会生成代理，allowPublicMethodsOnly()在AnnotationTransactionAttributeSource中重写了 // 默认传了个true if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123; return null; &#125; // The method may be on an interface, but we need attributes from the target class. // If the target class is null, the method will be unchanged. // 获取原始方法，因为这个method对象可能是从接口的class对象上获取的，接口上的method没有注解 Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); // First try is the method in the target class. //获取方法上面的@Transactional注解的属性 TransactionAttribute txAttr = findTransactionAttribute(specificMethod); if (txAttr != null) &#123; return txAttr; &#125; //如果方法上面没有@Transactional注解，则去找类上面是否有@Transactional注解 // Second try is the transaction attribute on the target class. txAttr = findTransactionAttribute(specificMethod.getDeclaringClass()); if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAttr; &#125; if (specificMethod != method) &#123; // Fallback is to look at the original method. txAttr = findTransactionAttribute(method); if (txAttr != null) &#123; return txAttr; &#125; // Last fallback is the class of the original method. txAttr = findTransactionAttribute(method.getDeclaringClass()); if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAttr; &#125; &#125; return null;&#125; 看看这行代码 1234// 只允许publicif (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123; return null;&#125; 这行代码直接限制了@Transactional只能加载public修饰的方法上。接着执行了这样代码: 12//获取原始方法，因为这个method对象可能是从接口的class对象上获取的，接口上的method没有注解Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); 在上一节已经介绍了这行代码的作用了为什么这样做。接着是下面代码 1TransactionAttribute txAttr = findTransactionAttribute(specificMethod); 这行就是获取方法上@Transaction注解，并把注解的属性填充到RuleBasedTransactionAttribute对象中。 上面这些都都是方法上的，但有时方法上没注解，而类上有@Transactional注解，所以这时还会有一个检查类上的注解的逻辑。这段代码即完成这逻辑的。 1234txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAttr;&#125; 当TransactionAttribute创建完成后，computeTransactionAttribute返回后，在getTransactionAttribute方法中会把TransactionAttribute对象保存到缓存attributeCache中。所以，知道getTransactionAttribute中找到@Transaction注解，那就意味着某个类的某个方法匹配到事物切面。 简单看下findTransactionAttribute(Method method)方法 12AnnotationTransactionAttributeSource#findTransactionAttribute ——&gt; AnnotationTransactionAttributeSource#determineTransactionAttribute 12345678910//AnnotationTransactionAttributeSource#determineTransactionAttributeprotected TransactionAttribute determineTransactionAttribute(AnnotatedElement element) &#123; for (TransactionAnnotationParser parser : this.annotationParsers) &#123; TransactionAttribute attr = parser.parseTransactionAnnotation(element); if (attr != null) &#123; return attr; &#125; &#125; return null;&#125; annotationParsers这个属性的初始化是在AnnotationTransactionAttributeSource创建时初始化的，默认情况下 只会走到红款的代码。继续跟踪代码 1SpringTransactionAnnotationParser.parseTransactionAnnotation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//SpringTransactionAnnotationParser@Override@Nullable// 把@Transactional转换成TransactionAttribute对象public TransactionAttribute parseTransactionAnnotation(AnnotatedElement element) &#123; AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes( element, Transactional.class, false, false); if (attributes != null) &#123; //解析Transactional注解中的属性，并封装成对象 return parseTransactionAnnotation(attributes); &#125; else &#123; return null; &#125;&#125;protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) &#123; RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute(); Propagation propagation = attributes.getEnum(&quot;propagation&quot;); rbta.setPropagationBehavior(propagation.value()); Isolation isolation = attributes.getEnum(&quot;isolation&quot;); rbta.setIsolationLevel(isolation.value()); rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;).intValue()); rbta.setReadOnly(attributes.getBoolean(&quot;readOnly&quot;)); // 这里把@Transactional中的value设置到TransactionAttribute的qualifier属性中 // @Transactional中的value对应的是事务管理器的beanName rbta.setQualifier(attributes.getString(&quot;value&quot;)); List&lt;RollbackRuleAttribute&gt; rollbackRules = new ArrayList&lt;&gt;(); for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;rollbackFor&quot;)) &#123; rollbackRules.add(new RollbackRuleAttribute(rbRule)); &#125; for (String rbRule : attributes.getStringArray(&quot;rollbackForClassName&quot;)) &#123; rollbackRules.add(new RollbackRuleAttribute(rbRule)); &#125; for (Class&lt;?&gt; rbRule : attributes.getClassArray(&quot;noRollbackFor&quot;)) &#123; rollbackRules.add(new NoRollbackRuleAttribute(rbRule)); &#125; for (String rbRule : attributes.getStringArray(&quot;noRollbackForClassName&quot;)) &#123; rollbackRules.add(new NoRollbackRuleAttribute(rbRule)); &#125; rbta.setRollbackRules(rollbackRules); return rbta;&#125; 从上边的源码看到TransactionAttribute就是@Transaction注解的抽象，包含了注解的全部属性。 TransactionAttribute有一个属性需要关注下 1rbta.setQualifier(attributes.getString(&quot;value&quot;)); 这里把@Transactional中的value设置到TransactionAttribute的qualifier属性中 而@Transactional中的value对应的是事务管理器的beanName TransactionInterceptor看adivce只要看invoke方法就好了 1234567public Object invoke(MethodInvocation invocation) throws Throwable &#123; Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);&#125; 看invokeWithinTransaction方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// TransactionAspectSupportprotected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123; // If the transaction attribute is null, the method is non-transactional. //获取事务属性类 这里返回的是AnnotationTransactionAttributeSource TransactionAttributeSource tas = getTransactionAttributeSource(); //获取事务属性，这里前面就解析过了，在这里会从缓存中拿到该对象。 final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); //获取事务管理器， // 1. 这里先看@Transactional的value值是有有值，有的话就从BeanFactory中拿到对应的事物管理器 // 2. 没有值就获取一个默认的，会通过beanFactory.getBean(TransactionManager.class)这样获取事务管理 // 1和2获取到的事务管理都会放到一个ConcurrentMap&lt;Object, TransactionManager&gt;中，之后就从缓存中拿 // 如果这一步没有获取到TransactionManager，这里会抛出错误 final TransactionManager tm = determineTransactionManager(txAttr); if (this.reactiveAdapterRegistry != null &amp;&amp; tm instanceof ReactiveTransactionManager) &#123; //这里好像是响应式编程的代码 ... &#125; // 这里校验事务管理器的对象是否PlatformTransactionManager，否则会抛出错误 PlatformTransactionManager ptm = asPlatformTransactionManager(tm); //获取到有注解的方法名称 final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); //注解事务会走这里 if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. //开启事务 TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. //火炬传递 retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception //事务回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123; // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null &amp;&amp; txAttr != null) &#123; retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status); &#125; &#125; //事务提交 commitTransactionAfterReturning(txInfo); return retVal; &#125; else &#123; //不是核心逻辑，省略 ... &#125;&#125; 从上面可知InvocationCallback invocation = invocation::proceed，所以invocation对象的作用就是进行火炬传递的。 上面的代码一行行看。先看这个 根据前面，这里就是从缓存中获取TransactionAttribute，也就是事物注解的属性对象。 这代码就是获取事物管理器的，看事物管理怎么获取的。 123456789101112131415161718protected TransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) &#123; //非关键代码 .... else &#123; //从advice中获取事务管理器 TransactionManager defaultTransactionManager = getTransactionManager(); if (defaultTransactionManager == null) &#123; defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY); if (defaultTransactionManager == null) &#123; //从spring容器中获取事务管理器 defaultTransactionManager = this.beanFactory.getBean(TransactionManager.class); this.transactionManagerCache.putIfAbsent( DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager); &#125; &#125; return defaultTransactionManager; &#125;&#125; 整段代码只看else就好了。这段代码的意思就是。我这样创建一个事物管理器后，可以从上面的代码中获取到。 123456@Beanpublic PlatformTransactionManager annotationDrivenTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager dtm = new DataSourceTransactionManager(); dtm.setDataSource(dataSource); return dtm;&#125; 现在开始看核心代码，这个代码的就是整个事物切面的核心！ 123456789101112131415161718192021222324252627282930313233343536final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);//注解事务会走这里if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. //开启事务 TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification); Object retVal; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. //火炬传递 retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception //事务回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; if (retVal != null &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123; // Set rollback-only in case of Vavr failure matching our rollback rules... TransactionStatus status = txInfo.getTransactionStatus(); if (status != null &amp;&amp; txAttr != null) &#123; retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status); &#125; &#125; //事务提交 commitTransactionAfterReturning(txInfo); return retVal;&#125; 先回忆下，在数据库中开启事物是怎么样的 12345678910111213begin;//do somethingcommit或者rollback//下面是jdbc的规范中，开启事物的伪代码Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);connection.setAutoCommit(false);//do somethingconnection.commit(); 或者 connection.rollback();connection.setAutoCommit(false); 这样代码相当于beginconnection.commit(); 或者 connection.rollback();就是commit或者rollback了 而Spring的事物管理器也是遵循JDBC规范的，所以Spring的事物处理代码和伪代码的逻辑都是一样的。 下面就看这个逻辑来讲解代码 开启事物下面就是开启事物的代码： 12345678910111213141516171819// TransactionAspectSupportprotected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, final String joinpointIdentification) &#123; .... TransactionStatus status = null; if (txAttr != null) &#123; if (tm != null) &#123; //开启事务，这里重点看 status = tm.getTransaction(txAttr); &#125; else &#123; .... &#125; &#125; //创建事务信息对象，记录新老事务信息对象 return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);&#125; 这个事务管理器，我们重点看DataSourceTransactionManager，因为这是常用的。好了，现在看getTransaction方法: getTransaction12345678910111213141516171819202122232425262728293031323334353637383940414243444546// AbstractPlatformTransactionManagerpublic final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // Use defaults if no transaction definition given. TransactionDefinition def = (definition != null ? definition : TransactionDefinition.withDefaults()); //这里重点看，拿到DataSourceTransactionObject对象 Object transaction = doGetTransaction(); boolean debugEnabled = logger.isDebugEnabled(); //第一次进来connectionHolder为空的，所以不存在事务 if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. //如果不是第一次进来，则会走这个逻辑，重点看 return handleExistingTransaction(def, transaction, debugEnabled); &#125; //一些校验 .... //第一次进来大部分会走这里 else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; //先挂起 SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) &#123; logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def); &#125; try &#123; return startTransaction(def, transaction, debugEnabled, suspendedResources); &#125; catch (RuntimeException | Error ex) &#123; resume(null, suspendedResources); throw ex; &#125; &#125; else &#123; // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization. if (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123; logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; + &quot;isolation level will effectively be ignored: &quot; + def); &#125; boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(def, null, true, newSynchronization, debugEnabled, null); &#125;&#125; 先看这行代码 1234567891011121314// AbstractPlatformTransactionManager// 拿到DataSourceTransactionObject对象Object transaction = doGetTransaction();// DataSourceTransactionManagerObject doGetTransaction() &#123; DataSourceTransactionObject txObject = new DataSourceTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); //这个代码是从ThreadLocal中获取到连接对象 ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource()); txObject.setConnectionHolder(conHolder, false); return txObject;&#125; 这里的DataSourceTransactionObject对象看下它有什么属性和方法。 这个对象从属性上看就是一个数据库链接对象的包装对象，包含了链接对象、只读标记、是否新建的Connect等信息；还有包含了创建savepoint方法、回滚某个savepoint方法等 看代码： 123//这个代码是从ThreadLocal中获取到连接对象ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource()); 先看obtainDataSource: 12345678910// DataSourceTransactionManagerprotected DataSource obtainDataSource() &#123; DataSource dataSource = getDataSource(); Assert.state(dataSource != null, &quot;No DataSource set&quot;); return dataSource;&#125;// 所以Spring的事物就是事物的搬运工而已，它不管处理逻辑public DataSource getDataSource() &#123; return this.dataSource;&#125; 这个dataSource，有很多来源，比如HikariCP、Druid、C3P0。而dataSource的初始化是PlatformTransactionManager的初始化时传入的。也就是 而TransactionSynchronizationManager.getResource这里简单的说就是从一个ThreadLocal中拿ConnectionHolder，ThreadLocal没有就返回null。而第一次进来的话是肯定为null的。 回到doGetTransaction‘ 123// DataSourceTransactionManager// DataSourceTransactionObjecttxObject.setConnectionHolder(conHolder, false); 通过这个方法，把前面拿到的ConnectionHolder设置进DataSourceTransactionObject中，并把DataSourceTransactionObject的newConnectHolder设置为false。最后doGetTransaction就把DataSourceTransactionObject对象返回。 回到AbstractPlatformTransactionManager#getTransaction方法。 现在Object transaction = doGetTransaction();代码返回了一个DataSourceTransactionObject对象。接着执行了下面代码: 1234567// AbstractPlatformTransactionManager// 第一次进来connectionHolder为空的，所以不存在事务if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. // 如果不是第一次进来，则会走这个逻辑，重点看 return handleExistingTransaction(def, transaction, debugEnabled);&#125; 这个isExistingTransaction 1234567// DataSourceTransactionManager@Overrideprotected boolean isExistingTransaction(Object transaction) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; //如果事务对象中有连接且是active的，则说明之前存在事务 return (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());&#125; 就是从两个维度判断的 判断ConnectionHolder是否为null 如果第一步不为null就判断ConnectionHolder的事物是否活跃。 第一次进来的话DataSourceTransactionObject的connecttionHolder是为null的，所以，这个方法会放回false的，所以先看getTransaction后面的代码 1234567891011121314151617181920// AbstractPlatformTransactionManager.getTransaction// 第一次进来大部分会走这里else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; //先挂起，这里只对PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED有用 SuspendedResourcesHolder suspendedResources = suspend(null); if (debugEnabled) &#123; logger.debug(&quot;Creating new transaction with name [&quot; + def.getName() + &quot;]: &quot; + def); &#125; try &#123; return startTransaction(def, transaction, debugEnabled, suspendedResources); &#125; catch (RuntimeException | Error ex) &#123; resume(null, suspendedResources); throw ex; &#125;&#125;// 其他事物传播属性就不看了...... 这段代码就涉及到事物传播属性了。先看下这个事务传播属性 事务传播下一节讲 先看 1234567891011121314// AbstractPlatformTransactionManagerprivate TransactionStatus startTransaction(TransactionDefinition definition, Object transaction, boolean debugEnabled, @Nullable SuspendedResourcesHolder suspendedResources) &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); //创建一个新的事务状态，注意这里的 newTransaction 属性为 true了 DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); //开启事务,重点看看 DataSourceTransactionObject doBegin(transaction, definition); //开启事务后，改变事务状态 prepareSynchronization(status, definition); return status;&#125; 先创建了一个DefaultTransactionStatus对象，表示当前事务的状态。这个对象你面有事务的状态属性，比如是否新的，是否挂起，是否readOnly，有一点要注意，在这里，DefaultTransactionStatus中的newTransaction&#x3D;true的，这一点很重要。接着就是doBegin，从方法名就知道，就是开启事物的。 doBegin1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// DataSourceTransactionManagerprotected void doBegin(Object transaction, TransactionDefinition definition) &#123; //事务对象 DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; Connection con = null; try &#123; // 判断事务对象中有没有连接 if (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123; //事务管理器中拿dataSource对象，从dataSource中拿连接对象 。。这里可能是AbstractRoutingDataSource的数据源 Connection newCon = obtainDataSource().getConnection(); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Acquired Connection [&quot; + newCon + &quot;] for JDBC transaction&quot;); &#125; //把连接对象设置到事务对象中 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); &#125; //设置有事务标识 txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); //设置是否只读连接和设置事务隔离级别 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); //设置该连接的上一个隔离级别 txObject.setPreviousIsolationLevel(previousIsolationLevel); txObject.setReadOnly(definition.isReadOnly()); //如果是自动提交 if (con.getAutoCommit()) &#123; // 设置标记，表示最后一定要把链接对象的自动提交打开 txObject.setMustRestoreAutoCommit(true); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;); &#125; //把自动提交关闭，因为提交要交给spring来做 con.setAutoCommit(false); &#125; //执行只读事务命令 prepareTransactionalConnection(con, definition); //把事务状态设置为true txObject.getConnectionHolder().setTransactionActive(true); //获取事务超时时间 int timeout = determineTimeout(definition); if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123; txObject.getConnectionHolder().setTimeoutInSeconds(timeout); &#125; // Bind the connection holder to the thread. //如果是一个新事务，这建立数据源对象和连接对象的绑定关系.且把该绑定关系的map设置到ThreadLocal中 if (txObject.isNewConnectionHolder()) &#123; TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder()); &#125; &#125; catch (Throwable ex) &#123; ..... &#125;&#125; 这代码看注解就好了，我在这总结下 由于第一次进来的时候，没有从ThreadLocal中获取到链接，所以会通过通过dataSource获取链接对象，并把链接对象包装成ConnectionHolder，然后赋值给DataSourceTransactionObject，并把DataSourceTransactionObject的新创建的Connection属性newConnectionHolder设置为true(这里对象里的connectionHolder属性第一次进来的时候是null的) 设置是否只读和设置事务隔离级别，在设置事务隔离级别的时候会记录链接对象的事务隔离级别（数据库默认的），然后把这个隔离级别设置到DataSourceTransactionObject对象的previousIsolationLevel属性中（这是为了恢复链接对象的隔离级别）。 把自动提交关闭 执行只读事务命令stmt.executeUpdate(&quot;SET TRANSACTION READ ONLY&quot;); 把DataSourceTransactionObject对象的事务活跃标记设置为true 判断这个ConnectionHolder是否新建的（判断DataSourceTransactionObject.newConnectionHolder属性是否为true。在第一步设置为true了），如果是就建立&lt;dataSource, connectionHolder&gt;这种对应关系，并把这个对应关系放入到ThreadLocal resources中。 doBegin执行完后执行了prepareSynchronization，这个方法就是设置下TransactionSynchronizationManager中ThreadLocal的值，这样我们在业务代码中就可以使用TransactionSynchronizationManager来获取属性了。 123456789101112131415// AbstractPlatformTransactionManagerprepareSynchronization(status, definition);protected void prepareSynchronization(DefaultTransactionStatus status, TransactionDefinition definition) &#123; // DefaultTransactionStatus在第一次创建的时候，newSynchronization设置为true了 if (status.isNewSynchronization()) &#123; TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction()); TransactionSynchronizationManager.setCurrentTransactionIsolationLevel( definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ? definition.getIsolationLevel() : null); TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly()); TransactionSynchronizationManager.setCurrentTransactionName(definition.getName()); TransactionSynchronizationManager.initSynchronization(); &#125;&#125; 最后把DefaultTransactionStatus对象返回。回到TransactionAspectSupport.createTransactionIfNecessary，把返回值对象设置给了status变量。最后执行了一步： 这个方法就是封装TransactionInfo对象。TransactionAspectSupport.createTransactionIfNecessary也执行完了，返回了一个TransactionInfo对象。 火炬传递 之前就说过，invocation &#x3D; invocation::proceed，所以这里的方法调用就是执行了invocation::proceed，这个方法的作用在AOP的调用中就已经说过了。最终会调用到目标对象的业务方法，执行事务逻辑。 事务提交在没错误发生时就进行了事物提交。 跟踪代码 事务提交方法中的回滚123456789101112131415161718192021222324252627282930313233343536373839// TransactionAspectSupportprotected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) &#123; if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Completing transaction for [&quot; + txInfo.getJoinpointIdentification() + &quot;]&quot;); &#125; // 或返回DataSourceTransactionManager txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); &#125;&#125;// AbstractPlatformTransactionManager@Overridepublic final void commit(TransactionStatus status) throws TransactionException &#123; if (status.isCompleted()) &#123; throw new IllegalTransactionStateException( &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;); &#125; DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status; // 这里要注意，这里执行了回滚操作，因为有一个方法抛出错误了 if (defStatus.isLocalRollbackOnly()) &#123; if (defStatus.isDebug()) &#123; logger.debug(&quot;Transactional code has requested rollback&quot;); &#125; processRollback(defStatus, false); return; &#125; if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123; if (defStatus.isDebug()) &#123; logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;); &#125; processRollback(defStatus, true); return; &#125; //执行事务提交 processCommit(defStatus);&#125; 在这段代码中，发现有可能会执行一个方法processRollback。这个方法是用来做事务回滚的。居然在commit代码中会发生回滚，现在看下发生回滚的条件。 就是DefaultTransactionStatus中的rollbackOnly属性设置为true了。而只能通过DefaultTransactionStatus对象的setRollbackOnly()方法把rollbackOnly设置为true。 第二种情况需要满足两个条件。第一，需要检查AbstractPlatformTransactionManager#shouldCommitOnGlobalRollbackOnly() 方法返回值是否为false，该方法的默认实现的返回值为false。第二，通过DefaultTransactionStatus，检查DataSourceTransactionObject中的ConnectionHolder对象的rollbackOnly属性是否为true。 满足上边的两种情况的某一个，都会触发在conmit方法中调用rollback逻辑。而怎么触发条件，在事务传播属性中讲 从第二中情况看DefaultTransactionStatus、DataSourceTransactionObject和ConnectionHolder的关系。从包含关系看，它们的关系是这样的： 执行事务提交1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// AbstractPlatformTransactionManagerprivate void processCommit(DefaultTransactionStatus status) throws TransactionException &#123; try &#123; boolean beforeCompletionInvoked = false; try &#123; boolean unexpectedRollback = false; prepareForCommit(status); //调用beforeCommit方法，事务提交之前做业务处理 triggerBeforeCommit(status); triggerBeforeCompletion(status); beforeCompletionInvoked = true; //如果有回滚点 if (status.hasSavepoint()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Releasing transaction savepoint&quot;); &#125; unexpectedRollback = status.isGlobalRollbackOnly(); status.releaseHeldSavepoint(); &#125; //如果是新事务，则提交事务 else if (status.isNewTransaction()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Initiating transaction commit&quot;); &#125; unexpectedRollback = status.isGlobalRollbackOnly(); doCommit(status); &#125; else if (isFailEarlyOnGlobalRollbackOnly()) &#123; unexpectedRollback = status.isGlobalRollbackOnly(); &#125; // Throw UnexpectedRollbackException if we have a global rollback-only // marker but still didn&#x27;t get a corresponding exception from commit. if (unexpectedRollback) &#123; throw new UnexpectedRollbackException( &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;); &#125; &#125; catch (UnexpectedRollbackException ex) &#123; // can only be caused by doCommit triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK); throw ex; &#125; catch (TransactionException ex) &#123; // can only be caused by doCommit if (isRollbackOnCommitFailure()) &#123; doRollbackOnCommitException(status, ex); &#125; else &#123; triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); &#125; throw ex; &#125; catch (RuntimeException | Error ex) &#123; if (!beforeCompletionInvoked) &#123; triggerBeforeCompletion(status); &#125; doRollbackOnCommitException(status, ex); throw ex; &#125; // Trigger afterCommit callbacks, with an exception thrown there // propagated to callers but the transaction still considered as committed. try &#123; //触发afterCommit方法，事务提交后做业务处理 triggerAfterCommit(status); &#125; finally &#123; triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED); &#125; &#125; finally &#123; //处理挂起事务，在这里恢复绑定关系 cleanupAfterCompletion(status); &#125;&#125;protected void doCommit(DefaultTransactionStatus status) &#123; DataSourceTransactionManager.DataSourceTransactionObject txObject = (DataSourceTransactionManager.DataSourceTransactionObject)status.getTransaction(); Connection con = txObject.getConnectionHolder().getConnection(); try &#123; con.commit(); &#125; catch (SQLException var5) &#123; throw new TransactionSystemException(&quot;Could not commit JDBC transaction&quot;, var5); &#125;&#125; 这段代码就只有一处有doCommit，所以重点看这里（其他）： 这段代码很简单，就是判断DefaultTransactionStatus.newTransaction属性是否为true，为true就提交了。在上面已经强调过了DefaultTransactionStatus.newTransaction属性，在对象刚创建的时候就是设置为true的。而从代码也可以得出，DefaultTransactionStatus.newTransaction这个属性是用来控制事务提交的。 事务回滚回到TransactionAspectSupport，当火炬传递出错时，就会执行下面的代码 跟踪代码，到： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// AbstractPlatformTransactionManagerprivate void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123; try &#123; boolean unexpectedRollback = unexpected; try &#123; triggerBeforeCompletion(status); //如果有回滚点，如果是嵌套事务 if (status.hasSavepoint()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Rolling back transaction to savepoint&quot;); &#125; status.rollbackToHeldSavepoint(); &#125; //如果是新事务，newTransaction 为true的情况下才回滚 else if (status.isNewTransaction()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Initiating transaction rollback&quot;); &#125; doRollback(status); &#125; else &#123; // Participating in larger transaction if (status.hasTransaction()) &#123; if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;); &#125; doSetRollbackOnly(status); &#125; else &#123; if (status.isDebug()) &#123; logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;); &#125; &#125; &#125; else &#123; logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;); &#125; // Unexpected rollback only matters here if we&#x27;re asked to fail early if (!isFailEarlyOnGlobalRollbackOnly()) &#123; unexpectedRollback = false; &#125; &#125; &#125; catch (RuntimeException | Error ex) &#123; triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); throw ex; &#125; triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK); // Raise UnexpectedRollbackException if we had a global rollback-only marker if (unexpectedRollback) &#123; throw new UnexpectedRollbackException( &quot;Transaction rolled back because it has been marked as rollback-only&quot;); &#125; &#125; finally &#123; cleanupAfterCompletion(status); &#125;&#125;protected void doRollback(DefaultTransactionStatus status) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction(); Connection con = txObject.getConnectionHolder().getConnection(); if (status.isDebug()) &#123; logger.debug(&quot;Rolling back JDBC transaction on Connection [&quot; + con + &quot;]&quot;); &#125; try &#123; con.rollback(); &#125; catch (SQLException ex) &#123; throw new TransactionSystemException(&quot;Could not roll back JDBC transaction&quot;, ex); &#125;&#125; 和提交一样，都是通过DefaultTransactionStatus.newTransaction属性来控制的。最后都是通过Connection对象的rollback方法回滚的。 但这里有一点要说下，就是异常校验 异常校验回到TransactionAspectSupport#completeTransactionAfterThrowing，到这里 txInfo.transactionAttribute就是封装了注解@Transactional的属性对象。在poincut解析@Transcation中可以知道，最后封装成了RuleBasedTransactionAttribute这个对象。我们看下这个rollbackOn方法。 1234567891011121314151617181920212223242526272829303132// RuleBasedTransactionAttribute@Overridepublic boolean rollbackOn(Throwable ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Applying rules to determine whether transaction should rollback on &quot; + ex); &#125; RollbackRuleAttribute winner = null; int deepest = Integer.MAX_VALUE; if (this.rollbackRules != null) &#123; for (RollbackRuleAttribute rule : this.rollbackRules) &#123; int depth = rule.getDepth(ex); if (depth &gt;= 0 &amp;&amp; depth &lt; deepest) &#123; deepest = depth; winner = rule; &#125; &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Winning rollback rule is: &quot; + winner); &#125; // User superclass behavior (rollback on unchecked) if no rule matches. if (winner == null) &#123; logger.trace(&quot;No relevant rollback rule found: applying default rules&quot;); return super.rollbackOn(ex); &#125; return !(winner instanceof NoRollbackRuleAttribute);&#125; 这段代码就是判断哪些错误需要回滚，哪些错误不需要回滚的 其核心代码有三部分 第一部分: 123456789if (this.rollbackRules != null) &#123; for (RollbackRuleAttribute rule : this.rollbackRules) &#123; int depth = rule.getDepth(ex); if (depth &gt;= 0 &amp;&amp; depth &lt; deepest) &#123; deepest = depth; winner = rule; &#125; &#125;&#125; 这段代码中rollbackRules集合的初始化看RuleBasedTransactionAttribute的初始化代码 这个集合只涉及到两个对象RollbackRuleAttribute和NoRollbackRuleAttribute。而NoRollbackRuleAttribute是RollbackRuleAttribute的父类，getDepth方法的逻辑都是在RollbackRuleAttribute中的，看代码 execptionName就是@Transcational的设置的值，就是异常类的完全限定名。而上边的代码就是检查异常类和异常类的父类是否和execptionName匹配，匹配的话就返回深度。如果没有匹配到的情况，那么就会走到第二部分代码 在这一部分代码中，会调用RuleBasedTransactionAttribute父类的rollbackOn方法。 第一部分如果匹配到的情况，就会检查 匹配到的RollbackRuleAttribute是否是NoRollbackRuleAttribute，如果是的话，那就意味着是不需要回滚的，所以最终会返回false。 整段代码的意思就是如如果抛出的异常和配置的异常不匹配，就找父类再和配置的异常匹配，如果这样一直下去还找不到，那就和RuntimeExection和Error比较。如果通过异常类有匹配到，那就检查是否NoRollbackRuleAttribute，如果是就意味着不需要回滚，不是的话就是需要回滚。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"11-Spring中的代理的TargetSource接口的使用","slug":"spring/5.2.8/11-Spring中的代理的TargetSource接口的使用","date":"2021-11-20T12:00:19.000Z","updated":"2022-03-14T09:04:26.116Z","comments":true,"path":"blog/spring/5.2.8/11-Spring中的代理的TargetSource接口的使用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/11-Spring%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E7%9A%84TargetSource%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"TargetSourceSpring中的代理在Spring中所有的代理类都是通过ProxyFactory类的getProxy来生成的，而这个getPorxy会分情况使用JdkDynamicAopProxy或者ObjenesisCglibAopProxy来生成代理对象。这个情况有两个 如果注解的proxyTargetClass = true 或者 proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS&#96; 对象的类有实现接口 如果满足情况1或者两个情况都不瞒住那么就会使用ObjenesisCglibAopProxy（Cglib）来创建代理对象；如果情况1步满足，满足情况2那么会使用JdkDynamicAopProxy（jdk动态代理）来创建代理对象。 这里我只看JdkDynamicAopProxy就好了，ObjenesisCglibAopProxy的逻辑和JdkDynamicAopProxy一样。只是api不同。 看JdkDynamicAopProxy的getProxy方法 123456789101112131415@Overridepublic Object getProxy() &#123; return getProxy(ClassUtils.getDefaultClassLoader());&#125;@Overridepublic Object getProxy(@Nullable ClassLoader classLoader) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource()); &#125; // 获取实现的接口 Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 可以看到，这个Proxy就是使用了JDK的动态代理，而且InvocationHandler就是JdkDynamicAopProxy对象。 所以只要看JdkDynamicAopProxy的invoke方法就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; //从代理工厂中拿到TargetSource对象，该对象包装了被代理实例bean TargetSource targetSource = this.advised.targetSource; Object target = null; try &#123; //被代理对象的equals方法和hashCode方法是不能被代理的，不会走切面 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; // The target does not implement the equals(Object) method itself. return equals(args[0]); &#125; else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123; // The target does not implement the hashCode() method itself. return hashCode(); &#125; else if (method.getDeclaringClass() == DecoratingProxy.class) &#123; // There is only getDecoratedClass() declared -&gt; dispatch to proxy config. return AopProxyUtils.ultimateTargetClass(this.advised); &#125; else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); &#125; Object retVal; //如果该属性设置为true，则把代理对象设置到ThreadLocal中 if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // Get as late as possible to minimize the time we &quot;own&quot; the target, // in case it comes from a pool. //这个target就是被代理实例 target = targetSource.getTarget(); Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null); // Get the interception chain for this method. //从代理工厂中拿过滤器链 Object是一个MethodInterceptor类型的对象，其实就是一个advice对象 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // Check whether we have any advice. If we don&#x27;t, we can fallback on direct // reflective invocation of the target, and avoid creating a MethodInvocation. //如果该方法没有执行链，则说明这个方法不需要被拦截，则直接反射调用 if (chain.isEmpty()) &#123; // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; // We need to create a method invocation... MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. retVal = invocation.proceed(); &#125; // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned &quot;this&quot; and the return type of the method // is type-compatible. Note that we can&#x27;t help if the target sets // a reference to itself in another returned object. retVal = proxy; &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123; throw new AopInvocationException( &quot;Null return value from advice does not match primitive return type for: &quot; + method); &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come from TargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 这个方法在[AOP的方法调用](.&#x2F;10-Spring AOP中的方法调用)中已经讲过了，整个逻辑就只有3部分 获取目标对象 Advice链的调用 非增强方法的调用 2和3步之前就已经讲过了。第一步其实就是一段简单的代码 1Object target = this.advised.targetSource.getTarget(); 这里就是TargetSource接口的应用。从这里就可以知道，TargetSource接口的的作用其实就是在代理对象中获取目标对象。而这个其实是Spring的一个扩展，这个扩展也对外提供了入口方法。 TargetSource接口在项目中的使用TargetSourceCreator对象的创建12345678910111213// AbstractBeanFactoryBasedTargetSourceCreator实现了TargetSourceCreator接口public class CustomTargetSourceCreator extends AbstractBeanFactoryBasedTargetSourceCreator &#123; @Override protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class&lt;?&gt; beanClass, String beanName) &#123; if (getBeanFactory() instanceof ConfigurableListableBeanFactory) &#123; if(beanClass.isAssignableFrom(StudentServiceImpl.class)) &#123; return new CustomTargetSource(); &#125; &#125; return null; &#125;&#125; 可以加@Component注解 TargetSource接口的创建1234567// AbstractBeanFactoryBasedTargetSource实现了TargetSource接口public class CustomTargetSource extends AbstractBeanFactoryBasedTargetSource &#123; @Override public Object getTarget() throws Exception &#123; return getBeanFactory().getBean(getTargetBeanName()); &#125;&#125; 入口123456789101112131415161718192021222324252627@Componentpublic class SetCustomTargetSourceCreator implements BeanPostProcessor, PriorityOrdered, BeanFactoryAware &#123; private BeanFactory beanFactory; @Override public int getOrder() &#123; return 45; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if(bean instanceof AnnotationAwareAspectJAutoProxyCreator || bean instanceof InfrastructureAdvisorAutoProxyCreator) &#123; AbstractAdvisorAutoProxyCreator proxyCreator = (AbstractAdvisorAutoProxyCreator)bean; CustomTargetSourceCreator customTargetSourceCreator = new CustomTargetSourceCreator(); customTargetSourceCreator.setBeanFactory(beanFactory); proxyCreator.setCustomTargetSourceCreators(customTargetSourceCreator); &#125; return bean; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; &#125;&#125; 注意，这个入口类必须要考虑执行顺序，这个之后再讲。 自定义的TargetSource对象在Spring源码中的初始化自定义的TargetSource对象的初始化这里涉及到Spring Bean的初始化流程，初始化流程的入口方法看AbstractBeanFactory的getBean方法，跟踪代码到AbstractAutowireCapableBeanFactor.createBean中的这段代码，这段代码在Bean实例化前调用。 resolveBeforeInstantiation方法是BeanPostProcessor接口的运用，跟踪代码到applyBeanPostProcessorsBeforeInstantiation。 123456789101112131415161718192021222324252627282930313233// AbstractAutowireCapableBeanFactoryprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) &#123; bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = (bean != null); &#125; return bean;&#125;// AbstractAutowireCapableBeanFactory@Nullableprotected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null;&#125; 看这个实现 AbstractAutoProxyCreator的postProcessBeforeInstantiation方法 12345678910111213141516171819202122232425262728293031// AbstractAutoProxyCreator@Overridepublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Object cacheKey = getCacheKey(beanClass, beanName); if (!StringUtils.hasLength(beanName) || !this.targetSourcedBeans.contains(beanName)) &#123; if (this.advisedBeans.containsKey(cacheKey)) &#123; return null; &#125; if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; // Create proxy here if we have a custom TargetSource. // Suppresses unnecessary default instantiation of the target bean: // The TargetSource will handle target instances in a custom fashion. TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) &#123; if (StringUtils.hasLength(beanName)) &#123; this.targetSourcedBeans.add(beanName); &#125; Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; return null;&#125; 这段代码是在bean实例化前调用的。这段代码重点看TargetSource targetSource = getCustomTargetSource(beanClass, beanName);。 12345678910111213141516171819202122// AbstractAutoProxyCreator@Nullableprotected TargetSource getCustomTargetSource(Class&lt;?&gt; beanClass, String beanName) &#123; // We can&#x27;t create fancy target sources for directly registered singletons. if (this.customTargetSourceCreators != null &amp;&amp; this.beanFactory != null &amp;&amp; this.beanFactory.containsBean(beanName)) &#123; for (TargetSourceCreator tsc : this.customTargetSourceCreators) &#123; TargetSource ts = tsc.getTargetSource(beanClass, beanName); if (ts != null) &#123; // Found a matching TargetSource. if (logger.isTraceEnabled()) &#123; logger.trace(&quot;TargetSourceCreator [&quot; + tsc + &quot;] found custom TargetSource for bean with name &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return ts; &#125; &#125; &#125; // No custom TargetSource found. return null;&#125; 这段代码中customTargetSourceCreators的值是通过setCustomTargetSourceCreators方法设置的，而AbstractAutoProxyCreator又是AnnotationAwareAspectJAutoProxyCreator或者InfrastructureAdvisorAutoProxyCreator的父类，所以这里的customTargetSourceCreators就是CustomTargetSourceCreator了。所以现在只需要看CustomTargetSourceCreator的getTargetSource方法。而该方法的实现在其父类中，看源码 1234567891011121314151617181920212223242526272829303132// AbstractBeanFactoryBasedTargetSourceCreator@Override@Nullablepublic final TargetSource getTargetSource(Class&lt;?&gt; beanClass, String beanName) &#123; AbstractBeanFactoryBasedTargetSource targetSource = createBeanFactoryBasedTargetSource(beanClass, beanName); if (targetSource == null) &#123; return null; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Configuring AbstractBeanFactoryBasedTargetSource: &quot; + targetSource); &#125; DefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName); // We need to override just this bean definition, as it may reference other beans // and we&#x27;re happy to take the parent&#x27;s definition for those. // Always use prototype scope if demanded. BeanDefinition bd = this.beanFactory.getMergedBeanDefinition(beanName); GenericBeanDefinition bdCopy = new GenericBeanDefinition(bd); if (isPrototypeBased()) &#123; bdCopy.setScope(BeanDefinition.SCOPE_PROTOTYPE); &#125; internalBeanFactory.registerBeanDefinition(beanName, bdCopy); // Complete configuring the PrototypeTargetSource. targetSource.setTargetBeanName(beanName); targetSource.setBeanFactory(internalBeanFactory); return targetSource;&#125; 第一行就是createBeanFactoryBasedTargetSource就是我们实现的，返回一个TargetSource对象。如果真的返回了TargetSource对象后，就会执行这块代码 12345678910TargetSource targetSource = getCustomTargetSource(beanClass, beanName);if (targetSource != null) &#123; if (StringUtils.hasLength(beanName)) &#123; this.targetSourcedBeans.add(beanName); &#125; Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy;&#125; 来完成切面的收集和为目标对象进行切面匹配，最后通过匹配到的切面完成代理对象的创建，这时代理对象就包含了 TargetSource对象 切面链表 最后把对象返回，并且最后会执行InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法。最后createBean方法结束，然后把返回的Bean加入到一级缓存（如果是单例）中。 自定义的TargetSource对象的入口需要考虑顺序123456789101112131415161718192021222324252627@Componentpublic class SetCustomTargetSourceCreator implements BeanPostProcessor, PriorityOrdered, BeanFactoryAware &#123; private BeanFactory beanFactory; @Override public int getOrder() &#123; return 45; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if(bean instanceof AnnotationAwareAspectJAutoProxyCreator || bean instanceof InfrastructureAdvisorAutoProxyCreator) &#123; AbstractAdvisorAutoProxyCreator proxyCreator = (AbstractAdvisorAutoProxyCreator)bean; CustomTargetSourceCreator customTargetSourceCreator = new CustomTargetSourceCreator(); customTargetSourceCreator.setBeanFactory(beanFactory); proxyCreator.setCustomTargetSourceCreators(customTargetSourceCreator); &#125; return bean; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; &#125;&#125; 我写的入口方法是实现了BeanPostProcessor接口。 从上边的解析中知道，自定义的TragetSource对象的生成是使用了BeanPostProcessor的。而AnnotationAwareAspectJAutoProxyCreator或者instanceof InfrastructureAdvisorAutoProxyCreator这两个接口是实现了Ordered接口的。而且这些BeanPostProcessor接口的是有顺序的，在之前就解析过，这个顺序是在在AbstractApplicationContext的registerBeanPostProcessors是确定的。这个方法的执行逻辑如下 获取所有实现了BeanPostProcessor接口的BeanName 遍历，把实现了PriorityOrdered接口的beanName找出来，然后通过beanFactory.getBean(beanName)方法获取实例，让后放到列表中。便利结束后排序，然后添加到beanFactory的beanPostProcessors列表中。 遍历，把实现了Ordered接口的beanName找出来，然后通过beanFactory.getBean(beanName)方法获取实例，让后放到列表中。便利结束后排序，然后添加到beanFactory的beanPostProcessors列表中。 遍历，把没有实现PriorityOrdered和Ordered接口的beanName找出来，然后通过beanFactory.getBean(beanName)方法获取实例，让后放到列表中。便利结束后排序，然后添加到beanFactory的beanPostProcessors列表中。 遍历，把实现了接口MergedBeanDefinitionPostProcessor的beanName找出来，然后通过beanFactory.getBean(beanName)方法获取实例，让后放到列表中。便利结束后排序，然后添加到beanFactory的beanPostProcessors列表中。 最终的beanPostProcessors的顺序 1234List BeanPostProcessor,PriorityOrderedList BeanPostProcessor,OrderedList BeanPostProcessorList MergedBeanDefinitionPostProcessor 而AnnotationAwareAspectJAutoProxyCreator或者instanceof InfrastructureAdvisorAutoProxyCreator是在第二个List中，所以我的入门方法只需要保证在第一个List中就行了。但是不能是在第二个或之后的List中。因为如果在第二个List中时，beanFactory.getBean(beanName)时，此时的beanPostProcessors列表只包含第一List的也就是实现了PriorityOrdered接口的，只有第二list的BeanPostProcessor全部getBean排序后才会加入到postBeanProcessors列表中。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"11-Spring中多例TargetSource","slug":"spring/5.2.8/11-Spring中多例TargetSource","date":"2021-11-20T12:00:18.000Z","updated":"2022-03-14T09:04:26.106Z","comments":true,"path":"blog/spring/5.2.8/11-Spring中多例TargetSource/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/11-Spring%E4%B8%AD%E5%A4%9A%E4%BE%8BTargetSource/","excerpt":"","text":"Spring 中的多例在Spring中bean的初始化过程中简单的说过多例，就是每次beanFactory.getBean时都会生成一个实例，这点是没问题的。 那么现在有这样类的定义： 1234567891011121314151617181920@Component@Scope(value = DefaultListableBeanFactory.SCOPE_PROTOTYPE)public class ScopedProxyBean &#123; public void code() &#123; System.out.println(this.hashCode()); &#125;&#125;@Componentpublic class MyBean &#123; @Autowired private ScopedProxyBean scopedProxyBean; public void tet() &#123; scopedProxyBean.code(); &#125;&#125; 上面的代码很简单，就是把ScopedProxyBean设置成多例，然后MyBean中DI这个类。而在MyBean，中调用scopedProxyBean.code()来打印ScopedProxyBean的hashcode。现在有这样的测试代码： 12345678@Testpublic void test9() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ScanBean.class); MyBean bean = applicationContext.getBean(MyBean.class); for (int i = 0; i &lt; 10; i++) &#123; bean.tet(); &#125;&#125; 结果： 因为，对于一个多例的Spring Bean，MyBean在DI时调用了一次getBean已经获取到一个ScopedProxyBean实例了，那么在MyBean这个类中的ScopedProxyBean的对对象已经确定了，所以hashcode才会相同。而别的对象中，调用getBean又会获取不同的对象。 单例和多例的不同就是单例使用了缓存，让第二次getbean时从一级缓存stangleObjects这个Map中取对象，而多例没有使用缓存，所以每次getbean都会创建新的对象。 现在改下ScopedProxyBean： 12345678@Component@Scope(value = DefaultListableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)public class ScopedProxyBean &#123; public void code() &#123; System.out.println(this.hashCode()); &#125;&#125; 也就加了proxyMode = ScopedProxyMode.TARGET_CLASS 其他都一样。测试结果： 可以看到，每次答应的结果都不同，这是不是意味着MyBean中的ScopedProxyBean会变化？如果真的这样，就破坏了Spring的单例原则，而且在运行时每次都改变MyBean中的ScopedProxyBean引用指向的对象这种行为也不可能实现。造成上面的情况，只可能是使用了代理，在依赖注入的时候先为MyBean中的ScopedProxyBean的引用指向一个代理对象。而在运行时，通过代理对象调用方法时会新建一个对象来进行方法调用，只有通过这样的方法才会造成这种现象。现在看下MyBean中的ScopedProxyBean的引用指向的对象： 可以看到，是一个CGLIB的代理对象。可以确定在@Scope中加上 1@Scope(value = DefaultListableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS) 会导致生成代理对象。那问题来了，是在什么时候检查到需要生成代理对象的。看扫描类生成BeanDefinition的源码（这里以注解的上下文对象为例），在ConfigurationClassPostProcessor中扫描@Component注解的逻辑中： 1AnnotationConfigUtils 1ScopedProxyUtils 好了，现在重点看下ScopedProxyUtils.createScopedProxy这个方法。 从上边可知，在这种情况下 1@Scope(value = DefaultListableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS) proxyTargetClass为true。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//ScopedProxyUtilspublic static BeanDefinitionHolder createScopedProxy(BeanDefinitionHolder definition, BeanDefinitionRegistry registry, boolean proxyTargetClass) &#123; // 原来的beanName String originalBeanName = definition.getBeanName(); BeanDefinition targetDefinition = definition.getBeanDefinition(); // 把targetName设置成 scopedTarget. + beanName 这种模式，比如：scopedTarget.xyzBean String targetBeanName = getTargetBeanName(originalBeanName); // Create a scoped proxy definition for the original bean name, // &quot;hiding&quot; the target bean in an internal target definition. // 把BeanDefinition的目标对象的类型设置为ScopedProxyFactoryBean RootBeanDefinition proxyDefinition = new RootBeanDefinition(ScopedProxyFactoryBean.class); proxyDefinition.setDecoratedDefinition(new BeanDefinitionHolder(targetDefinition, targetBeanName)); proxyDefinition.setOriginatingBeanDefinition(targetDefinition); proxyDefinition.setSource(definition.getSource()); proxyDefinition.setRole(targetDefinition.getRole()); // 添加属性targetBeanName为targetBeanName // 通过这样设置会，在通过BeanDefintion创建对象时会调用ScopedProxyFactoryBean的setTargetBeanName方法。 proxyDefinition.getPropertyValues().add(&quot;targetBeanName&quot;, targetBeanName); if (proxyTargetClass) &#123; targetDefinition.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); // ScopedProxyFactoryBean&#x27;s &quot;proxyTargetClass&quot; default is TRUE, so we don&#x27;t need to set it explicitly here. &#125; else &#123; proxyDefinition.getPropertyValues().add(&quot;proxyTargetClass&quot;, Boolean.FALSE); &#125; // Copy autowire settings from original bean definition. // 设置是否允许注入，默认值为true proxyDefinition.setAutowireCandidate(targetDefinition.isAutowireCandidate()); // 设置Primary proxyDefinition.setPrimary(targetDefinition.isPrimary()); if (targetDefinition instanceof AbstractBeanDefinition) &#123; proxyDefinition.copyQualifiersFrom((AbstractBeanDefinition) targetDefinition); &#125; // The target bean should be ignored in favor of the scoped proxy. targetDefinition.setAutowireCandidate(false); targetDefinition.setPrimary(false); // 注册旧的beanDefinition // Register the target bean as separate bean in the factory. registry.registerBeanDefinition(targetBeanName, targetDefinition); // Return the scoped proxy definition as primary bean definition // (potentially an inner bean). // 这里的BeanDefinitionHolder指向的beanDefinition为新的，而且originalBeanName就是我们自己定义的beanName return new BeanDefinitionHolder(proxyDefinition, originalBeanName, definition.getAliases());&#125; 可以看到，对于加上了ScopedProxyMode.TARGET_CLASS的@Scope，会在往BeanFactory注册BeanDefinition前会在扫描出来的BeanDefinition的基础上创建一个新的BeanDefinition，而新的BeanDefinition对在其属性中加上这个属性： 1org.springframework.aop.framework.autoproxy.AutoProxyUtils.preserveTargetClass=true 而且新的BeanDefinition的被允许为可以依赖注入并设置Primary属性，而且旧的BeanDefinition把是否允许注入设置为false了，这也就是说，旧的beanDefinition创建的对象是不会被注入到其他对象中的。 而且上边有4点很重要 就是beanName了，上边会有两个beanName，一个是originalBeanName，这个就是我们定义的benName（默认）；第二个就是targetBeanName，这个targetBeanName的值被设置成了scopedTarget. + originalBeanName这种模式。比如：scopedTarget.xyzBean。在最后注册BeanDefinition的时候，会生成如下的关系 12&lt;targetBeanName, 旧的BeanDefinition&gt;&lt;originalBeanName, 新的BeanDefinition&gt; 新建的BeanDefinition的目标对象是ScopedProxyFactoryBean这个对象 新建的BeanDefinition通过 1proxyDefinition.getPropertyValues().add(&quot;targetBeanName&quot;, targetBeanName); 设置了targetBeanName属性，这样设置后，在通过BeanDefinition创建对象的时候会调用调用ScopedProxyFactoryBean的setTargetBeanName方法。 新的BeanDefinition的scope值为默认值，也就是单例；而旧的BeanDefinition的scope为我们bean定义的值，在上边的例子中，就是多例 所以通过上边的4点可知，根据新的BeanDefinition创建的对象，就是我们在代码中通过依赖注入主人的对象，该对象的BeanName就是我们定义的。而通过旧的BeanDefinition创建的对象是多例的，而且不会被依赖注入，而且BanName为scopedTarget.$&#123;BeanName&#125;这种模式。所我我们现在只需要关注新BeanDefintion的定义所对应的类，也就是ScopedProxyFactoryBean。看代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class ScopedProxyFactoryBean extends ProxyConfig implements FactoryBean&lt;Object&gt;, BeanFactoryAware, AopInfrastructureBean &#123; /** The TargetSource that manages scoping. */ private final SimpleBeanTargetSource scopedTargetSource = new SimpleBeanTargetSource(); /** The name of the target bean. */ @Nullable private String targetBeanName; /** The cached singleton proxy. */ @Nullable private Object proxy; /** * Create a new ScopedProxyFactoryBean instance. */ public ScopedProxyFactoryBean() &#123; setProxyTargetClass(true); &#125; /** * Set the name of the bean that is to be scoped. */ public void setTargetBeanName(String targetBeanName) &#123; this.targetBeanName = targetBeanName; this.scopedTargetSource.setTargetBeanName(targetBeanName); &#125; @Override public void setBeanFactory(BeanFactory beanFactory) &#123; if (!(beanFactory instanceof ConfigurableBeanFactory)) &#123; throw new IllegalStateException(&quot;Not running in a ConfigurableBeanFactory: &quot; + beanFactory); &#125; ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory; this.scopedTargetSource.setBeanFactory(beanFactory); ProxyFactory pf = new ProxyFactory(); pf.copyFrom(this); pf.setTargetSource(this.scopedTargetSource); Assert.notNull(this.targetBeanName, &quot;Property &#x27;targetBeanName&#x27; is required&quot;); Class&lt;?&gt; beanType = beanFactory.getType(this.targetBeanName); if (beanType == null) &#123; throw new IllegalStateException(&quot;Cannot create scoped proxy for bean &#x27;&quot; + this.targetBeanName + &quot;&#x27;: Target type could not be determined at the time of proxy creation.&quot;); &#125; if (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) &#123; pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader())); &#125; // Add an introduction that implements only the methods on ScopedObject. ScopedObject scopedObject = new DefaultScopedObject(cbf, this.scopedTargetSource.getTargetBeanName()); pf.addAdvice(new DelegatingIntroductionInterceptor(scopedObject)); // Add the AopInfrastructureBean marker to indicate that the scoped proxy // itself is not subject to auto-proxying! Only its target bean is. pf.addInterface(AopInfrastructureBean.class); this.proxy = pf.getProxy(cbf.getBeanClassLoader()); &#125; @Override public Object getObject() &#123; if (this.proxy == null) &#123; throw new FactoryBeanNotInitializedException(); &#125; return this.proxy; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; if (this.proxy != null) &#123; return this.proxy.getClass(); &#125; return this.scopedTargetSource.getTargetClass(); &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 可以看到，它是实现了 FactoryBean接口，而且新建的BeanDefinition能够被依赖注入，也就是说该类对象的生命周期被Spring控制，所以在依赖注入时，被注入的对象的类型是由getObjectType决定的，而ScopedProxyFactoryBean的getObjectType方法看下图： 现在看下ScopedProxyFactoryBean#getTargetClass。 12345678910111213141516171819202122232425//ScopedProxyFactoryBean@Overridepublic Class&lt;?&gt; getTargetClass() &#123; Class&lt;?&gt; targetClass = this.targetClass; if (targetClass != null) &#123; return targetClass; &#125; synchronized (this) &#123; // Full check within synchronization, entering the BeanFactory interaction algorithm only once... targetClass = this.targetClass; if (targetClass == null &amp;&amp; this.beanFactory != null) &#123; // Determine type of the target bean. targetClass = this.beanFactory.getType(this.targetBeanName); if (targetClass == null) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Getting bean with name &#x27;&quot; + this.targetBeanName + &quot;&#x27; for type determination&quot;); &#125; Object beanInstance = this.beanFactory.getBean(this.targetBeanName); targetClass = beanInstance.getClass(); &#125; this.targetClass = targetClass; &#125; return targetClass; &#125;&#125; 可以看到，会根据targetBeanName去获取目标类的class对象。从上边的ScopedProxyFactoryBean的BeanDefinition定义可知，在创建ScopedProxyFactoryBean对象的时候会调用其setTargetBeanName方法： 1234public void setTargetBeanName(String targetBeanName) &#123; this.targetBeanName = targetBeanName; this.scopedTargetSource.setTargetBeanName(targetBeanName);&#125; 所以，targetBeanName就有值了，而且该值的有个固定前缀scopedTarget.。所以通过getTargetClass获取到的就是我们定义的Bean的类型，以最开始的例子为例，targetClass = ScopedProxyBean.class。 而注入的对象是由getObject()方法决定的 通过上边的分析，已知ScopedProxyFactoryBean是能依赖注入的。以MyBean和ScopedProxyBean为例，getObjectType()返回的class对象就是ScopedProxyBean.class，而在依赖注入时getBean获取到了ScopedProxyFactoryBean这个类的实例，而由于这个类的实例是实现了FactoryBean接口，那么就会在缓存FactoryBeanRegistrySupport.factoryBeanObjectCache中拿目标对象，缓存中没有就调用getObject()方法，而在这里getObject()返回返回的是一个proxy，是一个代理对象。而这个代理对象是什么时候生成的，那么就要看ScopedProxyFactoryBean实现的另一个接口——BeanFactoryAware了。 BeanFactoryAware这个接口会在Bean创建完，并完成依赖注入后会调用，现在看这个接口的方法setBeanFactory(BeanFactory beanFactory) 1234567891011121314151617181920212223242526272829303132333435//ScopedProxyFactoryBean @Overridepublic void setBeanFactory(BeanFactory beanFactory) &#123; if (!(beanFactory instanceof ConfigurableBeanFactory)) &#123; throw new IllegalStateException(&quot;Not running in a ConfigurableBeanFactory: &quot; + beanFactory); &#125; ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory; this.scopedTargetSource.setBeanFactory(beanFactory); ProxyFactory pf = new ProxyFactory(); pf.copyFrom(this); pf.setTargetSource(this.scopedTargetSource); Assert.notNull(this.targetBeanName, &quot;Property &#x27;targetBeanName&#x27; is required&quot;); // 设置目标接口 Class&lt;?&gt; beanType = beanFactory.getType(this.targetBeanName); if (beanType == null) &#123; throw new IllegalStateException(&quot;Cannot create scoped proxy for bean &#x27;&quot; + this.targetBeanName + &quot;&#x27;: Target type could not be determined at the time of proxy creation.&quot;); &#125; if (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) &#123; pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader())); &#125; // Add an introduction that implements only the methods on ScopedObject. ScopedObject scopedObject = new DefaultScopedObject(cbf, this.scopedTargetSource.getTargetBeanName()); pf.addAdvice(new DelegatingIntroductionInterceptor(scopedObject)); // Add the AopInfrastructureBean marker to indicate that the scoped proxy // itself is not subject to auto-proxying! Only its target bean is. pf.addInterface(AopInfrastructureBean.class); this.proxy = pf.getProxy(cbf.getBeanClassLoader());&#125; targetBeanName&#96;还是和上边的一样 这里就是整个@Scope(value = DefaultListableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)的关键，首先从整体看，它就是去创建一个代理对象的，但这里有一个非常关键的代码，就是 12ProxyFactory pf = new ProxyFactory();pf.setTargetSource(this.scopedTargetSource); 这段代码就是赠段代码的核心，但却很简单，就是往ProxyFactory设置了一个targetSource对象，这个对象就是SimpleBeanTargetSource。 这个对象是在创建 ScopedProxyFactoryBean的时候创建的 而且在创建的玩后会调用ScopedProxyFactoryBean#setTargetBeanName方法，会设置scopedTargetSource的targetBeanName。 这个SimpleBeanTargetSource最终会在代理对象的方法调用时被调用，但现在先跟踪下代理对象的创建过程也就是ProxyFactory.getProxy 12345678910111213141516171819202122232425262728public Object getProxy(@Nullable ClassLoader classLoader) &#123; return createAopProxy().getProxy(classLoader);&#125;protected final synchronized AopProxy createAopProxy() &#123; if (!this.active) &#123; activate(); &#125; return getAopProxyFactory().createAopProxy(this);&#125;//这里的AdvisedSupport config = this = 最开始的ProxyFactory pf = new ProxyFactory();public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; + &quot;Either an interface or a target is required for proxy creation.&quot;); &#125; if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125;&#125; 这里有两个代理，而从上文已知代理对象是使用了CGLIB的代理，但由于我更加熟悉jdk原生动态代理而且，有设置接口，所以这里就以JdkDynamicAopProxy为例，而CGLIB的调用逻辑也是一样的，就是API不同而已。 看JdkDynamicAopProxy.getProxy 123456789//JdkDynamicAopProxypublic Object getProxy(@Nullable ClassLoader classLoader) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 从这里可知，InvocationHandler是this，也就是JdkDynamicAopProxy，现在看invoke方法，在代理对象调用方法时都会进入到这个方法，invoke在[10-Spring AOP中的方法调用](.&#x2F;10-Spring AOP中的方法调用)中对已经看过了，不过那时时关注的是切面的调用过程，和目标对象的方法的是怎么调用的，但没关注目标对象是怎么获取的。这里就看下目标对象是怎么获取的。 在invoke中先通过这段代码获取TargetSource 1TargetSource targetSource = this.advised.targetSource; 然后通过这段代码获取目对象: 1target = targetSource.getTarget(); 好了，这就结束。现在回忆下AOP的代理对象是怎么生成的，看代码AbstractAutoProxyCreator.createProxy: 生成的过程和多实例代理一样，不同点在于TargetSource不同，AOP中用到了SingletonTargetSource，这个其实很简单，就是把目标对象放进去就，然后get出来。而多实例的代理是SimpleBeanTargetSource，现在看SimpleBeanTargetSource的定义: 12345678public class SimpleBeanTargetSource extends AbstractBeanFactoryBasedTargetSource &#123; @Override public Object getTarget() throws Exception &#123; return getBeanFactory().getBean(getTargetBeanName()); &#125;&#125; 很简单，就是使用beanFactory重新去获取一个新的对象，所以这里就解析了为什么加了proxyMode = ScopedProxyMode.TARGET_CLASS每次调用对象都不同。因为在这里的targetBeanName的值是targetSource.scopedProxyBean，该对象的BeanDefinition是被设置成多例的，所以在getBean的时候就会新建一个对象。 注意SimpleBeanTargetSource中的getBeanFactory()是在运行时就已经设置进去了，就是TargetSource接口的初始化过程。这个过程和bean代理的提前生成有关。 CGLIB就类推就好了，逻辑都是一样的，就是API不同。 在Spring中，一个Bean的beanName有targetSource.这个前缀的话，就代表该Bean只是一个单纯的对象，不会参与到依赖注入，也就是说不会被其他对象引用，所以这种Bean从功能的角度看，没有任何作用。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"11-Spring-用接口实现AOP","slug":"spring/5.2.8/11-Spring-用接口实现AOP","date":"2021-11-20T12:00:17.000Z","updated":"2022-03-14T09:04:26.069Z","comments":true,"path":"blog/spring/5.2.8/11-Spring-用接口实现AOP/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/11-Spring-%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0AOP/","excerpt":"","text":"Spring-用接口实现AOP感觉使用AOP接口更加的灵活。 Advisor123456789101112131415161718192021222324@Componentpublic class CustomAdvisor implements PointcutAdvisor &#123; @Autowired private CustomPointcut pointcut; @Autowired private CustomAdvice advice; @Override public Pointcut getPointcut() &#123; return pointcut; &#125; @Override public Advice getAdvice() &#123; return advice; &#125; @Override public boolean isPerInstance() &#123; return false; &#125;&#125; Advice1234567891011@Componentpublic class CustomAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;我是自定义的AOP--before&quot;); Object obj = invocation.proceed(); System.out.println(&quot;我是自定义的AOP--after&quot;); return obj; &#125;&#125; Pointcut1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class CustomPointcut implements Pointcut, MethodMatcher &#123; /** * 所有类都匹配 * @return */ @Override public ClassFilter getClassFilter() &#123; return ClassFilter.TRUE; &#125; @Override public MethodMatcher getMethodMatcher() &#123; return this; &#125; /** * 所有方法都匹配 * @param method * @param targetClass * @return */ @Override public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //拿原始方法对象，这个方法上才有注解 Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); if(AnnotatedElementUtils.hasAnnotation(specificMethod, CustomCache.class)) &#123; return true; &#125; return false; &#125; @Override public boolean isRuntime() &#123; return true; &#125; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) &#123; if (args.length &gt; 0 &amp;&amp; args[0] != null) &#123; return &quot;xyz&quot;.equalsIgnoreCase(args[0].toString()); &#125; return false; &#125;&#125; 自定义注解CustomCache123456@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CustomCache &#123;&#125; 测试12345678@Testpublic void test4() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ScanBean.class, BeanPostProcessorPro.class); AopBean1 aopBean1 = applicationContext.getBean(AopBean1.class); System.out.println(aopBean1); aopBean1.print(&quot;xx&quot;); aopBean1.print(&quot;xyz&quot;);&#125; 分析逻辑很简单，就是匹配方法是否有CustomCache这个注解和入参是否为”xyz”。 结果： 这里我分析些下CustomPointcut的方法 12345678910@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //拿原始方法对象，这个方法上才有注解 Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); if(AnnotatedElementUtils.hasAnnotation(specificMethod, CustomCache.class)) &#123; return true; &#125; return false;&#125; 这里，我为什么不这样写呢？ 1234567@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; if(AnnotatedElementUtils.hasAnnotation(method, CustomCache.class)) &#123; return true; &#125; return false;&#125; 首先，这个方法matches对于一个对象来说至少会被执行一次，对于一个需要被增强的对象来说至少被执行两次。 第一次是在生成代理类对象之前，第二次是在方法调用的过程中。 在这两次的过程，传入的Method是不同的。 第一次：看源码从这里开始 到这里结束： 这个class对象是通过bean.getClass()获取的，也就是说，第一个Method对象是从bean类型类中获取的。 第二次是通过动态代理对象中的的invoke获取的 那么这个invoke的Method对象是怎么来的，写了个测试方法 1234567891011121314@Testpublic void test5() &#123; byte[] $Proxy0s = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, new Class[]&#123;AopBean.class&#125;); try &#123; FileOutputStream fileOutputStream = new FileOutputStream(&quot;$Proxy0.class&quot;); fileOutputStream.write($Proxy0s); fileOutputStream.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 这个测试方法是把动态代理的class打印出来 看这个代理类的字节码文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final class $Proxy0 extends Proxy implements AopBean &#123; private static Method m1; private static Method m2; private static Method m0; private static Method m3; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void print(String var1) throws &#123; try &#123; super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); m3 = Class.forName(&quot;com.enjoy.xyz.aop.bean.AopBean&quot;).getMethod(&quot;print&quot;, Class.forName(&quot;java.lang.String&quot;)); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 可以看到，这个Method对象对象是通过 1Class.forName(&quot;com.enjoy.xyz.aop.bean.AopBean&quot;).getMethod(&quot;print&quot;, Class.forName(&quot;java.lang.String&quot;)); 这样获取的，也就是获取接口的Method对象。 所以，这两次由于获取Method对象的来源不同，导致这两个Method对象拥有的信息不一样，比如这个方法是有注解的，那么第一次的Method对象是能获取到注解的信息的，而第二次不行。 添加了这样的条件断点 注意，以上的情况只会出现在被代理对象使用了接口的情况。 所以才在matches中用这行代码来拿原始方法对象，这个方法上才有注解 1Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); 这行代码的原理就是由于matches中targetClass是被代理对象的class对象，所以从这里获取的Method才是准的。 其他AopContext.currentProxy()在这样定义后 1@EnableAspectJAutoProxy(exposeProxy = true) 就能在项目中使用AopContext.currentProxy()来获取代理类。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"10-Spring AOP中的方法调用","slug":"spring/5.2.8/10-Spring AOP中的方法调用","date":"2021-11-20T12:00:16.000Z","updated":"2022-03-14T09:04:26.034Z","comments":true,"path":"blog/spring/5.2.8/10-Spring AOP中的方法调用/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/10-Spring%20AOP%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/","excerpt":"","text":"Spring AOP中的方法调用在前面讲过，代理对象有两种生成方式（如果被代理对象没接口就只能用cglib） 在之前的对getProxy的代码分析中，已经知道，createAopProxy最终有代理类 JdkDynamicAopProxy ObjenesisCglibAopProxy JdkDynamicAopProxy在AOP解析已经了解代理对象的InvocationHandler就是JdkDynamicAopProxy 所以看invoke方法就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; //从代理工厂中拿到TargetSource对象，该对象包装了被代理实例bean TargetSource targetSource = this.advised.targetSource; Object target = null; try &#123; //被代理对象的equals方法和hashCode方法是不能被代理的，不会走切面 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; // The target does not implement the equals(Object) method itself. return equals(args[0]); &#125; else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123; // The target does not implement the hashCode() method itself. return hashCode(); &#125; else if (method.getDeclaringClass() == DecoratingProxy.class) &#123; // There is only getDecoratedClass() declared -&gt; dispatch to proxy config. return AopProxyUtils.ultimateTargetClass(this.advised); &#125; else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); &#125; Object retVal; //如果该属性设置为true，则把代理对象设置到ThreadLocal中 if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; //这个target就是被代理实例 target = targetSource.getTarget(); Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null); //从代理工厂中拿过滤器链 Object是一个MethodInterceptor类型的对象，其实就是一个advice对象 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); //如果该方法没有执行链，则说明这个方法不需要被拦截，则直接反射调用 if (chain.isEmpty()) &#123; Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; // We need to create a method invocation... MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. retVal = invocation.proceed(); &#125; // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; retVal = proxy; &#125; else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123; throw new AopInvocationException( &quot;Null return value from advice does not match primitive return type for: &quot; + method); &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come from TargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125; 我们看重要的。先执行到这里 这里的意思就是如果在在这种情况 设置了exposeProxy&#x3D;true，那么可以就会把代理对象放入到一个ThreadLocal中。在方法中就可以通过 1AopContext.currentProxy() 获取到代理对象。这是可以解决这种[问题](.&#x2F;Sping AOP在开发中的问题) 下面就是AOP调用的核心逻辑了。 1List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass) 这个方法会去检查这个执行的方法是否被拦截，并会返回匹配到的advice对象。 如果没有advice被返回，那执行了 也就是直接通过反射，用用被代理对象来调用。 而如果通过该方法有匹配成功的Advisor，那就直接来过增强逻辑的调用流程了 下面先看下这个方法advised.getInterceptorsAndDynamicInterceptionAdvice 在方法调用时，获取匹配的Advisor跟踪代码到DefaultAdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//DefaultAdvisorChainFactorypublic List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice( Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) &#123; // This is somewhat tricky... We have to process introductions first, // but we need to preserve order in the ultimate list. AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); //从代理工厂中获得该被代理类的所有切面advisor，config就是代理工厂对象 Advisor[] advisors = config.getAdvisors(); List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length); Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass()); Boolean hasIntroductions = null; for (Advisor advisor : advisors) &#123; //大部分走这里 if (advisor instanceof PointcutAdvisor) &#123; // Add it conditionally. PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor; //如果切面的pointCut和被代理对象是匹配的，说明是切面要拦截的对象..先进行类匹配 if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123; //先类匹配，然后在方法匹配 MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; if (mm instanceof IntroductionAwareMethodMatcher) &#123; if (hasIntroductions == null) &#123; hasIntroductions = hasMatchingIntroductions(advisors, actualClass); &#125; match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions); &#125; else &#123; match = mm.matches(method, actualClass); &#125; //如果类和方法都匹配 if (match) &#123; //获取到切面advisor中的advice，并且包装成MethodInterceptor类型的对象 MethodInterceptor[] interceptors = registry.getInterceptors(advisor); if (mm.isRuntime()) &#123; // Creating a new object instance in the getInterceptors() method // isn&#x27;t a problem as we normally cache created chains. for (MethodInterceptor interceptor : interceptors) &#123; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); &#125; &#125; else &#123; interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; &#125; &#125; //如果是引介切面 else if (advisor instanceof IntroductionAdvisor) &#123; IntroductionAdvisor ia = (IntroductionAdvisor) advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; else &#123; Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); &#125; &#125; return interceptorList;&#125; 先获取了 上述方法中的config就是 这个advisors就是在AOP解析最后匹配成功的Advisor 接着执行到这个for循环 上边的代码块就是进行了类匹配和方法匹配，如果匹配成功了会执行到 这里，下面就讲这代码块 getInterceptors看一个方法 可以看到，这个方法里会做一些类型的转变，就看一个AfterReturningAdviceAdapter 可以看到，这里会把AfterRetruningAdvice这个Advice封装成一个AfterReturningAdviceInterceptor，也就是存在这样的封装 AfterReturningAdvice——AfterReturningAdviceInterceptor MethodBeforeAdviceAdapter——MethodBeforeAdviceInterceptor ThrowsAdviceAdapter——ThrowsAdviceInterceptor getInterceptors方法执行完后getInterceptors方法执行完后有这样一个判断。 就是MethodMatcher.isRuntime放回true后，那么就会把MethodInterceptor封装成InterceptorAndDynamicMethodMatcher。这个的作用在这先透露下，就是在Advice执行前做方法的参数校验的。 赠强方法的调用过程——ReflectiveMethodInvocation#proceed回到JdkDynamicAopProxy的invoke方法。 现在假如在方法调用时，调用的方法找到匹配的Advice列表（一条责任链），会执行下面的代码块。这也是 先看下ReflectiveMethodInvocation的构造方法 123456789101112private int currentInterceptorIndex = -1;protected ReflectiveMethodInvocation( Object proxy, @Nullable Object target, Method method, @Nullable Object[] arguments, @Nullable Class&lt;?&gt; targetClass, List&lt;Object&gt; interceptorsAndDynamicMethodMatchers) &#123; this.proxy = proxy; this.target = target; this.targetClass = targetClass; this.method = BridgeMethodResolver.findBridgedMethod(method); this.arguments = AopProxyUtils.adaptArgumentsIfNecessary(method, arguments); this.interceptorsAndDynamicMethodMatchers = interceptorsAndDynamicMethodMatchers;&#125; 看下ReflectiveMethodInvocation#proceed方法 12345678910111213141516171819202122232425262728293031@Override@Nullablepublic Object proceed() throws Throwable &#123; // We start with an index of -1 and increment early. if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass()); if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. return proceed(); &#125; &#125; else &#123; // It&#x27;s an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; 在第一个if中，由于currentInterceptorIndex属性的默认值为-1，所以先不会执行到这。 接着执行这代码 12Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); 而这代码的意思就是获取匹配到的Advice中的第++this.currentInterceptorIndex个。 运行时参数匹配接着到下一个if 这个InterceptorAndDynamicMethodMatcher就是当MethodMatcher.isRuntime放回true后生成的。里面的逻辑挺简单的，就是在运行时进行参数匹配，比如这可以判断参数是等于某个值时才进行执行增强的方法。为ture时的代码方法到下面讲。else的时候就递归调用（跳过这个Advice）。 MethodInterceptor的invoke调用现在看回这段代码。 解析前，先说下在这段代码中涉及到的一些关系 @Around——在APO注解解析时——AspectJAroundAdvice @Before ——在APO注解解析时—— AspectJMethodBeforeAdvice——在方法调用时，增强逻辑执行前——MethodBeforeAdviceInterceptor @After —— 在APO注解解析时——AspectJAfterAdvice——在方法调用时，增强逻辑执行前——AfterReturningAdviceInterceptor @AfterReturning ——在APO注解解析时—— AspectJAfterReturningAdvice @AfterThrowing ——在APO注解解析时—— AspectJAfterThrowingAdvice——在方法调用时，增强逻辑执行前——ThrowsAdviceInterceptor 这些关系在之前就已经说明了。看会代码，这一段代码的意思就是执行增强逻辑的，比如下面的这些方法。 现在假设interceptorOrInterceptionAdvice的类型是MethodBeforeAdviceInterceptor 看MethodBeforeAdviceInterceptor 这个advice就是AspectJMethodBeforeAdvice 这个before就是一个反射调用方法，而这个方法就是增强的方法，过程就不看了。重点看before方法调用后的MethodInvocation.proceeed方法。我们再看下调用invoke的代码 传了一个this进来，也就是说这个mi就是ReflectiveMethodInvocation这个对象本身，所以mi.proceed就是一个递归调用的过程，由于前一次会下标进行了+1的操作，所以这次的调用的Advice变成了第二个，然后这个又重复。比如第二次调用的Advice是AspectJAroundAdvice 看AspectJAroundAdvice 其实这里和before那一样的，不同点在于 aroud多传了ProceedingJoinPoint这个参数。最后还是调用了增强的方法。看回上图，before1()方法调用完之后之所以能能调用下个Advice是因为他的MethodInvocation默认帮我们调用了proceed()。而around不同，看它的invoke只是调用了增强方法本身，并没有帮我们传递，所以对于aroud就必须在增强方法那调用 这个方法才能继续调用下一个Advice。 好了，其他的就不说的了，其它大致也差不多。 那问题来了，什么时候调用目标方法呢？ 目标方法的调用回到ReflectiveMethodInvocation#proceed 看这里，当Advisor调用完后，这个if返回true 从传参就可以猜到作用了，继续跟踪 最后通过反射调用了目标方法。也就是说，执行目标方法的条件就是匹配的切面都执行过了（注意不是执行完） 再谈ExposeInvocationInterceptor.ADVISOR前面已经说过了，在匹配到的Advisor中只要有用注解定义的切面，那每次都会在匹配的到的Advisors列表的头部添加上这个 这里看下这个切面有什么用。 在ExposeInvocationInterceptor中看到 切面的类型是DefaultPointcutAdvisor，看一个切面主要看两点，pointcut和Advice。 从构造函数可以看出，切点是Pointcut.TRUE，Advice是ExposeInvocationInterceptor。 切点无非就看两个，ClassFilter和MethodMatcher，跟踪代码看到 这里我不继续跟了，ClassFilter.TRUE和MethodMatcher.TRUE两个实际上不做什么，在它们的match方法上都返回true，也就是说对所有类和方法都通行。下面看Advice 看Advice，在Spring中实现一个Advice，有两种方法，实现Advice接口、另一个实现MethodInterceptor接口。用得最多的就是实现MethodInterceptor接口的。这ExposeInvocationInterceptor就是实现了MethodInterceptor接口，所以看它的作用就只需看invoke方法。 这个切面所做的增强只是在把MethodInvocation方法放入到了一个ThreadLocal中，并且把旧的删除。由于它是在切面数组的0号位置，所以会第一次执行（我们没有添加全局AOP时） 这样带来的便利就是在方法中，只需要通过 1ExposeInvocationInterceptor.currentInvocation() 就能获取到MethodInvocation。这个对象的类型为ReflectiveMethodInvocation。通过这个对象，可以获取目标对象，代理类，参数等。 如果全部的Advisor都是用接口实现的，这种情况下通过下面的方法会返回一个null值 总结现在假设我定义的切面入下 然后又调用 了一个测试方法 aopBean1这个就是代理对象，aopBean1.print(“xx”);调用后就执行了下边的流程。 这时开始调用前的链表顺序是这样的(不考虑全局的AOP和ExposeInvocationInterceptor.ADVISOR) 也就是说先调用了around1 System.out.println(&quot;around1----1&quot;); 然后调用了joinPoint.proceed();，这个方法的作用和before中的mi.proceed是一样的，就是又调用链中的下一个Advice，这时也就是执行around2，而around2中又执行了 System.out.println(&quot;around2---1&quot;);接着又调用了joinPoint.proceed();，又调用了链中的下一个Advice也就是before1的System.out.println(&quot;before1----1&quot;);。这时从上边可以知道，before1方法执行完后又调用会调用连中下一个，这时链中Advice已经调用完了，就执行了这行代码 这就是执行目标方法的，执行完后就返回了，这时before1返回了，接着before1出栈，又到aroud2执行了，around2执行了System.out.println(&quot;around2---2&quot;);后就出栈了，又到aroud1执行了 around1执行了System.out.println(&quot;around1----2&quot;);,aroud1又出栈了，接着其他方法也执行完了，那整个调用就完成了，打印应结果 和预测的一样，整个执行时序是 1234567891011121314151617181920212223242526272829动态代理的invoke()方法入栈：ReflectiveMethodInvocation.proceed()入栈：around1()方法入栈：around1:System.out.println(&quot;around1----1&quot;);around1:joinPoint.proceed();around2()方法入栈：around2:System.out.println(&quot;around2---1&quot;);around2:joinPoint.proceed();before1()方法入栈：before1: System.out.println(&quot;before1----1&quot;);目标方法入栈：目标方法执行目标方法出栈before1()方法出栈。around2:System.out.println(&quot;around2---2&quot;);around2()方法出栈。around1:System.out.println(&quot;around1----2&quot;);around1()方法出栈。ReflectiveMethodInvocation.proceed()出栈。动态代理的invoke()方法出栈。 这里我把joinPoint.proceed()称为火炬传递，看下Afiter，也是一样的，只是先火炬传递，然后再调用after的逻辑。 ​ 这其实和Netty中的pipeline一样的","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"09-Spring-AOP解析","slug":"spring/5.2.8/09-Spring-AOP解析","date":"2021-11-20T12:00:15.000Z","updated":"2022-03-14T09:04:25.916Z","comments":true,"path":"blog/spring/5.2.8/09-Spring-AOP解析/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/09-Spring-AOP%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Spring-AOP解析传统的xml在传统的xml中开启aop要这样 通过前面的只是，找到了解析类AspectJAutoProxyBeanDefinitionParser 源码： 12345public BeanDefinition parse(Element element, ParserContext parserContext) &#123; AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); extendBeanDefinition(element, parserContext); return null;&#125; 看第一行代码的源码： 方法registerAspectJAnnotationAutoProxyCreatorIfNecessary的作用就是去生成一个AnnotationAwareAspectJAutoProxyCreator类对应的BeanDefinition。并把这个BeanDefinition注册到registry中。 注解使用@EnableAspectJAutoProxy 该注解的定义： 有个@Import，它会把类引入到Spring中，看AspectJAutoProxyRegistrar 实现了ImportBeanDefinitionRegistrar那么在注解解析完并且BeanDefinition创建注册完后会调用方法registerBeanDefinitions。看到了一个熟悉的方法 1AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); 在xml中已经解析过了，就是创建AnnotationAwareAspectJAutoProxyCreator的BeanDefinition，然后注册。剩下的代码就是AOP对应接口的检查和AOP注解的解析了。 Spring中的AOP使用在前上一节就已经讲了Spring中AOP的使用了。在使用注解模式的时候，其本质就是转化成接口模式。先有这个概念。 AnnotationAwareAspectJAutoProxyCreator现在看下AnnotationAwareAspectJAutoProxyCreator的类图 从类图上可知，AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor接口，而这个接口是继承了BeanPostProcessor这节中点看postProcessAfterInitialization方法，这是AOP的入口方法。 wrapIfNecessary1234567891011121314151617181920212223242526272829//AnnotationAwareAspectJAutoProxyCreatorprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; //创建当前bean的代理，如果这个bean有advice的话，重点看，重要程度5 // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); //如果有切面，则生成该bean的代理 if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); //把被代理对象bean实例封装到SingletonTargetSource对象中 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 这个方法就是检查是否需要对类进行包装，如果需要，就生成一个代理类。而判断依据就是方法getAdvicesAndAdvisorsForBean方法的返回值。而getAdvicesAndAdvisorsForBean方法用一句话总结就是：获取切面或者增强对象。而这个方法是在AbstractAdvisorAutoProxyCreator中实现的。 获取匹配的切面——getAdvicesAndAdvisorsForBean12345678910111213141516171819202122232425//AnnotationAwareAspectJAutoProxyCreatorprotected Object[] getAdvicesAndAdvisorsForBean( Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) &#123; //找到合格的切面，重点看 List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) &#123; return DO_NOT_PROXY; &#125; return advisors.toArray();&#125;//AnnotationAwareAspectJAutoProxyCreatorprotected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; //找到候选的切面,其实就是一个寻找有@Aspectj注解的过程，把工程中所有有这个注解的类封装成Advisor返回 List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); //判断候选的切面是否作用在当前beanClass上面，就是一个匹配过程。。现在就是一个匹配 List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); //针对@Aspect注解切面添加了一个默认的切面 DefaultPointcutAdvisor extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; //对有@Order@Priority进行排序 eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 这个方法就是对切面Advisor的收集了。 findCandidateAdvisors——获取（创建）所有Advisor这两个方法有两个地方有实现 由于是通过AnnotationAwareAspectJAutoProxyCreator调用的，所以我们只看这个就好了。 AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors 12345678910111213//AnnotationAwareAspectJAutoProxyCreator@Overrideprotected List&lt;Advisor&gt; findCandidateAdvisors() &#123; // Add all the Spring advisors found according to superclass rules. //找到所有的Advisor List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory. //主要看这里，创建候选的切面 对@Aspect注解的类进行处理 if (this.aspectJAdvisorsBuilder != null) &#123; advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); &#125; return advisors;&#125; 它先调了父类的findCandidateAdvisors，看父类也就是AbstractAdvisorAutoProxyCreator。 12345//AbstractAdvisorAutoProxyCreatorprotected List&lt;Advisor&gt; findCandidateAdvisors() &#123; Assert.state(this.advisorRetrievalHelper != null, &quot;。。。。&quot;); return this.advisorRetrievalHelper.findAdvisorBeans();&#125; 获取实现了Advisor接口的实例BeanFactoryAdvisorRetrievalHelper#findAdvisorBeans 1234567891011121314151617181920212223242526272829303132//BeanFactoryAdvisorRetrievalHelperpublic List&lt;Advisor&gt; findAdvisorBeans() &#123; String[] advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) &#123; advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; &#125; if (advisorNames.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); for (String name : advisorNames) &#123; if (isEligibleBean(name)) &#123; if (this.beanFactory.isCurrentlyInCreation(name)) &#123; //去掉日志打印 。。。 &#125; else &#123; try &#123; advisors.add(this.beanFactory.getBean(name, Advisor.class)); &#125; catch (BeanCreationException ex) &#123; //去掉重要代码 。。。 &#125; &#125; &#125; &#125; return advisors;&#125; 先找到实现了Advisor接口的BeanName，后面的for循环就是根据名字beanFactory.getBean放入到一个集合中并且返回。 回到AnnotationAwareAspectJAutoProxyCreator#findCandidateAdvisors方法 getAdvisors——根据注解@Aspect生成一个个Advisor对象看BeanFactoryAspectJAdvisorsBuilder#buildAspectJAdvisors方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//BeanFactoryAspectJAdvisorsBuilder//省略了部分代码...List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();aspectNames = new ArrayList&lt;&gt;();//获取spring容器中的所有bean的名称BeanNameString[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Object.class, true, false);for (String beanName : beanNames) &#123; if (!isEligibleBean(beanName)) &#123; continue; &#125; Class&lt;?&gt; beanType = this.beanFactory.getType(beanName); if (beanType == null) &#123; continue; &#125; //判断类上是否有@Aspect注解 if (this.advisorFactory.isAspect(beanType)) &#123; aspectNames.add(beanName); AspectMetadata amd = new AspectMetadata(beanType, beanName); if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123; //创建获取有@Aspect注解类的实例工厂，负责获取有@Aspect注解类的实例 MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); //创建切面advisor对象 List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) &#123; this.advisorsCache.put(beanName, classAdvisors); &#125; else &#123; this.aspectFactoryCache.put(beanName, factory); &#125; advisors.addAll(classAdvisors); &#125; else &#123; // Per target or per this. if (this.beanFactory.isSingleton(beanName)) &#123; throw new IllegalArgumentException(&quot;Bean with name &#x27;&quot; + beanName + &quot;&#x27; is a singleton, but aspect instantiation model is not singleton&quot;); &#125; MetadataAwareAspectInstanceFactory factory = new PrototypeAspectInstanceFactory(this.beanFactory, beanName); this.aspectFactoryCache.put(beanName, factory); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125;&#125;this.aspectBeanNames = aspectNames;return advisors;//省略了部分代码... 按功能看代码 先获取所有的beanName，然后遍历该接口。 判断有没有@Aspect这个注解。 后面就是根据注解生成切面的过程了，看源码： 创建了一个MetadataAwareAspectInstanceFactory工厂类对象，接着看核心代码 1List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); 这里的advisorFactory的对象是ReflectiveAspectJAdvisorFactory. 12345678910111213141516171819202122232425262728293031323334353637//ReflectiveAspectJAdvisorFactorypublic List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123; //从工厂中获取有@Aspect注解的类Class Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); //从工厂中获取有@Aspect注解的类的名称 String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName(); validate(aspectClass); //创建工厂的装饰类，获取实例只会获取一次 MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory); List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;(); //这里循环没有@Pointcut注解的方法 for (Method method : getAdvisorMethods(aspectClass)) &#123; //非常重要重点看看，重要程度 5 Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, 0, aspectName); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123; Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory); advisors.add(0, instantiationAdvisor); &#125; //判断属性上是否有引介注解 for (Field field : aspectClass.getDeclaredFields()) &#123; //判断属性上是否有DeclareParents注解，如果有返回切面 Advisor advisor = getDeclareParentsAdvisor(field); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; return advisors;&#125; 看第一for循环 通过getAdvisorMethods(aspectClass)获取了没有@Pointcut注解的有注解的方法，接着遍历执行getAdvisor方法。 getAdvisor——Advisor（切面）的创建——InstantiationModelAwarePointcutAdvisorImpl看这个方法的源码 123456789101112131415161718//ReflectiveAspectJAdvisorFactorypublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName) &#123; validate(aspectInstanceFactory.getAspectMetadata().getAspectClass()); //获取pointCut对象，最重要的是从注解中获取表达式 AspectJExpressionPointcut expressionPointcut = getPointcut( candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()); if (expressionPointcut == null) &#123; return null; &#125; //创建Advisor切面类，这才是真正的切面类，一个切面类里面肯定要有1、pointCut 2、advice //这里pointCut是expressionPointcut， advice 增强方法是 candidateAdviceMethod return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName);&#125; 整段代码做了三件事： pointcut的创建 advice的创建 根据前两步的pointcut和advice创建一个InstantiationModelAwarePointcutAdvisorImpl切面Advisor对象 pointcut的创建——AspectJExpressionPointcut12345678910111213141516171819202122232425262728293031323334private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123; //从候选的增强方法里面 candidateAdviceMethod 找有有注解 //Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class //并把注解信息封装成AspectJAnnotation对象 AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; //创建一个PointCut类，并且把前面从注解里面解析的表达式设置进去 AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]); ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); if (this.beanFactory != null) &#123; ajexp.setBeanFactory(this.beanFactory); &#125; return ajexp;&#125;protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123; //Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class for (Class&lt;?&gt; clazz : ASPECTJ_ANNOTATION_CLASSES) &#123; //找到Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class //注解的方法，并且把注解里面的信息封装成AspectJAnnotation对象 AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) clazz); if (foundAnnotation != null) &#123; return foundAnnotation; &#125; &#125; return null;&#125;private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] &#123; Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class&#125;; 整个代码下来就做一件事，就是找方法上是否有 Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class这些注解，有的话就把注解的信息封装成一个AspectJAnnotation对象，并在最后创建AspectJExpressionPointcut对象，并把AspectJAnnotation中的表达式赋值给AspectJExpressionPointcut，那么这时pointcut就已经创建了，而且这个pointcut的类型是AspectJExpressionPointcut 这里pointcut有两种情况： 注解中的值是表达式@Around(value = &quot;execution(public * com.enjoy.xyz.aop.bean.*.*(..))&quot;)这样的形式 注解中的值是符号引用 @Around(value = &quot;pc1()&quot;)这样的形式 对于这两种pointcut中的表达式（被代理方法的集合），第一种就是已经完成创建好pointcut了，第二种的情况创建完一半，剩下的一半需要把value中的符号变成确定的表达式。下边的讲解都一第二种情况为例 比如我定义这样一个类： 1234567891011121314@Component@Aspectpublic class AspectAnnotation &#123; @Pointcut(value = &quot;execution(public * com.enjoy.xyz.aop.bean.*.*(..))&quot;) public void pc1() &#123; &#125; @Around(value = &quot;pc1()&quot;) public void around1(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;around1----1&quot;); joinPoint.proceed(); System.out.println(&quot;around1----2&quot;); &#125;&#125; 经过了 getPointcut后获取到数据入下图 现在已经有expression&#x3D;pc()了，也就是说我们只要根据这个expression&#x3D;pc()就能找到对应的方法了，找到方法后就能找到方法上对应的@Pointcut的信息了。 好了，现在已经有了pointcut了，就差Advite了 Advice的创建——AbstractAspectJAdvice一个Advisor中要有一个pointcut和一个Advice。在注解的模式中，advice对应着一个方法。下面就看Advice是怎么创建的 看代码 这个构造方法传入的Advice的方法。然后看最后 123456private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) &#123; //创建Advice对象 Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut, this.aspectInstanceFactory, this.declarationOrder, this.aspectName); return (advice != null ? advice : EMPTY_ADVICE);&#125; 看ReflectiveAspectJAdvisorFactory#getAdvice 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) &#123; //获取有@Aspect注解的类 Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); validate(candidateAspectClass); //找到candidateAdviceMethod方法上面的注解，并且包装成AspectJAnnotation对象，这个对象中就有注解类型 AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; // If we get here, we know we have an AspectJ method. // Check that it&#x27;s an AspectJ-annotated class if (!isAspect(candidateAspectClass)) &#123; throw new AopConfigException(&quot;Advice must be declared inside an aspect type: &quot; + &quot;Offending method &#x27;&quot; + candidateAdviceMethod + &quot;&#x27; in class [&quot; + candidateAspectClass.getName() + &quot;]&quot;); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Found AspectJ method: &quot; + candidateAdviceMethod); &#125; AbstractAspectJAdvice springAdvice; //根据不同的注解类型创建不同的advice类实例 switch (aspectJAnnotation.getAnnotationType()) &#123; case AtPointcut: if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Processing pointcut &#x27;&quot; + candidateAdviceMethod.getName() + &quot;&#x27;&quot;); &#125; return null; case AtAround: //实现了MethodInterceptor接口 springAdvice = new AspectJAroundAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtBefore: //实现了MethodBeforeAdvice接口，没有实现MethodInterceptor接口 springAdvice = new AspectJMethodBeforeAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfter: //实现了MethodInterceptor接口 springAdvice = new AspectJAfterAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); break; case AtAfterReturning: //实现了AfterReturningAdvice接口，没有实现MethodInterceptor接口 springAdvice = new AspectJAfterReturningAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterReturningAnnotation.returning())) &#123; springAdvice.setReturningName(afterReturningAnnotation.returning()); &#125; break; case AtAfterThrowing: //实现了MethodInterceptor接口 springAdvice = new AspectJAfterThrowingAdvice( candidateAdviceMethod, expressionPointcut, aspectInstanceFactory); AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation(); if (StringUtils.hasText(afterThrowingAnnotation.throwing())) &#123; springAdvice.setThrowingName(afterThrowingAnnotation.throwing()); &#125; break; default: throw new UnsupportedOperationException( &quot;Unsupported advice type on method: &quot; + candidateAdviceMethod); &#125; // Now to configure the advice... springAdvice.setAspectName(aspectName); springAdvice.setDeclarationOrder(declarationOrder); //获取注解中的argNames属性参数名称 String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod); if (argNames != null) &#123; springAdvice.setArgumentNamesFromStringArray(argNames); &#125; //计算argNames和类型的对应关系 springAdvice.calculateArgumentBindings(); return springAdvice;&#125; 有多种Advice Around —— AspectJAroundAdvice Before —— AspectJMethodBeforeAdvice After —— AspectJAfterAdvice AfterReturning —— AspectJAfterReturningAdvice AfterThrowing —— AspectJAfterThrowingAdvice 上面的Advice都实现了MethodInterceptor接口 在Spring中实现一个Advice，有两种方法，实现Advice接口、另一个实现MethodInterceptor接口。用得最多的就是实现MethodInterceptor接口的。 MethodInterceptor的invoke方法就是增强逻辑的调用方法。和动态代理一样。 总结现在Pointcut是AspectJExpressionPointcut，Advite已经有了，最后一步就是把它们封装成一个切面Advisor。 InstantiationModelAwarePointcutAdvisorImpl是实现了PointcutAdvisor接口的，所以他是一个切面 经过getAdvisor，会获得到这样一个关系 最后就把这些新建的Advisor放入到集合中并返回。 排序在收集有注解的方法时就已经排序了 在这里会先根据上图的顺排序，相同的就根据方法的名字把方法排序好： 所以，在生成切面Advisor后的advisors集合就是有序的 总结findCandidateAdvisors方法就是找到候选的切面。 找实现了Advisor接口的类，获取其实例。 寻找有@Aspectj注解，并解析有@Around、@Before等注解的value，用来创建成一个piontCut对象，接着根据对应注解，把方法封装成对应的Advice对象，最终把Advice和pointCut封装成一个Advisor对象该对象类型是InstantiationModelAwarePointcutAdvisorImpl。然后缓存这个bean的。advisors集合，建立&lt;beanName, advisors&gt;这种关系。最后把工程中所有有的Advisor返回。 注意，在解析注解是，是没有处理@Pointcut这个注解的，至于为什么，后面讲 findAdvisorsThatCanApply——Advisor匹配过程上边是找到所用的Advisor，但不是所有的Advisor都适用在这个对象上面的，所以这一步就是一个匹配的过程。跟踪代码到： 12345678910111213141516171819202122232425//AopUtilspublic static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123; if (candidateAdvisors.isEmpty()) &#123; return candidateAdvisors; &#125; List&lt;Advisor&gt; eligibleAdvisors = new ArrayList&lt;&gt;(); for (Advisor candidate : candidateAdvisors) &#123; //如果是引介切面并且匹配 if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; boolean hasIntroductions = !eligibleAdvisors.isEmpty(); //调用pointCut中的ClassFilter 和methodMatcher的match方法的过程 for (Advisor candidate : candidateAdvisors) &#123; if (candidate instanceof IntroductionAdvisor) &#123; // already processed continue; &#125; if (canApply(candidate, clazz, hasIntroductions)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; return eligibleAdvisors;&#125; 看canApply，继续跟踪代码到 1234567891011121314151617181920212223242526272829303132333435363738public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; Assert.notNull(pc, &quot;Pointcut must not be null&quot;); //调用ClassFilter的matches方法，判断类是否匹配 if (!pc.getClassFilter().matches(targetClass)) &#123; return false; &#125; MethodMatcher methodMatcher = pc.getMethodMatcher(); if (methodMatcher == MethodMatcher.TRUE) &#123; // No need to iterate the methods if we&#x27;re matching any method anyway... return true; &#125; IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123; introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; &#125; Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;&gt;(); if (!Proxy.isProxyClass(targetClass)) &#123; classes.add(ClassUtils.getUserClass(targetClass)); &#125; classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass)); //判断类中方法是否匹配，，有些可能是方法上面有注解的拦截，所以需要判断方法是否匹配 for (Class&lt;?&gt; clazz : classes) &#123; Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) &#123; if (introductionAwareMethodMatcher != null ? introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) : methodMatcher.matches(method, targetClass)) &#123; return true; &#125; &#125; &#125; return false;&#125; 这个方法就是尽心pointcut的匹配，只有类和方法匹配都通过了。就表示这个Advisor就是这个这个bean切面。 判断类是否匹配 pc是一个Pointcut，看这个，因为在前面创建的Pointcut的类型是这个 看AspectJExpressionPointcut#matches 123456789101112131415161718public boolean matches(Class&lt;?&gt; targetClass) &#123; //这里会根据@Around(&quot;pc1()&quot;)配置中的pc1找到pc1方法从而找到真正的pointCut表达式 PointcutExpression pointcutExpression = obtainPointcutExpression(); try &#123; try &#123; //匹配targetClass是否在表达式中 return pointcutExpression.couldMatchJoinPointsInType(targetClass); &#125; catch (ReflectionWorldException ex) &#123; //去掉不重要的代码 ..... &#125; &#125; catch (Throwable ex) &#123; logger.debug(&quot;PointcutExpression matching rejected target class&quot;, ex); &#125; return false;&#125; 先看 1PointcutExpression pointcutExpression = obtainPointcutExpression(); 这一行会根据Pointcut的expression获取到对应的方法，然后获取方法的@Pointcut的信息，最后封装成了PointcutExpression。也就是说，比如这时的Pointcut对象是从这个注解生成的@Around(&quot;pc1()&quot;)，那就会去找pc1()方法上@Pointcut注解信息。 现在有了@Pointcut的信息了，然后调用 1pointcutExpression.couldMatchJoinPointsInType(targetClass) 去检查类的全限定名是否符合expression就好了。流程就这样，这里的细节就不扣了。 判断类中方法是否匹配 走到这就要意味着类是匹配的，接着就看方法是否匹配了，这里逻辑和上边是一样的，只是可以记下 1Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); Spring中ReflectionUtils工具类 总结就是通过pointcut进行类匹配和方法匹配，最后把匹配到的Advisor返回 extendAdvisors——添加ExposeInvocationInterceptor增强在执行extendAdvisors前 执行了extendAdvisors后 从上图可以看到，匹配的切面多了一个ExposeInvocationInterceptor.ADVISOR，而且这个切面放在第一的位置。跟踪源码 从isAspectJAdvice从源码可知，只有在使用注解创建切面后才需要引入这个默认的切面。应为InstantiationModelAwarePointcutAdvisor、AbstractAspectJAdvice和AspectJExpressionPointcut这三个都是在扫描到对应的aop注解后所生成的对应的类。 sortAdvisors做最后一次排序，这个排序是对有@Order @Priority进行排序 回到wrapIfNecessary 这行代码执行完了，已经得到了切面对象了，代码继续走 这段代码的，如果有切面的话就为bean生成一个代理对象。并返回代理对象。而且会把代理对象放入到一级缓存singletonObjects中。 创建代理对象——createProxy简单的看下createProxy源码 1234567891011121314151617181920212223242526272829303132333435//AbstractAutoProxyCreatorprotected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123; if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123; AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); &#125; ProxyFactory proxyFactory = new ProxyFactory(); //把AnnotationAwareAspectJAutoProxyCreator中的某些属性copy到proxyFactory中 proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) &#123; if (shouldProxyTargetClass(beanClass, beanName)) &#123; proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; //组装advisor Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); //把advisor加入到proxyFactory proxyFactory.addAdvisors(advisors); //把targetSource对象加入到proxyFactory proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; //获取代理对象 return proxyFactory.getProxy(getProxyClassLoader());&#125; 首先创建了一个ProxyFactory proxyFactory = new ProxyFactory(); 先下这个类的类图： 看 Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); 1234567891011121314151617181920212223242526272829protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) &#123; // Handle prototypes correctly... //设置自定义的MethodInterceptor 和 Advice Advisor[] commonInterceptors = resolveInterceptorNames(); List&lt;Object&gt; allInterceptors = new ArrayList&lt;&gt;(); if (specificInterceptors != null) &#123; allInterceptors.addAll(Arrays.asList(specificInterceptors)); if (commonInterceptors.length &gt; 0) &#123; if (this.applyCommonInterceptorsFirst) &#123; allInterceptors.addAll(0, Arrays.asList(commonInterceptors)); &#125; else &#123; allInterceptors.addAll(Arrays.asList(commonInterceptors)); &#125; &#125; &#125; if (logger.isTraceEnabled()) &#123; int nrOfCommonInterceptors = commonInterceptors.length; int nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0); ..... &#125; Advisor[] advisors = new Advisor[allInterceptors.size()]; for (int i = 0; i &lt; allInterceptors.size(); i++) &#123; advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i)); &#125; return advisors;&#125; 添加全局的切面在这个方法中有一个有意思的方法resolveInterceptorNames，看下后面的代码 通过resolveInterceptorNames生成的Advisor会被添加到allInterceptors的首位。而在这个方法resolveInterceptorNames我们是能做一些操作的。比如添加一个[全局的拦截器](.&#x2F;Spring 全局（切面）的拦截器)。 也就是说，这样做了后只要通过代理对象调用被拦截的方法，那我们添加的都会被调用到。 创建代理——proxyFactory.getProxy(buildAdvisors执行完后就返回了所有需要被执行的切面，看createProxy的源码看到， 而且在最后会把这Advisor数组设置到ProxyFactory中。 最后就是生成代理了。有两种代理方式。 我门先跟踪下createAopProxy()的方法 1234567891011121314151617181920212223242526//ProxyCreatorSupportprotected final synchronized AopProxy createAopProxy() &#123; if (!this.active) &#123; activate(); &#125; return getAopProxyFactory().createAopProxy(this);&#125;//DefaultAopProxyFactory@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; + &quot;Either an interface or a target is required for proxy creation.&quot;); &#125; if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125;&#125; 从源码发现，如果有接口的情况下会走JDK的代理，如果没有就走CGLIB的代理 可以看到，两种代理在创建的时候都会把AdvisedSupport对象作为入参传入，而这个AdvisedSupport对象就是之前创建的ProxyFactory。 我更熟悉JDK的动态代理，所以看下JdkDynamicAopProxy#getProxy方法（Cglib就是api不同，整体的逻辑都是一样的） 123456789@Overridepublic Object getProxy(@Nullable ClassLoader classLoader) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Creating JDK dynamic proxy: &quot; + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 可以看到，这个动态代理的InvocationHandler是this，也就是JdkDynamicAopProxy。这个类还有一个重要的属性， 这个引用指向的是ProxyFactory，而这个ProxyFactory从这个creaetProxy的代码中可以发现，他的作用就是用来保存一些必要的信息的，最重要的一个信息就是这个类匹配到的切面列表。剩下的InvocationHandler的invoke方法是怎么实现的，就在下节讲。 总结整个流程就是判断这个类是否有切面，判断的逻辑就是先获取全部的切面。 实现了Advisor接口的类的实例——直接通过beanFactory.getBean获取 有@Aspect注解的类——从缓存拿，没有的话根据@Around、@Before等注解的信息生成一个pointcut对象，然后再把方法封装成对应的Advice，接着把pointcut和Advice封装成一个Advisor。最后把Advisor放入缓存。而这里的实现类分别如下 123456789Advisor——InstantiationModelAwarePointcutAdvisorImplPointcut——AspectJExpressionPointcutAdvice对应的类型有点过，不过这些都是AbstractAspectJAdvice的子类- Around —— AspectJAroundAdvice- Before —— AspectJMethodBeforeAdvice- After —— AspectJAfterAdvice- AfterReturning —— AspectJAfterReturningAdvice- AfterThrowing —— AspectJAfterThrowingAdvice 获取到全部切面后，再遍历Advisor对象，根据pointcut找到对应的方法并获取该方法的@Pointcut注解的信息，然后看类和方法是否匹配，如果匹配就放入到一个集合中。 接着如果使用了@AOP的注解，而且bean也匹配到了通过注解生成的Advisor对象，那会添加一个切面，这个切面的pointcut为Pointcut.TURE，advice为ExposeInvocationInterceptor 最后，如果返回的集合不为空，就为bean生成一个代理对象。在生成代理对象时，可以通过[这种模式](.&#x2F;Spring 全局（切面）的拦截器)来生成一个全局的切面","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"08-Spring-AOP概念","slug":"spring/5.2.8/08-Spring-AOP概念","date":"2021-11-20T12:00:14.000Z","updated":"2022-03-14T09:04:25.779Z","comments":true,"path":"blog/spring/5.2.8/08-Spring-AOP概念/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/08-Spring-AOP%E6%A6%82%E5%BF%B5/","excerpt":"","text":"Spring-AOP-概念AOP-概念连接点（Joinpoint）&#x3D;&#x3D; 一个连接点就对应着一个被代理方法程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。 切点（Pointcut）&#x3D;&#x3D; 连接点的集合每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责切点所设定的查询条件，找到对应的连接点。其实确切地说，不能称之为查询连接点，因为连接点是方法执行前、执行后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体连接点上，还需要提供方位信息。 增强（Advice） &#x3D;&#x3D; 具体增强的代码逻辑增强是织入到目标类连接点上的一段程序代码，在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。 目标对象（Target）增强逻辑的织入目标类。如果没有AOP，目标业务类需要自己实现所有逻辑，而在AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用AOP动态织入到特定的连接点上。 引介（Introduction）和 织入（Weaving）引介（Introduction）引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。 织入（Weaving）织入是将增强添加对目标类具体连接点上的过程。AOP像一台织布机，将目标类、增强或引介通过AOP这台织布机天衣无缝地编织到一起。根据不同的实现技术，AOP有三种织入的方式： 编译期织入，这要求使用特殊的Java编译器。 类装载期织入，这要求使用特殊的类装载器。 动态代理织入，在运行期为目标类添加增强生成子类的方式。 Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 代理（Proxy） &#x3D;&#x3D; 动态生成的一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。 切面（Aspect、advisor） &#x3D;&#x3D; 一类功能（日志功能，事务功能，缓存功能）切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。advisor：必须要用 pointCut、advice Spring中的AOP概念在Spring中对AOP的概念做了简化。在Spring中只有切面、切点和增强 切面（Aspect、advisor）一类功能（日志功能，事务功能，缓存功能）必须要有Pointcut、Advice 切点（Pointcut）&#x3D;&#x3D; 被代理方法的集合作用：匹配、拦截目的： 为了生成代理对象 用代理对象调用的时候会匹配 一个Pointcut中会有这两个： ClassFiter &#x3D;&#x3D; 类是它拦截 MethodMatcher &#x3D;&#x3D; 方法是它匹配 增强（Advice） &#x3D;&#x3D; 具体增强的代码逻辑承载了具体的增强的代码逻辑 在Spring中使用有两种方法，一种是注解，一种是接口 注解12345678910111213141516171819202122232425262728293031323334@Component@Aspect@EnableAspectJAutoProxy()public class AspectAnnotation &#123; @Pointcut(value = &quot;execution(public * com.enjoy.xyz.aop.bean.*.*(..))&quot;) public void pc1() &#123; &#125; @Before(value = &quot;pc1()&quot;) public void before1() throws Throwable &#123; System.out.println(&quot;before1----1&quot;); &#125; @After(value = &quot;pc1()&quot;) public void after1() &#123; System.out.println(&quot;after1----1&quot;); &#125; @Around(value = &quot;pc1()&quot;) public void around1(ProceedingJoinPoint joinPoint) throws Throwable &#123; //可以通过这个或来去参数和方法 MethodInvocation methodInvocation = ExposeInvocationInterceptor.currentInvocation(); System.out.println(&quot;around1----1&quot;); joinPoint.proceed(); System.out.println(&quot;around1----2&quot;); &#125; @Around(value = &quot;pc1()&quot;) public void around2(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;around2---1&quot;); joinPoint.proceed(); System.out.println(&quot;around2---2&quot;); &#125;&#125; 开启： 1234@Component@EnableAspectJAutoProxy()public class AopConfig &#123;&#125; 接口切面123456789101112131415161718192021222324252627@Componentpublic class CustomAdvisor implements PointcutAdvisor &#123; // 切点 @Autowired private CustomPointcut pointcut; // 增强 @Autowired private CustomAdvice advice; @Override public Pointcut getPointcut() &#123; return pointcut; &#125; @Override public Advice getAdvice() &#123; return advice; &#125; @Override public boolean isPerInstance() &#123; return false; &#125;&#125; 切点、增强切点要实现Pointcut接口、增强要实现MethodMatcher接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Componentpublic class CustomPointcut implements Pointcut, MethodMatcher &#123; /** * 所有类都匹配 * @return */ @Override public ClassFilter getClassFilter() &#123; return ClassFilter.TRUE; &#125; @Override public MethodMatcher getMethodMatcher() &#123; return this; &#125; /** * 所有方法都匹配 * @param method * @param targetClass * @return */ @Override public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //拿原始方法对象，这个方法上才有注解 Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass); if(AnnotatedElementUtils.hasAnnotation(specificMethod, CustomCache.class)) &#123; method.getAnnotations(); return true; &#125; return false; &#125; @Override public boolean isRuntime() &#123; return true; &#125; /** * 参数匹配 * * @param method * @param targetClass * @param args * @return */ @Override public boolean matches(Method method, Class&lt;?&gt; targetClass, Object... args) &#123; if (args.length &gt; 0 &amp;&amp; args[0] != null) &#123; return &quot;xyz&quot;.equalsIgnoreCase(args[0].toString()); &#125; return false; &#125;&#125;@Componentpublic class CustomAdvice implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;我是自定义的AOP--before&quot;); Object obj = invocation.proceed(); System.out.println(&quot;我是自定义的AOP--after&quot;); return obj; &#125;&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"07-Spring中基于注解--ConfigurationClassPostProcessor","slug":"spring/5.2.8/07-Spring中基于注解--ConfigurationClassPostProcessor","date":"2021-11-20T12:00:13.000Z","updated":"2022-03-14T09:04:25.778Z","comments":true,"path":"blog/spring/5.2.8/07-Spring中基于注解--ConfigurationClassPostProcessor/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/07-Spring%E4%B8%AD%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3--ConfigurationClassPostProcessor/","excerpt":"","text":"Spring中基于注解–ConfigurationClassPostProcessor基于注解的就是去处理这些注解 @PropertySources、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource、@Configuration、@Value 这些注解的处理都是类ConfigurationClassPostProcessor实现的。（@Value还会通过AutowiredAnnotationBeanPostProcessor处理） 之前讲bean的初始化阶段都是基于ClassPathXmlApplicationContext这个上下文对象的，现在讲注解了，使用下面的上下文类AnnotationConfigApplicationContext，看下该类的类图： 从类图可以看到，该上下文类继承了GenericApplicationContext，而GenericApplicationContext实现了BeanDefinitionRegistry接口，也就是说上下文类AnnotationConfigApplicationContext将作为BeanDefinition的注册器。但如果继续看GenericApplicationContext： 将会发现这里只是使用了代理模式而已，GenericApplicationContext作为DefaultListableBeanFactory的代理类，真正的BeanDefinition的注册器还是DefaultListableBeanFactory。 比如有下面这一代码段： 12345678910111213141516@ComponentScans(&#123;@ComponentScan(&quot;xx&quot;), @ComponentScan(&quot;aa&quot;)&#125;)@Component@ComponentScan(value = &quot;com.enjoy.jack&quot;/*,includeFilters = ,basePackages = */)//&lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt;@PropertySource(name = &quot;jack&quot;, value = &quot;classpath:application.properties&quot;)public class ScanBean &#123;&#125;@Testpublic void test2() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ScanBean.class); StudentService bean = applicationContext.getBean(StudentService.class); System.out.println(bean); bean.sleep(new ArrayList()); bean.eat(&quot;Jack1&quot;);&#125; 看AnnotationConfigApplicationContext的对应的构造方法 12345678910public AnnotationConfigApplicationContext() &#123; this.reader = new AnnotatedBeanDefinitionReader(this); this.scanner = new ClassPathBeanDefinitionScanner(this);&#125;public AnnotationConfigApplicationContext(Class&lt;?&gt;... componentClasses) &#123; this(); register(componentClasses); refresh();&#125; 上面创建了两个对象，分别是ClassPathBeanDefinitionScanner和AnnotatedBeanDefinitionReader。ClassPathBeanDefinitionScanner之前已经说过了，它的作用就是扫描包，找有@Component等注解的类。而AnnotatedBeanDefinitionReader将在下面介绍它的职能。 继续看下一行代码 1register(componentClasses); 实际的作用就是把ScanBean这个类封装成AnnotatedGenericBeanDefinition然后注册到BeanDefinitionRegistry，也就是AnnotationConfigApplicationContext中。 12345678@Overridepublic void register(Class&lt;?&gt;... componentClasses) &#123; Assert.notEmpty(componentClasses, &quot;At least one component class must be specified&quot;); this.reader.register(componentClasses);&#125; ---&gt;AnnotatedBeanDefinitionReader.register(Class&lt;?&gt;... componentClasses) ---&gt;AnnotatedBeanDefinitionReader.registerBean(Class&lt;?&gt; beanClass) ---&gt;AnnotatedBeanDefinitionReader.doRegisterBean 从上面的代码可以发现一个问题，就是AnnotationConfigApplicationContext将类的信息封装成BeanDefinition这一步时委托给了AnnotatedBeanDefinitionReader这个对象完成的。而且，AnnotatedBeanDefinitionReader.deRegisterBean也就是这节重点讲解的方法。 最后看 1refresh(); AnnotationConfigApplicationContext没有重写refresh方法，所以refresh方法是从父类继承过来的 AbstractApplicationContext#refresh，这段代码讲了很多次了。 AnnotationConfigApplicationContext执行了refresh后，代码执行到了obtainFreshBeanFactory方法 12345protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; //核心方法，必须读，重要程度：5 refreshBeanFactory(); return getBeanFactory();&#125; 其中refreshBeanFactory方法有两个实现。 看回AnnotationConfigApplicationContext的类图，它的父类是GenericApplicationContext，所以refreshBeanFactory方法是从父类GenericApplicationContext继承过来的。 现在看GenericApplicationContext#refreshBeanFactory方法。 它什么都不做，这里就和ClassPathXmlApplicationContext完全不同了，ClassPathXmlApplicationContext会在这里添加完成扫描和BeanDefinition的创建和注册，但在AnnotationConfigApplicationContext中，这里基本什么都不做。 那BeanDefinition的创建和注册是在什么时候完成的？ 回到构造方法： 在初始化AnnotationConfigApplicationContext创建了AnnotatedBeanDefinitionReader，在上边已经简单的说了该类的作用，但去看该类的构造方法时会发现该类还有另一个作用。看下这个类的构造方法： 123456789101112// AnnotatedBeanDefinitionReaderpublic AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; this(registry, getOrCreateEnvironment(registry));&#125;public AnnotatedBeanDefinitionReader(BeanDefinitionRegistry registry, Environment environment) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); Assert.notNull(environment, &quot;Environment must not be null&quot;); this.registry = registry; this.conditionEvaluator = new ConditionEvaluator(registry, environment, null); AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);&#125; 重点是这行代码。 1AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); 还记得这行代码吗？在讲xml的自定义标签解析，解析这个时 讲过——在ClassPathBeanDefinitionScanner讲包的类扫描出来后，在对应的BeanDefinitionParser类——ComponentScanBeanDefinitionParser，把有对应的注解的类封装成ScannedGenericBeanDefinition后，在最后执行这一行代码: 还记得这个方法的作用吗？ 这个方法会把一些BeanPostProcessor封装成RootBeanDefinition，注册到BeanDefinitionRegistry中 之前我们重点关注的是 ConfigurationClassPostProcessor AutowiredAnnotationBeanPostProcessor CommonAnnotationBeanPostProcessor 在前面的章节已经讲过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor，这两个类是在Bean的初始化步骤中，注解收集和依赖注入起到作用。剩下的ConfigurationClassPostProcessor还没讲过他的作用。我们看下ConfigurationClassPostProcessor的类图： 可以看到ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口的，也就是说在AbstractApplicationContext#refresh方法执行到 1invokeBeanFactoryPostProcessors(beanFactory) 这行代码时会触发ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry方法的调用。通过之前对BeanDefinitionRegistryPostProcessor的讲解，已经知道了postProcessBeanDefinitionRegistry方法就是对BeanDefinition做一些操作的，比如添加也是可以的。下面看ConfigurationClassPostProcessor类。 ConfigurationClassPostProcessor 看ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry源码： 12345678910111213141516public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) &#123; throw new IllegalStateException( &quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry); &#125; if (this.factoriesPostProcessed.contains(registryId)) &#123; throw new IllegalStateException( &quot;postProcessBeanFactory already called on this post-processor against &quot; + registry); &#125; this.registriesPostProcessed.add(registryId); //核心逻辑，重点看，重要程度5 processConfigBeanDefinitions(registry);&#125; ConfigurationClassPostProcessor#processConfigBeanDefinitions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); //获取所有的beanNames String[] candidateNames = registry.getBeanDefinitionNames(); for (String beanName : candidateNames) &#123; BeanDefinition beanDef = registry.getBeanDefinition(beanName); //如果有该标识就不再处理 if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); &#125; &#125; //判断是否是候选的需要处理的BeanDefinition，如果是则放入容器configCandidates else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found //如果容器为空，则直接返回 if (configCandidates.isEmpty()) &#123; return; &#125; // Sort by previously determined @Order value, if applicable //对需要处理的所有beanDefinition排序 configCandidates.sort((bd1, bd2) -&gt; &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) &#123; this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; &#125; if (this.environment == null) &#123; this.environment = new StandardEnvironment(); &#125; //候选BeanDefinition的解析器 // Parse each @Configuration class ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do &#123; //解析核心流程，重点看，重要程度5 //其实就是把类上面的特殊注解解析出来最终封装成beanDefinition parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; //@Bean @Import 内部类 @ImportedResource ImportBeanDefinitionRegistrar具体处理逻辑 this.reader.loadBeanDefinitions(configClasses); //已经解析完成了的类 alreadyParsed.addAll(configClasses); candidates.clear(); //比较差异又走一遍解析流程 if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#x27;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125;&#125; 代码很长，这里我根据功能看. 对需要生成BeanDefinition的类进行收集 1beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) 这个方法的作用就是看该BeanDefinition的属性中有没有org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass这个key对应的属性值。在第一次的情况下该判断会返回false，所以这段代码主要看这行代码 1ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 看该方法的部分重要的代码段： 这里有两个逻辑，如果有@Configuration注解，就对BeanDefinition做如下标记: 12beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass=full 如果没有@Configuration但有@Component、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource注解的话就对BeanDefinition做如下标记: 12beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);org.springframework.context.annotation.ConfigurationClassPostProcessor.configurationClass=lite 这个标记的作用在后面会讲到。 最后： 如有有@Order注解，就取值并设置到BeanDefinition中。 其实ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory) 整个流程就是判断为BeanDefinition是否有@Component、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource、@Configuration这类注解，有就做标记并返回true。true就代表这个BeanDefinition需要被&#96;&#96;ConfigurationClassPostProcessor&#96;进一步处理。 回到ConfigurationClassPostProcessor#processConfigBeanDefinitions 对需要处理的所有beanDefinition进行升序排序，接着就是重点了 ConfigurationClassParser#parse看ConfigurationClassParser#parse 123456789101112131415161718192021222324252627public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123; for (BeanDefinitionHolder holder : configCandidates) &#123; BeanDefinition bd = holder.getBeanDefinition(); try &#123; //扫描注解得到的BeanDefinition if (bd instanceof AnnotatedBeanDefinition) &#123; parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); &#125; //非扫描注解得到的BeanDefinition else if (bd instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123; parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); &#125; else &#123; parse(bd.getBeanClassName(), holder.getBeanName()); &#125; &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( &quot;Failed to parse configuration class [&quot; + bd.getBeanClassName() + &quot;]&quot;, ex); &#125; &#125; //这行代码不能忽视 this.deferredImportSelectorHandler.process();&#125; 该方法的入参，就是之前收集的，有@Component、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource、@Configuration这些注解的类进行遍历解析。 到了一个重点方法了，看parse方法 12345protected final void parse(@Nullable String className, String beanName) throws IOException &#123; Assert.notNull(className, &quot;No bean class name for configuration class bean definition&quot;); MetadataReader reader = this.metadataReaderFactory.getMetadataReader(className); processConfigurationClass(new ConfigurationClass(reader, beanName), DEFAULT_EXCLUSION_FILTER);&#125; 看processConfigurationClass ConfigurationClassParser#processConfigurationClass其实就是把类上面的注解解析出来最终封装成beanDefinition 12345678910111213141516171819protected void processConfigurationClass(ConfigurationClass configClass, Predicate&lt;String&gt; filter) throws IOException &#123; // 对@Condition注解的支持，过滤掉不需要实例化的类 if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123; return; &#125; //不关注的代码 .... //这个对象理解为跟类或者接口对应，然后把metadata对象包装进去了 // Recursively process the configuration class and its superclass hierarchy. SourceClass sourceClass = asSourceClass(configClass, filter); do &#123; //核心代码，认真读 sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter); &#125; while (sourceClass != null); this.configurationClasses.put(configClass, configClass);&#125; 条件判断 12345678910111213141516171819202122232425262728293031323334353637383940public boolean shouldSkip(@Nullable AnnotatedTypeMetadata metadata, @Nullable ConfigurationPhase phase) &#123; if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) &#123; return false; &#125; if (phase == null) &#123; if (metadata instanceof AnnotationMetadata &amp;&amp; ConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) &#123; return shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION); &#125; return shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN); &#125; List&lt;Condition&gt; conditions = new ArrayList&lt;&gt;(); //获取@Conditional注解的value值 for (String[] conditionClasses : getConditionClasses(metadata)) &#123; for (String conditionClass : conditionClasses) &#123; //反射实例化Condition对象 Condition condition = getCondition(conditionClass, this.context.getClassLoader()); conditions.add(condition); &#125; &#125; //排序 AnnotationAwareOrderComparator.sort(conditions); //调用每一个condition的matches方法 for (Condition condition : conditions) &#123; ConfigurationPhase requiredPhase = null; if (condition instanceof ConfigurationCondition) &#123; requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase(); &#125; //调用matches方法 if ((requiredPhase == null || requiredPhase == phase) &amp;&amp; !condition.matches(this.context, metadata)) &#123; return true; &#125; &#125; return false;&#125; 这段代码的作用就是，当我有这样的注解时 对应的类 123456public class CustomCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; return true; &#125;&#125; 也就是，直到CustomCondition的matchs返回为true上面的代码才会玩下走，也就是BeanDefinition才能生成。 也可以自定义条件注解 自定义条件注解12345678910@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(value = OnClassCondition.class)public @interface ConditionOnClass &#123; Class&lt;?&gt;[] value() default &#123;&#125;; String[] name() default &#123;&#125;;&#125; 12345678910111213141516public class OnClassCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(metadata.isAnnotated(ConditionOnClass.class.getName())) &#123; Map&lt;String, Object&gt; annotationAttributes = metadata.getAnnotationAttributes(ConditionOnClass.class.getName()); try &#123; ClassUtils.forName(annotationAttributes.get(&quot;name&quot;).toString(),ClassUtils.getDefaultClassLoader()); return true; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); return false; &#125; &#125; return false; &#125;&#125; 使用： 1234567@Component@Conditional(value = &#123;CustomCondition.class,CustomCondition1.class&#125;)@ConditionOnClass(name = &quot;com.enjoy.jack.bean.circular.CircularRefConB&quot;)@ConditionOnProperty(name = &quot;cn.enjoy.flag&quot;)public class ConditionalBean &#123;&#125; 接着看processConfigurationClass方法 需要生成BeanDefinition的类的收集和一些接口的执行核心看ConfigurationClassParser#doProcessConfigurationClass 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798protected final SourceClass doProcessConfigurationClass( ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException &#123; //判断类上面是否有Component注解 if (configClass.getMetadata().isAnnotated(Component.class.getName())) &#123; // Recursively process any member (nested) classes first //递归处理有@Component、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource注解的内部类 processMemberClasses(configClass, sourceClass, filter); &#125; // Process any @PropertySource annotations //处理PropertySources和 PropertySource注解 for (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), PropertySources.class, org.springframework.context.annotation.PropertySource.class)) &#123; if (this.environment instanceof ConfigurableEnvironment) &#123; //核心逻辑 processPropertySource(propertySource); &#125; else &#123; logger.info(&quot;Ignoring @PropertySource annotation on [&quot; + sourceClass.getMetadata().getClassName() + &quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;); &#125; &#125; // Process any @ComponentScan annotations //处理ComponentScans和ComponentScan注解 Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class); //是否需要跳过 if (!componentScans.isEmpty() &amp;&amp; !this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123; for (AnnotationAttributes componentScan : componentScans) &#123; // The config class is annotated with @ComponentScan -&gt; perform the scan immediately //这个parse里面的逻辑，基本上跟我们&lt;component-scan&gt;自定义标签解析的逻辑差不多 Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); // Check the set of scanned definitions for any further config classes and parse recursively if needed //这里又去递归，扫描到@Component生成beanDefinition后，又递归去校验类上面是否有特殊注解 for (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123; BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition(); if (bdCand == null) &#123; bdCand = holder.getBeanDefinition(); &#125; //判断是否是候选的BeanDefinition，如果是又parse if (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) &#123; parse(bdCand.getBeanClassName(), holder.getBeanName()); &#125; &#125; &#125; &#125; //处理@Import注解 getImports(sourceClass) 获取类上面的@Import注解并封装成SourceClass // Process any @Import annotations processImports(configClass, sourceClass, getImports(sourceClass), filter, true); //处理@ImportResource注解 ，没啥用，加载xml配置文件 // Process any @ImportResource annotations AnnotationAttributes importResource = AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class); if (importResource != null) &#123; String[] resources = importResource.getStringArray(&quot;locations&quot;); Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(&quot;reader&quot;); for (String resource : resources) &#123; String resolvedResource = this.environment.resolveRequiredPlaceholders(resource); //建立xml文件和reader的映射关系 configClass.addImportedResource(resolvedResource, readerClass); &#125; &#125; //处理@Bean注解，重点 // Process individual @Bean methods //收集有@bean 注解的方法 Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass); for (MethodMetadata methodMetadata : beanMethods) &#123; //加入到ConfigurationClass中 configClass.addBeanMethod(new BeanMethod(methodMetadata, configClass)); &#125; //处理接口里面方法有@Bean注解的，逻辑差不多 // Process default methods on interfaces processInterfaces(configClass, sourceClass); // Process superclass, if any if (sourceClass.getMetadata().hasSuperClass()) &#123; String superclass = sourceClass.getMetadata().getSuperClassName(); if (superclass != null &amp;&amp; !superclass.startsWith(&quot;java&quot;) &amp;&amp; !this.knownSuperclasses.containsKey(superclass)) &#123; this.knownSuperclasses.put(superclass, configClass); // Superclass found, return its annotation metadata and recurse return sourceClass.getSuperClass(); &#125; &#125; // No superclass -&gt; processing is complete return null;&#125;先跳过一些方法，先看这段代码 看源码前，先解析下两个了类 ConfigurationClass该类的是对类的一些配置信息的封装 SourceClass是对类的封装，就是把类和注解封装起来 从这两个类的定义看，SourceClass其实就是一个简单的封装，这个类的重点就是包含了AnnotationMetadata也就是注解元数据。而这个类在源码中创建时，source就是目标类的class对象。 ConfigurationClass从属性上看，这个类也能表示某个类，因为它有beanName。但从其他属性看，更像是对一些信息的收集。 回到doProcessConfigurationClass，我们按功能看 判断类上面是否有Component注解和递归处理有@Component注解的内部类 这段代码块就是判断类上面是否有Component注解和递归处理有@Component注解的内部类，看源码： 12345678910111213141516171819202122232425262728293031323334private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter) throws IOException &#123; // 获取该类的内部类并又包装成sourceClass对象 Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses(); if (!memberClasses.isEmpty()) &#123; List&lt;SourceClass&gt; candidates = new ArrayList&lt;&gt;(memberClasses.size()); for (SourceClass memberClass : memberClasses) &#123; //如果类是候选的 if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &amp;&amp; !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) &#123; candidates.add(memberClass); &#125; &#125; //排序 OrderComparator.sort(candidates); //循环去处理每一个内部类 for (SourceClass candidate : candidates) &#123; if (this.importStack.contains(configClass)) &#123; this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); &#125; else &#123; this.importStack.push(configClass); try &#123; //candidate 子 configClass 父，candidate 是 configClass的内部类 processConfigurationClass(candidate.asConfigClass(configClass), filter); &#125; finally &#123; this.importStack.pop(); &#125; &#125; &#125; &#125;&#125; 先通过 1Collection&lt;SourceClass&gt; memberClasses = sourceClass.getMemberClasses(); 获取了内部类，接着执行了 看哪些内部类有@Component、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource这些注解 排序完后，就进行遍历了。这个就是解析的入口方法，所以这是一个递归的过程了。 继续看doProcessConfigurationClass 处理PropertySources和 PropertySource注解 12345678910111213141516171819202122232425262728293031private void processPropertySource(AnnotationAttributes propertySource) throws IOException &#123; String name = propertySource.getString(&quot;name&quot;); if (!StringUtils.hasLength(name)) &#123; name = null; &#125; String encoding = propertySource.getString(&quot;encoding&quot;); if (!StringUtils.hasLength(encoding)) &#123; encoding = null; &#125; //获取配置文件路径 String[] locations = propertySource.getStringArray(&quot;value&quot;); Assert.isTrue(locations.length &gt; 0, &quot;At least one @PropertySource(value) location is required&quot;); boolean ignoreResourceNotFound = propertySource.getBoolean(&quot;ignoreResourceNotFound&quot;); Class&lt;? extends PropertySourceFactory&gt; factoryClass = propertySource.getClass(&quot;factory&quot;); PropertySourceFactory factory = (factoryClass == PropertySourceFactory.class ? DEFAULT_PROPERTY_SOURCE_FACTORY : BeanUtils.instantiateClass(factoryClass)); for (String location : locations) &#123; try &#123; //替换占位符 String resolvedLocation = this.environment.resolveRequiredPlaceholders(location); //流的方式加载配置文件并封装成Resource对象 Resource resource = this.resourceLoader.getResource(resolvedLocation); //加载Resource中的配置属性封装成Properties对象中，并创建PropertySource对象加入到Environment对象中 addPropertySource(factory.createPropertySource(name, new EncodedResource(resource, encoding))); &#125; //去掉catch ... &#125;&#125; 通过执行了代码后 1factory.createPropertySource(name, new EncodedResource(resource, encoding)) 已经把配置信息封装成一个Map，并封装成一个PropertySource 接着在代码中 1addPropertySource(PropertySource&lt;?&gt; propertySource) 会把PropertySource添加到Environment中 处理ComponentScans和ComponentScan注解 先通过上边的代码获取ComponentScan的集合。如果有就进入该代码块： 对前面的结合遍历，而在在for循环中有这样的一个方法: 1Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()); componentScanParser指向的对象是ComponentScanAnnotationParser ComponentScanAnnotationParser#parse 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public Set&lt;BeanDefinitionHolder&gt; parse(AnnotationAttributes componentScan, final String declaringClass) &#123; ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(this.registry, componentScan.getBoolean(&quot;useDefaultFilters&quot;), this.environment, this.resourceLoader); Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(&quot;nameGenerator&quot;); boolean useInheritedGenerator = (BeanNameGenerator.class == generatorClass); scanner.setBeanNameGenerator(useInheritedGenerator ? this.beanNameGenerator : BeanUtils.instantiateClass(generatorClass)); ScopedProxyMode scopedProxyMode = componentScan.getEnum(&quot;scopedProxy&quot;); if (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123; scanner.setScopedProxyMode(scopedProxyMode); &#125; else &#123; Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(&quot;scopeResolver&quot;); scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass)); &#125; scanner.setResourcePattern(componentScan.getString(&quot;resourcePattern&quot;)); for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;includeFilters&quot;)) &#123; for (TypeFilter typeFilter : typeFiltersFor(filter)) &#123; scanner.addIncludeFilter(typeFilter); &#125; &#125; for (AnnotationAttributes filter : componentScan.getAnnotationArray(&quot;excludeFilters&quot;)) &#123; for (TypeFilter typeFilter : typeFiltersFor(filter)) &#123; scanner.addExcludeFilter(typeFilter); &#125; &#125; boolean lazyInit = componentScan.getBoolean(&quot;lazyInit&quot;); if (lazyInit) &#123; scanner.getBeanDefinitionDefaults().setLazyInit(true); &#125; Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;(); String[] basePackagesArray = componentScan.getStringArray(&quot;basePackages&quot;); for (String pkg : basePackagesArray) &#123; String[] tokenized = StringUtils.tokenizeToStringArray(this.environment.resolvePlaceholders(pkg), ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); Collections.addAll(basePackages, tokenized); &#125; for (Class&lt;?&gt; clazz : componentScan.getClassArray(&quot;basePackageClasses&quot;)) &#123; basePackages.add(ClassUtils.getPackageName(clazz)); &#125; if (basePackages.isEmpty()) &#123; basePackages.add(ClassUtils.getPackageName(declaringClass)); &#125; scanner.addExcludeFilter(new AbstractTypeHierarchyTraversingFilter(false, false) &#123; @Override protected boolean matchClassName(String className) &#123; return declaringClass.equals(className); &#125; &#125;); return scanner.doScan(StringUtils.toStringArray(basePackages));&#125; 第一行就new ClassPathBeanDefinitionScanner了，这个ClassPathBeanDefinitionScanner就是负责包扫描的。 后面的代码其他都是向ClassPathBeanDefinitionScanner中填充注解属性 最后： 这个方法的详情看01-Spring中BeanDefinition的创建和注册 扫描完后返回了一个BeanDefinition集合，接着又有一个for 因为通过scaner扫描出来的只是有@Component注解类，类上还可能有其他注解，所以对于这种情况，如果有对应注解，这里通过循环调用parse，又把流程走一遍 处理@Import注解接着代码走到这 先通过getImports(sourceClass)拿到类上的@Import的值和类上其他注解中@Import的的值，返回一个SourceClass集合。 接着看processImports的核心代码段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//如果没有@Import注解直接返回，不处理if (importCandidates.isEmpty()) &#123; return;&#125;//循环类上面的每一个@Importfor (SourceClass candidate : importCandidates) &#123; //如果Import进来的是一个ImportSelector类型 if (candidate.isAssignable(ImportSelector.class)) &#123; // Candidate class is an ImportSelector -&gt; delegate to it to determine imports Class&lt;?&gt; candidateClass = candidate.loadClass(); //反射实例化 ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) &#123; exclusionFilter = exclusionFilter.or(selectorFilter); &#125; //如果是一个DeferredImportSelector类型 if (selector instanceof DeferredImportSelector) &#123; //比较复杂，springboot中自动配置用到了 this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector); &#125; else &#123; //在这里调用selectImports方法，返回所有的需要import到spring容器的beanName String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter); //递归处理，有可能import进来的类又有@Import注解 processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false); &#125; &#125; //如果Import进来的是一个ImportBeanDefinitionRegistrar类型 else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) &#123; // Candidate class is an ImportBeanDefinitionRegistrar -&gt; // delegate to it to register additional bean definitions Class&lt;?&gt; candidateClass = candidate.loadClass(); //反射实例化 ImportBeanDefinitionRegistrar registrar = ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); //加入到importBeanDefinitionRegistrars容器中，这里还没有调用registerBeanDefinitions configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); &#125; else &#123; // Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&gt; // process it as an @Configuration class this.importStack.registerImport( currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); //如果都不是，则走这里 processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); &#125;&#125; importCandidates就是@Import中值。 从源码可知如果Import进来的是一个ImportSelector类型、DeferredImportSelector类型、ImportBeanDefinitionRegistrar类型的，都会在该方法中执行对应的逻辑，而如不是上边的类型，就会执行processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter)也就是递归的处理引入类的注解信息，这里有一点要注意，candidate.asConfigClass(configClass)candidate为被引入的类，configClass为有@Import的类，通过asConfigClass后，会把configClass添加到ConfigurationClass.importedBy集合中，这种表示该类是被某个类@Import进来的。 回到源码。 第一段代码就是如果没有@Import注解直接返回，不处理，有的话才会执行下面流程。假如有Import注解 看for的代码块，就是遍历@Import注解上的类，先看第一个if条件。 可以看到， 先实例话了对象，然后根据实现的接口走不同的逻辑。 如果实现了ImportSelector接口，就会先去创建对象，然后会看这个对象是否实现了DeferredImportSelector接口，如果没有实现，就会直接调用ImportSelector的selectImports方法，从源码可知，该方法的入参为有@Import注解的类。 执行完ImportSelector接口方法后，接口返回了一个类的全限定名数组，接着根据这个数组生成Collection&lt;SourceClass&gt; 1Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter); 最后，返回的类（Collection&lt;SourceClass&gt;）又有可能有Import注解，所以又调用了processImports递归的处理。 如果实现了DeferredImportSelector接口 就只是包装成DeferredImportSelectorHolder，然后放入到集合中 执行时机后边讲 接着看else if代码块: 如是实现的是mportBeanDefinitionRegistrars接口，先实例化，然后执行 12345configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());public void addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata) &#123; this.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);&#125; 添加到configClass（ConfigurationClass）的importBeanDefinitionRegistrars容器中。 这个接口的作用相当于BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry方法，只是调用的时机不同，比如实现这样一个功能 1234567891011public class JamesImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; //自己创建beanDefinition对象，然后注册到BeanDefinitionRegistry中 GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition(); genericBeanDefinition.setBeanClass(BeanDefinitionBean.class); MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues(); propertyValues.add(&quot;name&quot;,&quot;Jack&quot;); registry.registerBeanDefinition(&quot;beanDefinitionBean&quot;,genericBeanDefinition); &#125;&#125; 执行时机先不说 如果上面的接口都没有，情况下走到else了： candidate.asConfigClass(configClass)，这个方法的参数要搞清楚，configClass是有@Import注解的类，而candidate是被引入的类，这段代码的意思就是，把configClass添加到candidate的ConfigurationClass.importedBy集合中。这样，就能知道某个类是被谁impor的了。 接着调用了processConfigurationClass，因为被引入进来的类可能还有别的注解，所以流程又从头开始。 这个方法不像上边的Scan方法，这个方法中还没涉及BeanDefinition的创建，也没有注册，但会实例化对象，这点看上去有点迷惑，但如果看回入口方法ConfigurationClassParser#processConfigurationClass，在最后会把ConfigurationClass放入到一个Map中。从这点上看ConfigurationClass可以看做是BeanDefinition信息的载体。先看到这，等把下面的流程看完了， 再回到入口方法。 处理@ImportResource注解代码执行到这里了 再这里处理ImportResource注解。代码也很简单，只是在向ConfigurationClass的importedResources集合放入对应关系，也就是，这里和上边的一样，不会去实际处理。只是做了信息的收集。 处理@Bean注解 1retrieveBeanMethodMetadata(sourceClass) 这段代码的意思就是返回有@Bean的方法，并且把该方法封装成MethodMetadata，然后放入到ConfigurationClass的beanMethods集合中。还是做了信息的收集 重点的代码已经看完了，看回入口方法 再看ConfigurationClassParser#processConfigurationClass12345678SourceClass sourceClass = asSourceClass(configClass, filter);do &#123; //核心代码，认真读 sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);&#125;while (sourceClass != null);this.configurationClasses.put(configClass, configClass); 经过了doProcessConfigurationClass方法后，除了扫描的其他都是对注解信息的收集，并把信息放到了对应的ConfigurationClass类中，最后把ConfigurationClass放入了configurationClasses这个Map集合中。这个方法的逻辑就结束了。 也就是说configurationClasses这个集合是用来保存已经完成信息收集的ConfigurationClass类。 DeferredImportSelector类型的类的处理时机和作用DeferredImportSelector接口的作用、初始化和执行原理 再看ConfigurationClassPostProcessor#processConfigBeanDefinitions完整代码 上边的代码只是执行了parse方法，并把收集完信息的ConfigrationClass放入了ConfigurationClassParser#configurationClasses这个集合中，那下边剩下的逻辑就是处理这个集合中的configurationClasses了，看代码 继续跟踪代码到这里 BeanDefinition的创建——ConfigurationClassBeanDefinitionReader#loadBeanDefinitions 在其实已经有BeanDefinition的创建的创建了，就是@Component注解扫描。在这扫描其实已经把绝大部分的类的BeanDefinition都创建了。而到了loadBeanDefinitions这一步就是为剩余的类生成BeanDefinition。这些剩余类有 通过applicationContext.register()这样注册的 @Import进来的类，这里设计到的 @Bean注解 引入进来的xml文件的解析流程 ImportBeanDefinitionRegistrar 123456789101112131415161718192021222324252627282930313233343536//ConfigurationClassBeanDefinitionReaderpublic void loadBeanDefinitions(Set&lt;ConfigurationClass&gt; configurationModel) &#123; TrackedConditionEvaluator trackedConditionEvaluator = new TrackedConditionEvaluator(); for (ConfigurationClass configClass : configurationModel) &#123; loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator); &#125;&#125;private void loadBeanDefinitionsForConfigurationClass( ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator) &#123; //是否要跳过 // 判断哪些被@Improt引入的类中是有用@Contitional注解，有就执行方法判断条件是否通过 if (trackedConditionEvaluator.shouldSkip(configClass)) &#123; String beanName = configClass.getBeanName(); if (StringUtils.hasLength(beanName) &amp;&amp; this.registry.containsBeanDefinition(beanName)) &#123; this.registry.removeBeanDefinition(beanName); &#125; this.importRegistry.removeImportingClass(configClass.getMetadata().getClassName()); return; &#125; //@Import进来的类，和内部类走这里变成BeanDefinition，并注册 if (configClass.isImported()) &#123; registerBeanDefinitionForImportedConfigurationClass(configClass); &#125; //@Bean注解的方法变成BeanDefinition，并注册 for (BeanMethod beanMethod : configClass.getBeanMethods()) &#123; loadBeanDefinitionsForBeanMethod(beanMethod); &#125; //走xml解析流程 loadBeanDefinitionsFromImportedResources(configClass.getImportedResources()); //调用ImportBeanDefinitionRegistrar的方法 loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());&#125; 根据@Conditional来判断按功能看代码 这里又是根据@Conditional来判断条件是否符合 @Import进来的类 先执行了configClass.isImported())看源码： 123public boolean isImported() &#123; return !this.importedBy.isEmpty();&#125; 也就是，这个if是去判断这个类是否被@Import注解引入的。 12345678910111213141516171819// ConfigurationClassBeanDefinitionReaderprivate void registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass) &#123; AnnotationMetadata metadata = configClass.getMetadata(); AnnotatedGenericBeanDefinition configBeanDef = new AnnotatedGenericBeanDefinition(metadata); ScopeMetadata scopeMetadata = scopeMetadataResolver.resolveScopeMetadata(configBeanDef); configBeanDef.setScope(scopeMetadata.getScopeName()); String configBeanName = this.importBeanNameGenerator.generateBeanName(configBeanDef, this.registry); AnnotationConfigUtils.processCommonDefinitionAnnotations(configBeanDef, metadata); BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(configBeanDef, configBeanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); this.registry.registerBeanDefinition(definitionHolder.getBeanName(), definitionHolder.getBeanDefinition()); configClass.setBeanName(configBeanName); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Registered bean definition for imported class &#x27;&quot; + configBeanName + &quot;&#x27;&quot;); &#125;&#125; 生成一个AnnotatedGenericBeanDefinition对象了，并且执行registry.registerBeanDefinition去注册BeanDefinition @Bean注解接着看代码 ConfigurationClass中的BeanMethods集合放的是有@Bean的方法的封装，所以这个for就是把@Bean的方法，变成BeanDefinition，看源码到这里 这时存在这样的关系 这个是真的和factoryMethod一样了。 经过上面的步骤后，被@Import引入的类和有@Bean修饰的方法，都已经变成一个BeanDefinition了，剩下的看下面 xml解析 这个步骤就看这里——Spring中BeanDefinition的创建和注册BeanDefinition已经都生成并注册完了，看最后的一段代码 ImportBeanDefinitionRegistrar的方法 在对@Impor的解析的时候，如果引入的类实现了接口ImportBeanDefinitionRegistrar接口，就实例化一个对象并放入了ConfigrationClass的importBeanDefinitionRegistrars中，而这段代码就是拿到这个集合，并调用对象的registerBeanDefinitions方法。 看到这，还记得一个接口BeanDefinitionRegistryPostProcesso这个接口吗，ImportBeanDefinitionRegistrar接口的作用和BeanDefinitionRegistryPostProcesso是一样的。但是执行的时机不同。BeanDefinitionRegistryPostProcesso接口的的postProcessBeanDefinitionRegistry这个方法BeanFactory创建完成后调用的，可以对BeanDefinition做任何操作。可以看BeanDefinitionRegistryPostProcessor调用时机可以知道，实现PriorityOrdered接口的是最先执行的，而ConfigurationClassPostProcessor实现了这个接口，但该类的getOrder()返回的是最低的优先级。 也就是说，从执行的顺序看 实现了BeanDefinitionRegistryPostProcessor和PriorityOrdered的先执行 ConfigurationClassPostProcessor执行 在ConfigurationClassPostProcessor执行的最后执行ImportBeanDefinitionRegistrar 执行实现了BeanDefinitionRegistryPostProcessor和Ordered的 执行只实现了BeanDefinitionRegistryPostProcessor 所以，ImportBeanDefinitionRegistrar接口的调用是发生在ConfigurationClassPostProcessor中，所以对于某些有先后关系的Beandefinition，这时就需要考虑优先级的问题。 ConfigurationClassParser#parse总结parser.parse(candidates) 先解析@Configuration、@PropertySources、@PropertySource、@ComponentScan、@Bean、@Import、@ImportResource。在解析@ComponentScan的时候就已经把BeanDefinition创建并且注册了，而在解析@Import的时候会调用ImportSelector接口的方法，其他的注解都只是做一个信息收集的过程。收集完注解的信息后，会把这些信息的封装对象ConfigurationClass放到一个收集完成集合中，根据之前收集的信息（ConfigurationClass）去创建并注册BeanDefinition，并且最后调用ImportBeanDefinitionRegistrar接口的方法。 @Configuration和@Component的问题从源码可以知道，使用@Component都能触发内部注解的解析，但为什么还要用@Configuration这个注解呢？ 比如这种情况 在使用@Component的时候，根据之前的Bean的初始化阶段factoryMethod的源码我们都知道，这种情况lison()会被调用了两次。也就是说，会产生两个Lison对象。 还有一种情况 12345678910111213141516public class LiLi implements FactoryBean &#123; @Override public Object getObject() throws Exception &#123; return new Docker(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Docker.class; &#125; public void xae() &#123; System.out.println(&quot;xae&quot;); &#125;&#125; 也是使用了@Component，我通过applicationContext.getBean(Docker.class)获取的对象和通过lisonFactory()方法调用lili的getObject获取的对象是两个不同的对象。其实这样想，在lisonFactory()中就相当于获取了Lili中个工厂类，然后工程类在new一个。 上面两种情况都破坏了Spring的单例。 但是上面两种情况只要把@Component注解换成@Configuration注解，那么这时调用的都是获取同一个对象。@Configuration注解就是保证单例的。其实就是调用liLi方法时走的是代理对象的方法，代理对象会从缓存中拿值。 怎么实现的，看回源码 上面都是讲了ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry方法。用来生成并注册BeanDefinition。在处理完个方法后，还会执行一个方法，就是postProcessBeanFactory。现在看 ConfigurationClassPostProcessor#postProcessBeanFactory方法。 ConfigurationClassPostProcessor#postProcessBeanFactory 说代码前，先看下cglib的api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;(); for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); Object configClassAttr = beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE); MethodMetadata methodMetadata = null; if (beanDef instanceof AnnotatedBeanDefinition) &#123; methodMetadata = ((AnnotatedBeanDefinition) beanDef).getFactoryMethodMetadata(); &#125; if ((configClassAttr != null || methodMetadata != null) &amp;&amp; beanDef instanceof AbstractBeanDefinition) &#123; // Configuration class (full or lite) or a configuration-derived @Bean method // -&gt; resolve bean class at this point... AbstractBeanDefinition abd = (AbstractBeanDefinition) beanDef; if (!abd.hasBeanClass()) &#123; try &#123; abd.resolveBeanClass(this.beanClassLoader); &#125; catch (Throwable ex) &#123; throw new IllegalStateException( &quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex); &#125; &#125; &#125; if (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123; //打印日志 ..... configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.getBeanClass(); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; if (logger.isTraceEnabled()) &#123; //打印日志 ..... &#125; beanDef.setBeanClass(enhancedClass); &#125; &#125;&#125; 在之前的代码中，检查到有@Configuration、@Componet等注解的时候会为BeanDefi&#96;nition打一个标记，现在在这里取出这个标记。 往下走到这 在前面已经讲过了@Configuration，把属性值设置为CONFIGURATION_CLASS_FULL=full，而这块代码也很简单，就是放入到configBeanDefs容器中。这时往下走到这段代码，就是对configBeanDefs集合的调用 在这个for循环中，生成了一个ConfigurationClassEnhancer，然后循环的 也就是说，如果有@Configuration这个注解，就把需要生成代理标记设置到beanDefinition的属性中。并把代理对象的class设置到BeanDefinition中。现在看下： ConfigurationClassEnhancer#enhance 1234567891011private Enhancer newEnhancer(Class&lt;?&gt; configSuperClass, @Nullable ClassLoader classLoader) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(configSuperClass); enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;); enhancer.setUseFactory(false); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)); enhancer.setCallbackFilter(CALLBACK_FILTER); enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()); return enhancer;&#125; 也就是说在根据BeanDefinition生成bean的过程中会生成一个代理对象，该代理对象继承了目标类 定义的Callback 可以看下 从cglib的api可知，代理对象的方法调用都会被CallbackFilter拦截，看上面的ConditionalCallbackFilter 1234567891011121314151617181920212223242526272829private static class ConditionalCallbackFilter implements CallbackFilter &#123; private final Callback[] callbacks; private final Class&lt;?&gt;[] callbackTypes; public ConditionalCallbackFilter(Callback[] callbacks) &#123; this.callbacks = callbacks; this.callbackTypes = new Class&lt;?&gt;[callbacks.length]; for (int i = 0; i &lt; callbacks.length; i++) &#123; this.callbackTypes[i] = callbacks[i].getClass(); &#125; &#125; @Override public int accept(Method method) &#123; for (int i = 0; i &lt; this.callbacks.length; i++) &#123; Callback callback = this.callbacks[i]; if (!(callback instanceof ConditionalCallback) || ((ConditionalCallback) callback).isMatch(method)) &#123; return i; &#125; &#125; throw new IllegalStateException(&quot;No callback available for method &quot; + method.getName()); &#125; public Class&lt;?&gt;[] getCallbackTypes() &#123; return this.callbackTypes; &#125;&#125; 在accept中，看哪个匹配就执行那个，我们现在关注的是@Bean注解，所以去isMatch中找吧，找到了BeanMethodInterceptor的isMatch匹配 也就是说调用的方法会进入到BeanMethodInterceptor的intercept方法中。看源码 这个有印象吗？就是在Spring bean的初始化时，对于@Bean、factoryMetoh这种通过调用方法来实例化的时候，Spring调用SimpleInstantiationStrategy.instantiate的源码： 在初始化阶段，这里先把有@Bean的方法对象放入到currentlyInvokedFactoryMethod这个threadLocal中，然后用反射调用方法，由于factoryBean这个是代理对象，所以这里的方法调用实际上就走到了这里： 也就是说，在Spring调用方法的时候实际上也是一个代理对象，这个时候由于这个ThreadLocal有值，所以Spring调用的时候会进去了if的代码块，通过调用被代理对象调用方法来生成对象。这是在spring的ioc初始化阶段走的逻辑。如果初始化阶段结束了，在程序运行节点调用有@bean的方法的时候，回到BeanMethodInterceptor的intercept方法，继续走 进去resolveBeanReference后继续走 走到这里意味着已经初始化完成了，所以通过beanFactory.getBean就是从一级缓存singletonObjects这个Map中拿数据了。接着代码继续走，由于Spring在调用代理方法的时候都会往一个TreadLocal中设置值，调用完后就移除了，走到这段代码时 会放回null，所以这时我们通过缓存获取的对象就直接返回了。所以在上边的两种情况下，调用了一个@Bean的方法，那就相当于从一级缓存中拿到数据了。而对于FactoryBean LiLi 这时是一个FactoryBean类型对象，但由于这个对象是cglib的代理对象，所以当调用object.getObject时，代理对象通过getBean在一级缓存singletonObjects中拿到FactoryBean类型对象，然后在返回前调用调用getObjectForBeanInstance，这个方法在讲实例化的最后——FactoryBean类型实例化就说过了，作用就是从factoryBeanObjectCache中拿目标对象。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"06-Spring自定义Scope","slug":"spring/5.2.8/06-Spring自定义Scope","date":"2021-11-20T12:00:12.000Z","updated":"2022-03-14T09:04:25.553Z","comments":true,"path":"blog/spring/5.2.8/06-Spring自定义Scope/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/06-Spring%E8%87%AA%E5%AE%9A%E4%B9%89Scope/","excerpt":"","text":"Spring自定义ScopeBean 的多例作用域(如何管理 bean而已) 自定义作用域(Scope)自定义Scope要回到AbstractBeanFactory#doGetBean方法，源码 1234567891011121314151617181920212223242526272829protected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123; //去掉和这节没关的代码 ... String beanName = transformedBeanName(name); Object bean; //去掉和这节没关的代码 ... else &#123; String scopeName = mbd.getScope(); Scope scope = this.scopes.get(scopeName); try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; &#125; //去掉和这节没关的代码 ... return (T) bean;&#125; 自定义Scope： 1234567891011121314151617181920212223242526272829303132333435363738public class CustomScope implements Scope &#123; private ThreadLocal local = new ThreadLocal(); @Override public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123; if(local.get() != null) &#123; return local.get(); &#125; else &#123; //创建实例 // 其实就是调用createBean Object object = objectFactory.getObject(); local.set(object); return object; &#125; &#125; @Override public Object remove(String name) &#123; Object o = local.get(); local.remove(); return o; &#125; @Override public void registerDestructionCallback(String name, Runnable callback) &#123; &#125; @Override public Object resolveContextualObject(String key) &#123; return null; &#125; @Override public String getConversationId() &#123; return null; &#125;&#125; 自定义Scope注册: 12345678910111213@Componentpublic class CustomScopeRegistry implements BeanDefinitionRegistryPostProcessor &#123; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; beanFactory.registerScope(&quot;refreshScope&quot;,new CustomScope()); &#125;&#125; 使用自定义Scope： 1234567@Component@Scope(&quot;refreshScope&quot;)@Datapublic class CustomScopeBean &#123; private String username;&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"05-Spring配置的解析","slug":"spring/5.2.8/05-Spring配置的解析","date":"2021-11-20T12:00:11.000Z","updated":"2022-03-14T09:04:25.543Z","comments":true,"path":"blog/spring/5.2.8/05-Spring配置的解析/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/05-Spring%E9%85%8D%E7%BD%AE%E7%9A%84%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Spring配置的解析在Spring中，Spring会把配置内容保存到Environment中。而这个Environment内容的对象类型为StandardEnvironment。的创建采用的延迟创建的模式，只有当点用ApplicationContext的getEnvironment方法时才会传遍。源码为 123456789101112//AbstractApplicationContext@Overridepublic ConfigurableEnvironment getEnvironment() &#123; if (this.environment == null) &#123; this.environment = createEnvironment(); &#125; return this.environment;&#125;protected ConfigurableEnvironment createEnvironment() &#123; return new StandardEnvironment();&#125; xml对配置的解析传统手艺xml 1&lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt; 现在找property-placeholder这个是那个类解析的，流程就是通过context，找到URI，通过URi找到对应的NamespaceHandlerSupport，再看该类的init方法，根据key找到BeanDefinitionParser 最终找到了property-placeholder的解析类是PropertyPlaceholderBeanDefinitionParser，看下该类的定义: 看getBeanClass，该方法会返回一个解析的关键类，会返回一个PropertySourcesPlaceholderConfigurer.class对象 为什么说它重要呢？因为在对自定义标签的解析中，会去到PropertyPlaceholderBeanDefinitionParser后会调用parser方法，在该类调用的parser方法中就是调用了getBeanClass方法，并且会创建一个GenericBeanDefinition然后注册到beanFactory中，那么在BeanDefinition初始化和注册完成后，就会去找实现了BeanFactoryPostProcessor接口的BeanDefinition，然后实例化并调用方法postProcessBeanFactory方法。 看PropertySourcesPlaceholderConfigurer的类图 实现了BeanFactoryPostProcessor接口，那么会在BeanDefinition初始化和注册完成后就会调用该接口的方法，看方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; if (this.propertySources == null) &#123; this.propertySources = new MutablePropertySources(); if (this.environment != null) &#123; //把environment对象封装成的PropertySource对象加入到 this.propertySources.addLast( //把environment对象封装成PropertySource对象MutablePropertySources中的list中 new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) &#123; @Override @Nullable //source就是environment对象 public String getProperty(String key) &#123; return this.source.getProperty(key); &#125; &#125; ); &#125; try &#123; //加载本地配置文件中的属性值包装成properties对象后，最终包装成PropertySource对象 PropertySource&lt;?&gt; localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties()); //加入到MutablePropertySources中的list中 if (this.localOverride) &#123; this.propertySources.addFirst(localPropertySource); &#125; else &#123; this.propertySources.addLast(localPropertySource); &#125; &#125; catch (IOException ex) &#123; throw new BeanInitializationException(&quot;Could not load properties&quot;, ex); &#125; &#125; processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources)); this.appliedPropertySources = this.propertySources;&#125;protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, final ConfigurablePropertyResolver propertyResolver) throws BeansException &#123; //设置占位符的前缀后缀 propertyResolver.setPlaceholderPrefix(this.placeholderPrefix); propertyResolver.setPlaceholderSuffix(this.placeholderSuffix); //设分割符 : propertyResolver.setValueSeparator(this.valueSeparator); //重点是这个匿名对象 @Value的依赖注入会掉过来 StringValueResolver valueResolver = strVal -&gt; &#123; String resolved = (this.ignoreUnresolvablePlaceholders ? propertyResolver.resolvePlaceholders(strVal) : propertyResolver.resolveRequiredPlaceholders(strVal)); if (this.trimValues) &#123; resolved = resolved.trim(); &#125; return (resolved.equals(this.nullValue) ? null : resolved); &#125;; //核心流程。把占位符$&#123;xxx&#125;替换成真正的值 doProcessProperties(beanFactoryToProcess, valueResolver);&#125;protected void doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess, StringValueResolver valueResolver) &#123; //beanDefinition的修改者 BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver); //获取所有的beanNames String[] beanNames = beanFactoryToProcess.getBeanDefinitionNames(); for (String curName : beanNames) &#123; // Check that we&#x27;re not parsing our own bean definition, // to avoid failing on unresolvable placeholders in properties file locations. if (!(curName.equals(this.beanName) &amp;&amp; beanFactoryToProcess.equals(this.beanFactory))) &#123; //获取BeanDefinition对象 BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName); try &#123; //修改BeanDefinition中的MutablePropertyValues中的每一个属性值，把属性值有$&#123;enjoy.name&#125;修改成真正的参数值 visitor.visitBeanDefinition(bd); &#125; catch (Exception ex) &#123; throw new BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage(), ex); &#125; &#125; &#125; // New in Spring 2.5: resolve placeholders in alias target names and aliases as well. beanFactoryToProcess.resolveAliases(valueResolver); //把内嵌的Value解析器设置到BeanFactory中..为@Value的依赖注入做准备 // New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes. beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);&#125; 看第一个if (this.environment !&#x3D; null)，这个environment对在 这 这里创建一个对象 之后执行 PropertySource&lt;?&gt; localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());就把项目属性设置好了 该方法核心其实就是走了这种操作 123Properties properties = new Properties();properties.load(new FileInputStream(&quot;/Volumes/vm/mq/rockermq/conf/broker.conf&quot;));System.out.println(properties); 最后调用 processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources)); 跟踪代码最后看核心源码： 就是遍历BeanDefinition，然后修改对应的值。 解析的逻辑在这个类中：PropertyPlaceholderHelper 感觉配置是如何解析的不是很重要，大致流程了解下即可，也就是BeanFactoryPostProcessor接口的应用。 通过配置文件实例化bean12345678910enjoy.name=jackenjoy.password=123enjoy.beanClass = $&#123;enjoy.placeHolderBean1&#125;,$&#123;enjoy.placeHolderBean2&#125;,$&#123;enjoy.placeHolderBean3&#125;enjoy.placeHolderBean1 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean1enjoy.placeHolderBean2 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean2enjoy.placeHolderBean3 = com.enjoy.jack.beanDefinitionPostProcessor.PlaceHolderBean3cn.enjoy.scan.packages=com.xiangxue.jackcn.enjoy.flag=true 比如配置有个文件这样 然后我自己写了个类： 123456789101112131415161718192021222324@Componentpublic class PropertyPlaceHolderBeanDefinition implements BeanDefinitionRegistryPostProcessor &#123; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; try &#123; Properties properties = PropertiesLoaderUtils.loadAllProperties(&quot;application.properties&quot;, ClassUtils.getDefaultClassLoader()); String property = properties.getProperty(&quot;enjoy.beanClass&quot;); String[] beanClasss = property.split(&quot;,&quot;); for (String classs : beanClasss) &#123; BeanDefinition beanDefinition = new GenericBeanDefinition(); beanDefinition.setBeanClassName(classs);// String beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition,registry); registry.registerBeanDefinition(UUID.randomUUID().toString(),beanDefinition); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; &#125;&#125; @Value注解的依赖注入就看AbstarctAutowireCapobleBeanFactory#doCreateBean中的populateBean方法，该方法就是处理依赖注入的 到这里 跟踪代码： 1234AbstractAutowireCapableBeanFactory#populateBean ---&gt;AutowiredAnnotationBeanPostProcessor#postProcessProperties --&gt;InjectionMetadata#inject --&gt;AutowiredAnnotationBeanPostProcessor#inject @Autowire在这里会返回bean，但对于@Value不同，看代码： 在PropertySourcesPlaceholderConfigurer的源码中传入了一个匿名对象 那getAutowireCandidateResolver()这个就获取了匿名对象了。返回值后就和@Autowire一样了。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"04-Spring的Bean实例化","slug":"spring/5.2.8/04-Spring的Bean实例化","date":"2021-11-20T12:00:10.000Z","updated":"2022-03-14T09:04:25.497Z","comments":true,"path":"blog/spring/5.2.8/04-Spring的Bean实例化/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/04-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"","text":"Spring的Bean实例化实例化也是在refresh()方法中完成的。上refresh()源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //为容器初始化做准备，重要程度：0 // Prepare this context for refreshing. prepareRefresh(); /* 重要程度：5 1、创建BeanFactory对象 * 2、xml解析 * 传统标签解析：bean、import等 * 自定义标签解析 如：&lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&gt; * 自定义标签解析流程： * a、根据当前解析标签的头信息找到对应的namespaceUri * b、加载spring所有jar中的spring.handlers文件。并建立映射关系 * c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类 * d、调用类的init方法，init方法是注册了各种自定义标签的解析类 * e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析 * * 3、把解析出来的xml标签封装成BeanDefinition对象 * */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); /* * 给beanFactory设置一些属性值，可以不看 * */ // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); /* * BeanDefinitionRegistryPostProcessor * BeanFactoryPostProcessor * 完成对这两个接口的调用 * */ // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); /* * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中 * */ // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); /* * 国际化,重要程度2 * */ // Initialize message source for this context. initMessageSource(); //初始化事件管理类 // Initialize event multicaster for this context. initApplicationEventMulticaster(); //这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的 // Initialize other special beans in specific context subclasses. onRefresh(); /* * 往事件管理类中注册事件类 * */ // Check for listener beans and register them. registerListeners(); /* * 这个方法是spring中最重要的方法，没有之一 * 所以这个方法一定要理解要具体看 * 1、bean实例化过程 * 2、ioc * 3、注解支持 * 4、BeanPostProcessor的执行 * 5、Aop的入口 * */ // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; Bean的实例话时在finishBeanFactoryInitialization(beanFactory);方法中完成的。 1234567891011121314protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; //省略不重要的方法 .... // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // Allow for caching all bean definition metadata, not expecting further changes. beanFactory.freezeConfiguration(); //重点看这个方法，重要程度：5 // Instantiate all remaining (non-lazy-init) singletons. beanFactory.preInstantiateSingletons();&#125; 看最后的方法beanFactory.preInstantiateSingletons();（beanFactory终于不只是注册和查找了，终于有一个与它的名字相匹配的操作了）。方法翻译是实例化单例，那看看是怎么实例化Bean的吧。 DefaultListableBeanFactory#preInstantiateSingletons123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * 具体实例化过程 * */@Overridepublic void preInstantiateSingletons() throws BeansException &#123; // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. // 把所有beanName都缓存到beanDefinitionNames了，这时这个BeanName所对应的是BeanDefinition List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames); // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) &#123; //把父BeanDefinition里面的属性拿到子BeanDefinition中 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); //如果不是抽象的，单例的，非懒加载的就实例化 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; //判断bean是否实现了FactoryBean接口，这里可以不看 &amp;factoryBeanDemo if (isFactoryBean(beanName)) &#123; Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); if (bean instanceof FactoryBean) &#123; FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean; boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged( (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; &#125; else &#123; //主要从这里进入，看看实例化过程 getBean(beanName); &#125; &#125; &#125; // Trigger post-initialization callback for all applicable beans... for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 第一步就是 这个beanDefinitionNames就是BeanDefinition放入beanFactory的Map中后，还会把beanName放入到到beanFactory的一个list列表中，这个列表就是beanDefinitionNames。 然后就是遍历这个列表了。在for循环中第一行代码 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);，它是把父BeanDefinition里面的属性拿到子BeanDefinition中，这是一个深度拷贝的过程，而且会返回一个RootBeanDefinition，表示该BeanDefinition需要实例化了 比如是这样定义 比如在多数据源时，有一个父的bean保存一个共有的信息，而一些独有的信息就放在自己的bean中，那这时是要这样定义就好了。 继续看代码，如果不是抽象的，是单例的，非懒加载的就实例化，那会进入到if中， 这里主要看else吧，if的话是对那些实现FactoryBean接口的类实例化的，这里之后再看。 AbstractBeanFactory#getBeangetBean方法是由父类AbstractBeanFactory实现，跟踪代码，最后看AbstractBeanFactory#doGetBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// AbstractBeanFactoryprotected &lt;T&gt; T doGetBean( String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&amp;这个符号 String beanName = transformedBeanName(name); Object bean; //从缓存中拿实例 // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); //如果缓存里面能拿到实例 if (sharedInstance != null &amp;&amp; args == null) &#123; //该方法是FactoryBean接口的调用入口 bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; //如果singletonObjects缓存里面没有，则走下来 // Fail if we&#x27;re already creating this bean instance: // We&#x27;re assumably within a circular reference. //如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错 if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (parentBeanFactory instanceof AbstractBeanFactory) &#123; return ((AbstractBeanFactory) parentBeanFactory).doGetBean( nameToLookup, requiredType, args, typeCheckOnly); &#125; else if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else if (requiredType != null) &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; else &#123; return (T) parentBeanFactory.getBean(nameToLookup); &#125; &#125; if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; //父子BeanDefinition合并 RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); //获取依赖对象属性，依赖对象要先实例化 // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Circular depends-on relationship between &#x27;&quot; + beanName + &quot;&#x27; and &#x27;&quot; + dep + &quot;&#x27;&quot;); &#125; registerDependentBean(dep, beanName); try &#123; //实例化 getBean(dep); &#125; catch (NoSuchBeanDefinitionException ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;&#x27;&quot; + beanName + &quot;&#x27; depends on missing bean &#x27;&quot; + dep + &quot;&#x27;&quot;, ex); &#125; &#125; &#125; //着重看，大部分是单例的情况 // Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, () -&gt; &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125;); //该方法是FactoryBean接口的调用入口 bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; else if (mbd.isPrototype()) &#123; // It&#x27;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; //该方法是FactoryBean接口的调用入口 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; String scopeName = mbd.getScope(); if (!StringUtils.hasLength(scopeName)) &#123; throw new IllegalStateException(&quot;No scope name defined for bean ´&quot; + beanName + &quot;&#x27;&quot;); &#125; Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(&quot;No Scope registered for scope name &#x27;&quot; + scopeName + &quot;&#x27;&quot;); &#125; try &#123; Object scopedInstance = scope.get(beanName, () -&gt; &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, &quot;Scope &#x27;&quot; + scopeName + &quot;&#x27; is not active for the current thread; consider &quot; + &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;, ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType); if (convertedBean == null) &#123; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; return convertedBean; &#125; catch (TypeMismatchException ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Failed to convert bean &#x27;&quot; + name + &quot;&#x27; to required type &#x27;&quot; + ClassUtils.getQualifiedName(requiredType) + &quot;&#x27;&quot;, ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 先看 1String beanName = transformedBeanName(name); 这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&amp;这个符号。经过这个方法后，会去掉&amp;符号，所以进入了方法后对于FactoryBean的接口的BeanDefinition，会有两个名字，一个是 12name=&amp;beanNamebeanName=beanName 接着看 1Object sharedInstance = getSingleton(beanName); getSingleton方法是从DefaultSingletonBeanRegistry继承过来的，该方法会根据beanName从缓存中拿实例，进去看看getSingleton： 1234567891011121314151617181920212223242526protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; //根据beanName从缓存中拿实例 //先从一级缓存拿 Object singletonObject = this.singletonObjects.get(beanName); //如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; //从二级缓存中拿 singletonObject = this.earlySingletonObjects.get(beanName); //如果还拿不到，并且允许bean提前暴露 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; //从三级缓存中拿到对象工厂 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; //从工厂中拿到对象 singletonObject = singletonFactory.getObject(); //升级到二级缓存 this.earlySingletonObjects.put(beanName, singletonObject); //删除三级缓存 this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125; 就是从缓存一级一级找。回到开始的，看没拿到的情况，也就是else代码块的代码。 通过父BeanFactory获取bean 可以看到，这段代码先通过getParentBeanFactory()父BeanFactory，如果存在，并且当前的BeanFactory不存在对应beanName的BeanDefinition，那么就会尝试使用父BeanFactory获取Bean。 DefaultSingletonBeanRegistry#getSingleton先看下面的代码段： RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);上面讲过了，看下面处理dependsOn的 比如这样定义一个bean 那这个student的实例化是要依赖james13的，也就是说james13要先实例话，student才能实例话。回到源码，逻辑就是上面的逻辑，也就是先去getBean(‘james13’)，然后在往下实例化student 接着看代码块： 从if就知道，这代码块就是创建单例的Bean，也就是默认的情况。 getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法又是从DefaultSingletonBeanRegistry继承过来的 看DefaultSingletonBeanRegistry#getSingleton方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, &quot;Bean name must not be null&quot;); synchronized (this.singletonObjects) &#123; //如果缓存中有，则直接返回 Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; //打印日志 ...... //把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;&gt;(); &#125; try &#123; //如果这里有返回值，就代表这个bean已经结束创建了，已经完全创建成功 singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException ex) &#123; // Has the singleton object implicitly appeared in the meantime -&gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw ex; &#125; &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; //bean创建完成后singletonsCurrentlyInCreation要删除该bean afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; //创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存 addSingleton(beanName, singletonObject); &#125; &#125; return singletonObject; &#125;&#125; 注这里的 123456789ObjectFactory&lt;?&gt; singletonFactory = &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; ..... throw ex; &#125;&#125; 先从一级缓singletonObjects集合中存拿对象，看没拿到的情况就会进行创建逻辑 beforeSingletonCreation(beanName);，该方法的作用就是把beanName添加到singletonsCurrentlyInCreation容器中，在这个集合里面的bean都是正在实例化的bean。 接着到 这个singletonFactory是在进入方法时传的一个匿名对象 也就是说，调用getObject时，实际上时调用了createBean(beanName, mbd, args)方法。注意 getObject调用完成后，就意味着bean已经完成了创建 上面的createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)方法是在AbstractBeanFactory中定义的，它是一个抽象方法，这个方法的实现由AbstractAutowireCapableBeanFactory实现。 看AbstractAutowireCapableBeanFactory#createBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. try &#123; mbdToUse.prepareMethodOverrides(); &#125; //去掉了catch语句块 ....... try &#123; /* * TargetSource接口的运用，可以在用改一个类实现该接口，然后在里面定义实例化对象的方式，然后返回 * 也就是说不需要spring帮助我们实例化对象 * * * 这里可以直接返回实例本身 * * 这个代码不用看，实际开发过程中用不到，我会做为一个甜点分享 * */ // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; //去掉了catch语句块 ....... try &#123; //主要看这个方法，重要程度 5 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Finished creating instance of bean &#x27;&quot; + beanName + &quot;&#x27;&quot;); &#125; return beanInstance; &#125; //去掉了catch语句块 .......&#125; 重点看这段代码块： AbstractAutowireCapableBeanFactory#doCreateBean1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; //创建实例,,重点看，重要程度：5 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; Object bean = instanceWrapper.getWrappedInstance(); Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass(); if (beanType != NullBean.class) &#123; mbd.resolvedTargetType = beanType; &#125; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; //CommonAnnotationBeanPostProcessor 支持了@PostConstruct，@PreDestroy,@Resource注解 //AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解 //BeanPostProcessor接口的典型运用，这里要理解这个接口 //对类中注解的装配过程 //重要程度5，必须看 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; //打印日志 ....... &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. //是否 单例bean提前暴露 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isTraceEnabled()) &#123; //打印日志 ...... &#125; //这里着重理解，对理解循环依赖帮助非常大，重要程度 5 添加三级缓存 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; //ioc di，依赖注入的核心方法，该方法必须看，重要程度：5 populateBean(beanName, mbd, instanceWrapper); //bean 实例化+ioc依赖注入完以后的调用，非常重要，重要程度：5 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; catch (Throwable ex) &#123; //抛出BeanCreationException错误 ....... &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; //抛出BeanCurrentlyInCreationException错误 ....... &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; //注册bean销毁时的类DisposableBeanAdapter registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; //抛出BeanCreationException错误 ....... &#125; return exposedObject;&#125; 这是一个非常非常重要的方法，这里包含一个Spring bean的整个初始化流程，重要的方法 BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) 下面我们一个个方法 createBeanInstance—-Bean 的实例化过程（控制反转IOC）先看这段代码，也就是开头的代码 真正是实例就是在这段代码里完成的。 先总结这个方法的作用： 源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) &#123; // Make sure bean class is actually resolved at this point. Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; //抛出BeanCreationException错误 ....... &#125; Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier(); if (instanceSupplier != null) &#123; return obtainFromSupplier(instanceSupplier, beanName); &#125; //如果有FactoryMethodName属性 @Bean if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; return instantiateBean(beanName, mbd); &#125; &#125; // Candidate constructors for autowiring? //寻找当前正在实例化的bean中有@Autowired注解的构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; //如果ctors不为空，就说明构造函数上有@Autowired注解 return autowireConstructor(beanName, mbd, ctors, args); &#125; // Preferred constructors for default construction? ctors = mbd.getPreferredConstructors(); if (ctors != null) &#123; return autowireConstructor(beanName, mbd, ctors, null); &#125; //无参构造函数的实例化,大部分的实例是采用的无参构造函数的方式实例化 // No special handling: simply use no-arg constructor. return instantiateBean(beanName, mbd);&#125; &lt;bean&gt;标签里面。配置了factory-method属性的情况先执行这里： 这段代码的if只有在下面的情况才会进去。 标签里面。配置了factory-method属性 或者方法上面加上@Bean注解 看下AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod方法。 ConstructorResolver#instantiateUsingFactoryMethod方法:(不弄完整的代码了，只看核心的) 这样配置的情况 创建好了BeanWrapperImpl包装类后，调用beanFactory.getBean(factoryBeanName)，也就是说先去获取factoryBean(没有就执行创建流程)，获取到了方法所对应的对象，并且isStatic &#x3D; false。接着走 从所有factoryBean对应的类中拿到全部方法，并找到匹配的方法，而且由于isStatic &#x3D; false，所以不能拿到静态的方法。接着走 instantiate方法不用看了，就是用反射调用这种形式的api：Method.invoke(Object object, Object... args) 方法调用完后就按定义实力化bean了，并返回了。接着会把放回的bean放入到之前创建的BeanWrapperImpl的对象中。后面还有多个方法，不过我不想看了，最后还是只有一个方法会被调用。 不过除了上面的情况还，还可以这样配置 不过这就要求方法factoryMethod是静态的方法了。这种情况就会走到一开始的else情况，后面都一样 factory-method的处理结束了。 方法上面加上@Bean注解@Bean的方式是使用了factory-method的方式来实现的，它使用的是非静态方法的那种方式。 比如有这样的配置类 其实就是相当于 实例化带有@Autowired注解的构造函数回到AbstractAutowireCapableBeanFactory#createBeanInstance，代码一直走 这个方法的作用就是通过构造方法注入值，比如有这样一个类 那Spring会把sc对象，和cq对象传入AutowiredConsturctorBean对象中。看回源码。 代码determineConstructorsFromBeanPostProcessors getBeanPostProcessors()回获取BeanPostProcessor的实例，这些实例是在refresh()方法中，执行了BeanDefinitionRegistryPostProcessor这种后置处理器的方法后，调用了registryBeanPostProcessor方法去实例化对应的BeanPostProcessor的实例，并且注册到beanFacotry的beanPostProcessors中 回到for代码。这里会有多个BeanPostProcessor会被调用到，不过我们关注的是这个 AutowireAnnotationBeanPostProcessor，进去看determineCandidateConstructors方法 代码接着走 遍历构造函数，获取到构造函数上的@Autowired注解信息，接着 获取@Autowired的required的值，默认为true。这个值的作用就是为true时，如果注入的对象不存在就报错，为false的时候，如果如果注入的对象不存在，不报错(对应引用，还是使用默认值null)。 最后 放入candidateConstructorsCache后就返回了 回到AbstractAutowireCapableBeanFactory#createBeanInstance，假如返回的不为null，那看方法 autowireConstructor(beanName, mbd, ctors, args): 看ConstructorResolver#autowireConstructor方法 该方法其实是更具构造方法创建对象的过程，不过有个问题，就是构造方法的参数怎么获取。其实我猜测和factoryMethod一样。跟踪源码一直到 这方法的流程太长了，代码不看了，最后都会调用beanFactory.getBean方法。 有一种情况，多个构造函数上有@Autowire，默认情况下会报错，因为源码中 回到AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors方法，在 只要required&#x3D;false就不报错了。如果有多个构造函数，会根据构造函数参数个数排序，而且只会用一个构造函数。 实例化没有@Autowired的有参构造函数AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors方法在没有@Autowired是会根据情况返回构造函数的。之后都是调用autowireConstructor方法的。不过对于这种情况要注意一点，如果想这种情况走通，一定只能有一个带参数的构造函数。 实例化无参构造函数上面的情况都不符合的才会走到这里 总结其实就是如果有依赖别的bean的，先去创建别的bean。而且这里只是分配的内存空间，对象的属性还没有处理，也就是还没到依赖注入这阶段。 applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程createBeanInstance方法只是实例化对象(控制反转)，并没有处理依赖注入的问题。而applyMergedBeanDefinitionPostProcessors会对类中注解执行收集过程 又是getBeanPostProcessors()，在这里Spring会帮我们放入一些BeanPostProcessor，这里还有个要求，就是要实现的是MergedBeanDefinitionPostProcessor这个接口，看会01-Spring中BeanDefinition的创建和注册最后的3张类图，我们关注的3个BeanPostProcessor只有两个是实现这个接口的。这两个就是 CommonAnnotationBeanPostProcessor AutowiredAnnotationBeanPostProcessor 下面看这个两个类的postProcessMergedBeanDefinition方法 AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition跟踪代码 123456789101112131415161718192021222324252627public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition);&#125;private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, @Nullable PropertyValues pvs) &#123; // Fall back to class name as cache key, for backwards compatibility with custom callers. String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // Quick check on the concurrent map first, with minimal locking. InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; synchronized (this.injectionMetadataCache) &#123; metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; if (metadata != null) &#123; metadata.clear(pvs); &#125; //主要看这个方法 metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); &#125; &#125; &#125; return metadata;&#125; ---&gt;AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata findAutowiringMetadata的作用就是缓存和从缓存中拿InjectionMetadata对象，其核心就是调用了buildAutowiringMetadata。 看AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123; if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) &#123; return InjectionMetadata.EMPTY; &#125; List&lt;InjectionMetadata.InjectedElement&gt; elements = new ArrayList&lt;&gt;(); Class&lt;?&gt; targetClass = clazz; do &#123; final List&lt;InjectionMetadata.InjectedElement&gt; currElements = new ArrayList&lt;&gt;(); //寻找field上面的@Autowired注解并封装成对象 ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123; MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field); if (ann != null) &#123; if (Modifier.isStatic(field.getModifiers())) &#123; //去掉一些打印日志的 ..... return; &#125; boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); &#125; &#125;); //寻找Method上面的@Autowired注解并封装成对象 ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123; Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123; return; &#125; MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod); if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123; //去掉一些打印日志的 ..... boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); &#125; &#125;); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); &#125; while (targetClass != null &amp;&amp; targetClass != Object.class); return InjectionMetadata.forElements(elements, clazz);&#125; 这里就是收集这个类上，有某些注解的属性，而判断的的方法就是在findAutowiredAnnotation 123456789101112131415161718192021222324public AutowiredAnnotationBeanPostProcessor() &#123; this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try &#123; this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;) ClassUtils.forName(&quot;javax.inject.Inject&quot;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;); &#125; catch (ClassNotFoundException ex) &#123; // JSR-330 API not available - simply skip. &#125;&#125;@Nullableprivate MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123; MergedAnnotations annotations = MergedAnnotations.from(ao); for (Class&lt;? extends Annotation&gt; type : this.autowiredAnnotationTypes) &#123; MergedAnnotation&lt;?&gt; annotation = annotations.get(type); if (annotation.isPresent()) &#123; return annotation; &#125; &#125; return null;&#125; 可以看到，这里有3个注解。其中就有@Autowired和@Value 而且，会把有这些注解的Field（属性）和 required（是否必须，默认为true）值包装成一个AutowiredFieldElement对象。 后面一个doWithLocalMethods是找方法上有@Autowire的，把必要信息封装成AutowiredMethodElement： 也就是说，只要有@Value和@Autowire的注解的方法或属性，就会创建一个AutowiredMethodElement对象，然后放到一个集合中。 最后，将上边创建的AutowiredMethodElement对象集合封装成InjectionMetadata并返回： 该方法返回后，会把InjectionMetadata对象放到一个injectionMetadataCache缓存中。 CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinitionCommonAnnotationBeanPostProcessor的过程和上面基本一样，就是关注的注解不同。 不过这个类实际上只是处理了@Resource注解而已，真实的处理@PostConstruct和@PreDestroy注解的是在其父类InitDestroyAnnotationBeanPostProcessor上处理的。 12345public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName); InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition);&#125; 不过处理的逻辑都是一样，@PostConstruct和@PreDestroy只能在方法上。而@Resource能在属性和方法上。不过，对应注解封装成的对象不同而已，对于@PostConstruct和@PreDestroy的方法封装成LifecycleElement，对于@Resource，会封装成ResourceElement。 CommonAnnotationBeanPostProcessor其实还有其他注解的 WebServiceRef EJB 不过这些用都没用过，就不管了 总结这个方法就是去收集注解的 12CommonAnnotationBeanPostProcessor 收集了@PostConstruct，@PreDestroy,@Resource注解AutowiredAnnotationBeanPostProcessor 收集了 @Autowired,@Value注解 addSingletonFactory—对理解循环依赖帮助非常大 这里着重理解，对理解循环依赖帮助非常大，重要程度 5 添加三级缓存 这个方法在doCreateBean方法中的代码段是: 执行的前提是这个Bean的作用域是Singleton、beanFactory的allowCircularReferences为true（也就是开启循环依赖，默认开启）最后要isSingletonCurrentlyInCreation(beanName)。 这个isSingletonCurrentlyInCreation(beanName)是什么意识呢？DefaultSingletonBeanRegistry#getSingleton代码的（也就是doCreateBean的外层方法），调用了下面代码 1beforeSingletonCreation(beanName); 把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean 而isSingletonCurrentlyInCreation(beanName)就是判断这个beanName是否在singletonsCurrentlyInCreation Set容器的，也就是判断是否在创建中。正常情况会这个方法会返回true 条件都满足了就调用代码： 1addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); 这里先记下这个ObjectFactory&lt;?&gt; singletonFactory = () -&gt; getEarlyBeanReference(beanName, mbd, bean)对象记下，看addSingletonFactory源码: 12345678910111213protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;); synchronized (this.singletonObjects) &#123; //如果一级缓存不存在 if (!this.singletonObjects.containsKey(beanName)) &#123; //设置三级缓存 this.singletonFactories.put(beanName, singletonFactory); //删除二级缓存 this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125;&#125; 代码很简单，重要的一个作用就是设置三级缓存。 首先singletonObjects如果存在，就表示这个对象已经创建完成了，没有的话就会去设置三级缓存，并删除二级缓存。 看下三级缓存的定义 也就是说设置三级缓存的意义就是建立beanName和这个对象——() -&gt; getEarlyBeanReference(beanName, mbd, bean)的映射关系。 这个方法的作用就是这个，没别的了。 populateBean—依赖注入（DI）的核心方法依赖注入的核心方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) &#123; //去掉不重要的方法 .... //这里很有意思，写接口可以让所有类都不能依赖注入 if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; return; &#125; &#125; &#125; &#125; PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null); int resolvedAutowireMode = mbd.getResolvedAutowireMode(); if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE); PropertyDescriptor[] filteredPds = null; //重点看这个if代码块，重要程度 5 if (hasInstAwareBpps) &#123; if (pvs == null) &#123; pvs = mbd.getPropertyValues(); &#125; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; //依赖注入过程，@Autowired的支持 PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; //老版本用这个完成依赖注入过程，@Autowired的支持 pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvsToUse == null) &#123; return; &#125; &#125; pvs = pvsToUse; &#125; &#125; &#125; if (needsDepCheck) &#123; if (filteredPds == null) &#123; filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); &#125; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; //这个方法很鸡肋了，建议不看，是老版本用&lt;property name=&quot;username&quot; value=&quot;Jack&quot;/&gt; //标签做依赖注入的代码实现，复杂且无用 if (pvs != null) &#123; applyPropertyValues(beanName, mbd, bw, pvs); &#125;&#125; 这里我们按功能来分析代码，先看下面代码块。 这里又是BeanPostProcessor接口的应用。 这里我们可以自己写个类实现InstantiationAwareBeanPostProcessor接口，postProcessAfterInstantiation方法返回一个false，就可以不走依赖注入了。比如弄个有条件的依赖注入，类似这样 感觉这个扩展没什么用，只是用来坑人用的。接着后面的代码 又是BeanPostProcessor接口的应用，虽然实现InstantiationAwareBeanPostProcessor的类比较多，不过我们还是只关注两个 AutowiredAnnotationBeanPostProcessor#postProcessProperties 这个方法之前已经说过了。 之前在applyMergedBeanDefinitionPostProcessors已经收集好了注解了，而且，做了一个beanName和InjectionMetadata的映射。所以这里只需要用beanName就可以获取到InjectionMetadata对象了，这个对象就包含了beanName中，对应的注解信息（@Autowite，@Value等）。之后执行metadata.inject，这个方法就是依赖注入的核心。 先看AutowiredFieldElement#inject 重点是这个方法，这个方法会触发beanFactory.getBean方法的，也就是说如果A-&gt;B-&gt;C。 A在这个方法中会触发beanFactory.getBean(B)。接着B又在这个方法中会触发beanFactory.getBean(C) 最后调用 第一个就是调用field.setAccessible(true);，然后通过反射向字段设置值，也就是说依赖的属性现在经过这样的处理后就完成了值的设置了。 DI已经完成了，原理是真的简单，重点只是在收集注解上而已。 方法的依赖注入都一样的。 CommonAnnotationBeanPostProcessor#postProcessProperties对于@Resource注解，和上面都是一样的。 引用循环依赖的解决过程在AutowiredFieldElement#inject的 这里会触发依赖对象的beanFactory.getBean，上面说的情况是没有循环依赖的。 不过如果有这样的一种依赖情况—— A-&gt;B-&gt;A，这种也就是循环依赖的情况。 依赖情况—— A-&gt;B-&gt;A 一开始调用了A的doGetBean方法，接着又触发了B的doGetBean，由于循环依赖的关系，B的doGetBean又触发了A的doGetBean。这个流程看上去是一个死循环。但是如果在最后的A的doGetBean时，直接返回A的对象，而不去触发创建操作那当B拿到A对象，方法就返回了，并完成了Spring Bean的初始化流程，那么当B的doGetBean返回后，A也就会继续走其他流程了。下面看Spring源码是怎么实现这一步骤的。 我建立如下的调用顺序： A的doGetBean B的doGetBean B的doGetBean又触发了A的doGetBean 由于1在执行populateBean方法之前已经创建A这个对象，而且还会调用方法addSingletonFactory，建立了Map&lt;A,() -&gt; getEarlyBeanReference(beanName, mbd, bean)&gt;这种映射关系。2步骤没问题，看3步骤： A的doGetBean时，会调用 12//从缓存中拿实例Object sharedInstance = getSingleton(beanName); 前面简单的讲过这个方法，现在看回这个方法的源码。 123456789101112131415161718192021222324252627282930public Object getSingleton(String beanName) &#123; return getSingleton(beanName, true);&#125;protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; //根据beanName从缓存中拿实例 //先从一级缓存拿 Object singletonObject = this.singletonObjects.get(beanName); //如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; //从二级缓存中拿 singletonObject = this.earlySingletonObjects.get(beanName); //如果还拿不到，并且允许bean提前暴露 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; //从三级缓存中拿到对象工厂 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; //从工厂中拿到对象 singletonObject = singletonFactory.getObject(); //升级到二级缓存 this.earlySingletonObjects.put(beanName, singletonObject); //删除三级缓存 this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return singletonObject;&#125; 由于在1步骤中，A已经在三级缓存有这样一个对象了——() -&gt; getEarlyBeanReference(beanName, mbd, bean)。 注意，这里的bean的对象就是目标对象，也就是A对象。 也就是说，到这一步时 1ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); 得到的结果是singletonFactory &#x3D; () -&gt; getEarlyBeanReference(beanName, mbd, bean) 接着就执行了 1singletonObject = singletonFactory.getObject(); 也就是说，这里实际执行的getEarlyBeanReference(beanName, mbd, bean)方法，这个方法是在类AbstractAutowireCapableBeanFactory中的。看这个方法 123456789101112protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123; Object exposedObject = bean; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof SmartInstantiationAwareBeanPostProcessor) &#123; SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp; exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName); &#125; &#125; &#125; return exposedObject;&#125; 又是BeanPostProcessor的应用，而之所以这样，是因为返回的对象不一定是对象本身，比如AOP，它就需要返回一个代理对象了，所以在这才又使用 了这种BeanPostProcessor的应用。 这里会返回A对象，那么回到getSingleton()方法，这时会把该对象放入到二级缓存中，并删除三级缓存。getSingleton()的流程结束了，看拿到A的对象后做了什么。 最后还调用了getObjectForBeanInstance方法，这个方法就是FactoryBean接口的调用入口，暂时不看。else 不进入的话就不会去创建了，所以这里返回了，整个流程就和我一开始说的一样。只要在3这步切断A的createBean步骤就可以切断这个闭环了。 构造函数的循环依赖Spring是解决不了这种循环依赖的，对于引用的情况，是先创建了对象后才设置引用的。而构造函数的循环依赖是因为这时对象还在创建中，依赖的对象又在创建中。 所以Spring对于构造函数的循环依赖，会直接在启动的时候报错。 不过如果在构造函数上加上@Lazy就可以，因为实例化时获取到的依赖对象是一个代理对象，所以不存在循环依赖。 不过如果@Lazy加载两个类上还会有问题。 Bean范围为Pototype的时候的循环依赖这时bean是不会使用到3级缓存的，在源码AbstractBeanFactory#getBean中是没有调用到DefaultSingletonBeanRegistry#getSingleton方法的，这个方法就是使用3级缓存的。 该代码块直接调用了createBean，那只会触发bean的创建流程。但出现循环依赖，对同一对象的第二次调用doGetBean时，会进入到这段代码块: 会直接报错。 initializeBean—-依赖注入完以后的调用bean 实例化+ioc依赖注入完以后，会调用某些接口的方法。而initializeBean就是处理这个逻辑： 1234567891011121314151617181920212223242526272829303132333435363738protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123; invokeAwareMethods(beanName, bean); return null; &#125;, getAccessControlContext()); &#125; else &#123; //调用Aware方法 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; //对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5 //ApplicationContextAwareProcessor 对Aware接口的调用如： //EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware //ImportAwareBeanPostProcessor 对ImportAware的支持 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; //这个地方可能生出代理实例，是aop的入口 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 一个一个方法看。 invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware12345678910111213141516private void invokeAwareMethods(String beanName, Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ClassLoader bcl = getBeanClassLoader(); if (bcl != null) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl); &#125; &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 这个方法是对实现了这些接口的类的方法调用。 BeanNameAware BeanClassLoaderAware BeanFactoryAware applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5 12345678910111213public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor processor : getBeanPostProcessors()) &#123; Object current = processor.postProcessBeforeInitialization(result, beanName); if (current == null) &#123; return result; &#125; result = current; &#125; return result;&#125; 又是BeanPostProcessor的运用，会调用BeanPostProcessor#postProcessBeforeInitialization方法 有很多，我们只关注一些类 InitDestroyAnnotationBeanPostProcessor——@PostConstruct 这里会去调用加了这个@PostConstruct的方法。 该类是CommonAnnotationBeanPostProcessor的父类，CommonAnnotationBeanPostProcessor会在AnnotationConfigUtils#registerAnnotationConfigProcessors方法中，加入到Spring中，也就是在创建BeanDefinition阶段。 ApplicationContextAwareProcessor——又是Aware接口调用 1234567891011121314151617181920private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125;&#125; 挺简单的，就是会去调用这些接口的方法 EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware 这个是在AbstractApplicationContext.refresh方法中调用的prepareBeanFactory方法中添加进去的 ImportAwareBeanPostProcessor 调用了ImportAware的方法 比如这样写了一个类 是触发不到这段代码的，需要这样写也就是说只有通过@Import()注解注入的类才能调用到ImportAware#setImportMetadata方法。为什么会这样，这就涉及到这个类ConfigurationClassPostProcessor。这个类在之后会说。 这个是类是通过ConfigurationClassPostProcessor的postProcessBeanFactory方法加入进来的，也就是在Spring bean初始化之前。而ConfigurationClassPostProcessor又是通过AnnotationConfigUtils#registerAnnotationConfigProcessors加入进来的。 ServletContextAwareProcessor——ServletContextAware，ServletConfigAware 这是使用在使用Spring MVC的时候才会被加入到Spring中。 invokeInitMethods—-InitializingBeanInitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5 123456789101112131415161718192021222324252627282930313233protected void invokeInitMethods(String beanName, Object bean, @Nullable RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123; ...... if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; //调用实现了InitializingBean接口的方法 ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) &#123; String initMethodName = mbd.getInitMethodName(); if (StringUtils.hasLength(initMethodName) &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; //调用init-method配置的方法 invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 从源码可以看到，会调用InitializingBean接口的方法和bean标签的init-method方法。 applyBeanPostProcessorsAfterInitialization—-是aop的入口这个地方可能生出代理实例，是aop的入口 前面有个applyBeanPostProcessorsBeforeInitialization方法，这个叫AfterI，很明显又是BeanPostProcessor接口的应用。 看了这么多BeanPostProcessor了，都是在循环中的，而且都是对一个Bean循环的，可以看到，如果某个类对对应的方法感兴趣了，就在对应的方法了做一些对类的操作，不感兴趣了就直接返回就好了。而且，BeanPostProcessor这种使用方式感觉就是使用了装饰器模式，虽然没有装饰器模式的形，但有装饰器模式模式的魂—-给原始类添加增强功能 这里先讲一个类ApplicationListenerDetector。 我们之前讲过 ApplicationListener接口的，也就是监听类。这个监听类就是在ApplicationListenerDetector#postProcessAfterInitialization方法添加到applicationContext的事件管理类中的。（注意这里是实现接口，但注解的情况在这里没有处理，注解的情况后面会说） 还有一个AnnotationAwareAspectJAutoProxyCreator这个是AOP的入口方法，详情看这两节 08-Spring-AOP概念 09-Spring-AOP解析 registerDisposableBeanIfNecessary—注册DisposableBeanAdapter 1注册bean销毁时的类DisposableBeanAdapter 代码很简单registerDisposableBean就是在下面的Map中建立&lt;beanName, DisposableBeanAdapter&gt;这种映射关系。 DisposableBeanAdapter就是用于bean销毁（这里的销毁不是触发GC，而是Spring结束前对bean做的一些操作）的实例 DisposableBeanAdapter的构造函数做如下操作 是否有实现了接口DisposableBean和AutoCloseable 在bean标签中是否定义了destroy-method属性 获取到对象中有@PreDestory注解的方法。 什么时候触发的？手动这样触发的 Tomcat启动时，AbstractReactiveWebInitializer这个类里面会为Tomcat添加一个ServletContextListener，当tomcat触发close方法时，会调用contextDestroyed方法 123456789101112131415161718192021222324@Overridepublic void contextDestroyed(ServletContextEvent sce) &#123; this.applicationContext.close();&#125;@Overridepublic void close() &#123; synchronized (this.startupShutdownMonitor) &#123; // 这里会调用getBeanFactory().destroySingletons(); // destroySingletonsa会去触发DisposableBeanAdapter的destroy方法 doClose(); // If we registered a JVM shutdown hook, we don&#x27;t need it anymore now: // We&#x27;ve already explicitly closed the context. if (this.shutdownHook != null) &#123; try &#123; Runtime.getRuntime().removeShutdownHook(this.shutdownHook); &#125; catch (IllegalStateException ex) &#123; // ignore - VM is already shutting down &#125; &#125; &#125;&#125; DefaultSingletonBeanRegistry#getSingleton —-Bean创建完成后看DefaultSingletonBeanRegistry#getSingleton代码，上面的都只是这个调用的过程 12//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的beanbeforeSingletonCreation(beanName); 接着调用 12345678afterSingletonCreation(beanName);protected void afterSingletonCreation(String beanName) &#123; if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.remove(beanName)) &#123; //抛出IllegalStateException ..... &#125;&#125; 之前的beforeSingletonCreation是把beanName添加到singletonsCurrentlyInCreation Set容器中，表示这个Bean正在创建；而创建完成后，就调用了afterSingletonCreation方法，把beanName在singletonsCurrentlyInCreation Set容器中移除，表示Bean已经创建完成了。 最后调用了 12345678910111213141516if (newSingleton) &#123; //创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存 addSingleton(beanName, singletonObject);&#125;protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; //一级缓存 this.singletonObjects.put(beanName, singletonObject); //三级缓存 this.singletonFactories.remove(beanName); //二级缓存 this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); //这是设计到统计的 &#125;&#125; 把创建好的Bean放入到一级缓存singletonObjects中，并把二、三级缓存删掉。 总结下这个方法的作用，就是在缓存中没有对象的时候会去调用jvm的对象创建流程，创建完成成后，封装一个ObjectFactory并放入三级缓存中，在三级缓存建立&lt;beanName, ObjectFactory&gt;这样的对应关系，当处理IOC和DI时，如果出现循环依赖就通过三级缓存的ObjectFactory获取到之前已经创建好的jvm对象，并移出三级缓存进入二级缓存。最后IOC和DI处理完，并且对应接口的调用也调用完了，就把bean放入到一级缓存中，并移除二级、三级缓存对应的值。而对象创建的流程时通过方法createBean实现的，并不是getSingleton的逻辑。getSingleton的核心逻辑就是只是使用了singletonObjects 这个一级缓存。 放入一级缓存Bean初始化完成后，也就是AbstractBeanFactory#createBean方法调用完成后， 这时会返回对象，也就是DefaultSingletonBeanRegistry的getSingleton方法中 这代码执行完成了。最后就是执行了这些方法 1234567891011protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; //一级缓存 this.singletonObjects.put(beanName, singletonObject); //三级缓存 this.singletonFactories.remove(beanName); //二级缓存 this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); //这是设计到统计的 &#125;&#125; 上边的是只有scope&#x3D;”Singleton”时才会执行到，也就是说只有时单例模式，spring才会缓存对象。如果是prototype，也就是多例的时候，是不会用到缓存的。看源码 1234567891011121314//AbstractBeanFactory#doGetBeanelse if (mbd.isPrototype()) &#123; // It&#x27;s a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; //该方法是FactoryBean接口的调用入口 bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125; 可以看到，对于多例它是直接createBean的，没有通过getSingleton方法，来缓存。 实现FactoryBean接口的类的实例化这个和FactoryBean接口有关 FactoryBean接口的getObject在这个类实例化过程中是不会调用getObject方法的，只有在需要使用getObject返回对象时才会去调用这个方法。 回到refresh()方法。跟踪代码： 123AbstractApplicationContext#refresh --&gt;AbstractApplicationContext#finishBeanFactoryInitialization --&gt; DefaultListableBeanFactory#preInstantiateSingletons 看DefaultListableBeanFactory#preInstantiateSingletons部分源码 这个if就是判断是否实现了FactoryBean接口，这里就看if代码块的代码，先看 123String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;Object bean = getBean(FACTORY_BEAN_PREFIX + beanName); 也就是说，对于FactoryBean类，在调用getBean时会使用&amp;beanName这种形式去找bean 这时，经过transformedBeanName又去掉了&amp;符号，并把这个值赋给了新引用。 我们找的目标bean的名字就是beanName引用的指向的字符串。而且这个beanName是有对应的BeanDefinition，这个BeanDefinition指向的类是实现了FactoryBean接口的。所以如果走完Bean的初始化流程，那初始化出来的对象的类型肯定不是我们的目标类型。而是实现了FactoryBean接口类的类型 下图返回的是一个代理对象，之所以是代理是因为如果不是代理对象的情况下，直接返回FactoryBean接口对象，那么如果程序通过&amp;baenName获取到该FactoryBean对象，接着通过这个对象调用getObject()方法，那么就会产生一个新的目标对象，这和Spring中bean的范围为singleton相矛盾了，所以这里返回的代理对象，就算程序通过&amp;baenName获取FactoryBean对象，由于这个FactoryBean对象是代理对象，那么在调用getObject()时就能做一些前置处理，比如检查目标对象是否在缓存中存在，如果存在就直接返回就行了。 也就是说，在这个时候在一级缓存singletonObjects 这个Map中就存在一个这样的关系 1&lt;beanName, FactoryBean接口类（代理）&gt; 接着会执行这个方法 1AbstractBeanFactory.getObjectForBeanInstance(sharedInstance, name, beanName, mbd) 调用这个方法的时候name&#x3D;&amp;beanName， beanName&#x3D;beanName的，这从上图就已经证明。 1234567891011121314151617181920protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory. // 检查是否以&amp;开头 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass()); &#125; if (mbd != null) &#123; mbd.isFactoryBean = true; &#125; return beanInstance; &#125; .....&#125; 那么在上边的情况这时&#96;if (BeanFactoryUtils.isFactoryDereference(name)) 为true，就直接放回了。所以当通过&amp;beanName获取到的对象为FactoryBean的对象。此时，这个bean的初始化就已经结束了。下面看FactoryBean.getObject方法是什么时候调用的。 假如某个类的定义如下 123456789101112131415@Component(&quot;bObject&quot;)public AFactoryBean implements FactoryBean&lt;BObject&gt; &#123; ..... public BObject getObject() throws Exception &#123; renturn new BObject(); &#125; ....&#125;@Componentpublic C &#123; @Autowire private BObject bObject;&#125; 那么在该类C的DI阶段，就会调用beanFactory.getBean(“bObject”)，那么此时 1Object sharedInstance = getSingleton(&quot;bObject&quot;); 这代码会返回一个对象，而且这个对象是AFactoryBean，此时进入到getObjectForBeanInstance方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) &#123; // Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory. // 检查是否以&amp;开头 if (BeanFactoryUtils.isFactoryDereference(name)) &#123; if (beanInstance instanceof NullBean) &#123; return beanInstance; &#125; if (!(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(beanName, beanInstance.getClass()); &#125; if (mbd != null) &#123; mbd.isFactoryBean = true; &#125; return beanInstance; &#125; // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. //如果实例不是FactoryBean类型的 if (!(beanInstance instanceof FactoryBean)) &#123; return beanInstance; &#125; //如果代码能走下来，则说明 beanName不是以&amp;开头，并且beanInstance是FactoryBean类型的 Object object = null; if (mbd != null) &#123; mbd.isFactoryBean = true; &#125; else &#123; //从缓存里面拿FactoryBean类型的实例 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); //重点看 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; 由于beanName是bObject，所以不会进入到if代码，那么此时最后会走到这代码块 重点看 1object = getObjectFromFactoryBean(factory, beanName, !synthetic); 先从缓存factoryBeanObjectCache 中拿，没有就执行下边的doGetObjectFromFactoryBean方法 这个方法放回后，想都不用想，就是把拿到的目标对象放到缓存factoryBeanObjectCache中。下次再通过beanName就可以直接在缓存factoryBeanObjectCache中获取了。 而如果这时时通过&amp;beanName去获取bean，那么进入doGetBean时会把&amp;去掉后获取到一个实现FactoryBean类型类的对象，之后进入getObjectForBeanInstance(sharedInstance, name, beanName, mbd)时由于BeanFactoryUtils.isFactoryDereference(name)为true，所以就直接返回了实现FactoryBean类型类的对象了（注意，这个是代理对象）。 FactoryBean的应用场景可以提供用户自己定义实例化 在Spring中如果你想创建一个对象，对象能被Spring管理 自定义BeanDefination，通过BeanDefinitionRegistryPostProcessor接口 实现FactoryBean @Bean Spring bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口回到DefaultListableBeanFactory#preInstantiateSingletons() 在这里会调用接口SmartInitializingSingleton的方法。 这里说一个类就是EventListenerMethodProcessor。 EventListenerMethodProcessor——@EventListener注解的解析[Spring Event事件通知机制](.&#x2F;Spring Event事件通知机制) Spring初始化流程中的三级缓存在Spring的初始化流程会使用到三级缓存 123private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap(16);private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16); 其中singletonObjects就是最缓存最终的对象的。而earlySingletonObjects和singletonFactories相互配合使用，完成了Bean的初始化流程 比如：存在这样一个类 1234class A &#123; @Autowrite A a;&#125; 首先一个，在beanFactory.getBean(A)的时候， new A 收集A中的注解信息（@Autowrite、@Resource、@Value和@PostConstruct等注解信息） 创建一个包含A对象引用的ObjectFactory对象，并把这个对象放入3级缓存中。 populateBean，完成Bean的填充（DI依赖注入）和@PostConstruct等注解的处理 在处理依赖注入时，本质上就是进行beanFactory#getBean，所以对于A对象的依赖注入，会进行beanFactory.getBean(a) 从三级缓存中一级一级的拿对象，最终在第三级singletonFactories中获取到一个ObjectFactory对象。然后会执行ObjectFactory#getObject。 会对ObjectFactory对象中的A对象进行AbstractAutoProxyCreator#getEarlyBeanReference，也就是进行切面的匹配，匹配到的话就生成代理对象。 把第二步中返回的A对象（或A对像的代理对象）放入二级缓存，并移除3级缓存（这时二级缓存已经是最终的对象了） 把第3步的对象返回，作为A对象中a属性引用的对象。 对A对象进行initializeBean，并返回A对象（或A对像的代理对象） BeanPostProcessor#postProcessBeforeInitialization的执行，包括对ApplicationEventPublisherAware、ApplicationContextAware等接口的处理和@PostConstruct的等注解的处理 执行InitializingBean#afterPropertiesSet BeanPostProcessor#postProcessAfterInitialization的执行，并返回A对象（或A对像的代理对象） 最重要的就是AbstractAutoProxyCreator，完成切面匹配和代理类生成。对于A对象，由于在4.2中已经执行过这一步了，所以这里不会重复执行，会直接返回A对象。 会从二级缓存拿对象，如果没有就直接返回A对象。如果有就返回二级缓存对象（A对象或者A对像的代理对象） 对于没有的情况，是不存在循环依赖才会出现这种情况，而对于有的情况，就意味着有循环引用。 对于A对象，由于在第4步中提前完成了切面匹配和代理对象的生成，所以这里会返回A对象（或A对像的代理对象） 把第6步返回的对象（A对象或者A对像的代理对象）放入到一级缓存中，并移除二三级缓存对应的内容。 从这个过程可以看出，三级缓存singletonFactories就是用来避免循环依赖时，重复触发creaetBean的问题，并且会对Bean提交进行包装（AOP）。而二级缓存earlySingletonObjects存放提前完成包装的对象（AOP），并负责提前暴露给其他bean。 Spring Bean初始化流程图 Spring Bean 循环依赖的流程图","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"03-Spring的Bean实例化前的方法","slug":"spring/5.2.8/03-Spring的Bean实例化前的方法","date":"2021-11-20T12:00:09.000Z","updated":"2022-03-14T09:04:25.139Z","comments":true,"path":"blog/spring/5.2.8/03-Spring的Bean实例化前的方法/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/03-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"Spring的Bean实例化前的方法上节讲了BeanDefinitionRegistryPostProcessor的实例化和调用时机。 这节看Bean实例化前执行的一些重要方法。 回到AbstractApplicationContext#refresh()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //为容器初始化做准备，重要程度：0 // Prepare this context for refreshing. prepareRefresh(); /* 重要程度：5 1、创建BeanFactory对象 * 2、xml解析 * 传统标签解析：bean、import等 * 自定义标签解析 如：&lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&gt; * 自定义标签解析流程： * a、根据当前解析标签的头信息找到对应的namespaceUri * b、加载spring所有jar中的spring.handlers文件。并建立映射关系 * c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类 * d、调用类的init方法，init方法是注册了各种自定义标签的解析类 * e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析 * * 3、把解析出来的xml标签封装成BeanDefinition对象 * */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); /* * 给beanFactory设置一些属性值，可以不看 * */ // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); /* * BeanDefinitionRegistryPostProcessor * BeanFactoryPostProcessor * 完成对这两个接口的调用 * */ // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); /* * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中 * */ // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); /* * 国际化,重要程度2 * */ // Initialize message source for this context. initMessageSource(); //初始化事件管理类 // Initialize event multicaster for this context. initApplicationEventMulticaster(); //这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的 // Initialize other special beans in specific context subclasses. onRefresh(); /* * 往事件管理类中注册事件类 * */ // Check for listener beans and register them. registerListeners(); /* * 这个方法是spring中最重要的方法，没有之一 * 所以这个方法一定要理解要具体看 * 1、bean实例化过程 * 2、ioc * 3、注解支持 * 4、BeanPostProcessor的执行 * 5、Aop的入口 * */ // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; registerBeanPostProcessors(beanFactory)该方法也是一个很重要的方法，这里会把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中，而BeanPostProcessor的就是spring提供的扩展点接口。 registerBeanPostProcessors(beanFactory)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); //提前实例化BeanPostProcessor类型的bean，然后bean进行排序 for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; //getBean是实例化方法，后面我们在讲bean实例化过程是会着重讲到 BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); //判断类型是否是MergedBeanDefinitionPostProcessor，如果是则代码是内部使用的 if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, register the BeanPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); //注册到BeanFactory中 registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(orderedPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. sortPostProcessors(internalPostProcessors, beanFactory); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125; 看String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); 该方法上节讲过了，就是在beanDefinition注册器(BeanFactory)中获取了实现了BeanPostProcessor接口的类的beanName。 还记得名字是这两个的BeanDefinition吗？ org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor 这两个对应的BeanDefinition是RootBeanDefinition，是在扫描的最后一步，也就是扫描完类而且创建好了BeanDefinition和BeanDefinition已经注册完成后，Spring会把名字是这两个的RootBeanDefinition注册到注册器中，而且RootBeanDefinition里面对应的class对象是CommonAnnotationBeanPostProcessor.class和AutowiredAnnotationBeanPostProcessor.class 看下这两个类的类图: CommonAnnotationBeanPostProcessor: AutowiredAnnotationBeanPostProcessor: 好了代码继续走 这段代码会对实现了BeanPostProcessor的类实例化并进行分类 把实现了PriorityOrdered的分类一类 把实现了Ordered的分类一类 把除上边两种情况外的分为一类 然后会进行排序，排序规则和上一节的BeanDefinitionRegistryPostProcess的排序规则一样，在上边的分类下，对order进行升序排序。 接着执行： 1registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); 12345678910111213public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123; Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;); this.beanPostProcessors.remove(beanPostProcessor); if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123; this.hasInstantiationAwareBeanPostProcessors = true; &#125; if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123; this.hasDestructionAwareBeanPostProcessors = true; &#125; this.beanPostProcessors.add(beanPostProcessor);&#125; 就是把创建的BeanPostProcessor对象放入到下面这个集合中。 1private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList(); 下面的代码也是同样的逻辑。 registerBeanPostProcessors(beanFactory);该方法的作用就是把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中，没别的了。 BeanPostProcessor的简单介绍看下BeanPostProcessor接口的定义 接口看上去很简单，但该接口有很多子接口，在子接口中一般情况下是会定义一些default方法，这些default方法是交给实现类来重写的。而通过定义不同的default方法和实现类实现不同的default方法这种方式，来提供丰厚的扩展点。 比如： [BeanPostProcessor 接口理解](.&#x2F;BeanPostProcessor 接口理解) Spring中重要的接口 initApplicationEventMulticaster();——事件处理器SimpleApplicationEventMulticaster的创建源码： 123456789101112131415protected void initApplicationEventMulticaster() &#123; ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123; this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class); //打印日志 ...... &#125; else &#123; this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory); beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster); //打印日志 ...... &#125;&#125; 该方法会创建一个SimpleApplicationEventMulticaster对象，并把对象注册到了Spring容器的singletonObjects中（singletonObjects可以叫一级缓存或单例池）。而SimpleApplicationEventMulticaster是Spring的默认事件管理器。 详情看[Spring Event事件通知机制](.&#x2F;Spring Event事件通知机制) onRefresh();该方法在Spring中没用，是一个空方法，但在Spring boot中有用。 在spring boot中，这个方法是用来做内嵌Servlet容器（默认是tomcat）的启动的 registerListeners()——事件监听器注册源码: 1234567891011121314151617181920212223protected void registerListeners() &#123; // Register statically specified listeners first. for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // 触发一些应用早期事件 // Publish early application events now that we finally have a multicaster... Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125;&#125; 这个方法是添加一些ApplicationListener和触发一些early application events。 对于Spring 的事件通知可以看[Spring Event事件通知机制](.&#x2F;Spring Event事件通知机制) 对于 123for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; getApplicationEventMulticaster().addApplicationListener(listener);&#125; 可以通过下面的方式来添加ApplicationListener 对于 12345String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);&#125; 这里只是添加了实现了ApplicationListener接口的beanName，这里会在multicastEvent方法中，触发通过beanName，从Spring容器中获取对象的方法。也就是getBean。 而注册的事件是怎么触发的？可以通过下面的代码触发。 12ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);applicationContext.publishEvent(new EnjoyEvent(&quot;Jack&quot;,&quot;enjoyEvent&quot;)); Spring的事件通知涉及到观察者设计模式。 比如： 可以看下publishEvent源码: 可以看到，逻辑就是遍历全部的ApplicationListener，最后执行invokeListener(listener, event)方法。 看下invokeListener(listener, event)方法 Spring也会发布事件，有这5种标准事件： 比如第一事件ContextRefreshedEvent，在refresh()方法的最后的finishRefresh就有发布这个事件。 所以如果我们自己写一个订阅该事件的类，比如： 也就可以在容器初始化完时做一些操作。 第二个事件ContextStartedEvent 第三个事件ContextStoppedEvent","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机","slug":"spring/5.2.8/02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机","date":"2021-11-20T12:00:08.000Z","updated":"2022-03-14T09:04:25.033Z","comments":true,"path":"blog/spring/5.2.8/02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/02-Spinrg%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8-BeanDefinitionRegistryPostProcessor%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/","excerpt":"","text":"Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机以ClassPathXmlApplicationContext为ApplicationContext 1234567891011121314151617181920212223242526272829303132333435363738394041public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //x去掉了一些和这节无关的代码 ..... /* * 重要程度：5 * 1、创建BeanFactory对象 * 2、xml解析 * 传统标签解析：bean、import等 * 自定义标签解析 如：&lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&gt; * 自定义标签解析流程： * a、根据当前解析标签的头信息找到对应的namespaceUri * b、加载spring所有jar中的spring.handlers文件。并建立映射关系 * c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类 * d、调用类的init方法，init方法是注册了各种自定义标签的解析类 * e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析 * * 3、把解析出来的xml标签封装成BeanDefinition对象 * */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); /* * 给beanFactory设置一些属性值，可以不看 * */ // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); /* * BeanDefinitionRegistryPostProcessor * BeanFactoryPostProcessor * 完成对这两个接口的调用 * */ // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); &#125;&#125; 上一节讲了在XML配置下的BeanDefinition初始化和注册 1ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 这一节看 1invokeBeanFactoryPostProcessors(beanFactory); invokeBeanFactoryPostProcessors从方法的翻译—-调用Bean Factory后处理器看，它是做一些后置处理的。 1234protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); ....&#125; 这里的getBeanFactoryPostProcessors会返回一个List&lt;BeanFactoryPostProcessor&gt;，这个集合是通过ApplicationContext的addBeanFactoryPostProcessor方法来添加值的 看invokeBeanFactoryPostProcessors： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123; // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); // beanFactory是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口 if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); // 默认情况下beanFactoryPostProcessors会为空，可以通过addBeanFactoryPostProcessor方法来添加自己的BeanFactoryPostProcessor for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; registryProcessor.postProcessBeanDefinitionRegistry(registry); registryProcessors.add(registryProcessor); &#125; else &#123; regularPostProcessors.add(postProcessor); &#125; &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); //获取实现了BeanDefinitionRegistryPostProcessor接口的所有类的BeanDefinition对象的beanName // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; //排序 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); //调用过程 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; //判断是否是实现的Ordered接口 if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); //没实现排序接口的调用 // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); currentRegistryProcessors.clear(); &#125; //调用postProcessBeanFactory方法 // Now, invoke the postProcessBeanFactory callback of all processors handled so far. invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; //实现了PriorityOrdered接口的 else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; //实现了Ordered接口的 else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; //没实现接口的 nonOrderedPostProcessorNames.add(ppName); &#125; &#125; //排序 // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. sortPostProcessors(priorityOrderedPostProcessors, beanFactory); //调用 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... beanFactory.clearMetadataCache();&#125; 代码很长，不过跟着代码一步步走，beanFactory的实例类型是DefaultListableBeanFactory，而该类是实现了BeanDefinitionRegistry接口的，所以会进入第一个if。跟着代码一步步走，先看这段代码块 12String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 这代码的意思就是在之前注册的beanDefinition中，找到有实现了BeanDefinitionRegistryPostProcessor接口的beanDefinition，最后返回这些beanDefinition的beanName，看上图可以看到有名字返回。 请注意最后一个org.springframework.context.annotation.internalConfigurationAnnotationProcessor这个对应的beanDefinition就是在扫描注解创建完beanDefinition并注册后，Spring自己加进来的RootBeanDefinition，该BeanDefinition指代的类为ConfigurationClassPostProcessor.class&#96;这里只是回忆下，现在还没涉及到这个class对象。 下面先介绍下BeanDefinitionRegistryPostProcessor接口的作用。 BeanDefinitionRegistryPostProcessor的作用。 先看下定义： 从接口BeanDefinitionRegistryPostProcessor定义的抽象方法可以看到，带着注册中心，也就是说，这个接口的实现类完全可以获取到之前创建并注册完成的BeanDefinition！那我们可以做一些扩展，比如自己再注册个BeanDefinition或者修改下BeanDefinition也可以去实现扫描我们自定义的注解！也就是要增删改查BeanDefinition时可以实现这个接口！ 而BeanFactoryPostProcessor的定义方法是需要传BeanFactory的，所以该方法更加适合做修改应用上下文，但由于该方法的入参会是DefaultListableBeanFactory，该类也实现了BeanDefinitionRegistry，所以这也能对BeanDefinition做增删改 使用场景： 实现自己的自定义注解，并且注入到Spring容器中 这里定义了两个抽象方法，不过这两个方法的调用时机是不同的。从方法名可以了解一些信息 postProcessBeanDefinitionRegistry的重点是对BeanDefinition的处理 postProcessBeanFactory的重点是对BeanFactory对象属性的修改 参考类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Componentpublic class BeanPro implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, Ordered &#123; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; //查询BeanDefinition final String[] beanDefinitionNames = registry.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(beanDefinitionName); System.out.println(beanDefinition); &#125; GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition(); genericBeanDefinition.setBeanClass(BeanDefinitionBean.class); MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues(); propertyValues.add(&quot;name&quot;,&quot;Jack&quot;); registry.registerBeanDefinition(&quot;beanDefinitionBean&quot;,genericBeanDefinition); //也可以做自定义注解扫描// ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);// //需要过滤的注解// scanner.addIncludeFilter(new AnnotationTypeFilter(MyService.class));// scanner.scan(&quot;com.enjoy.jack.customBean&quot;); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; String[] beanDefinitionNames = registry.getBeanDefinitionNames(); DefaultListableBeanFactory beanFactory1 = (DefaultListableBeanFactory)beanFactory; beanFactory1.setAllowBeanDefinitionOverriding(true); beanFactory1.setAllowCircularReferences(true); beanFactory1.setAllowRawInjectionDespiteWrapping(true); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125;@Datapublic class BeanDefinitionBean &#123; private String name = &quot;test&quot;;&#125; 回到invokeBeanFactoryPostProcessors 12String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); 已经讲了，看for，for里面就是是判断下是否实现了PriorityOrdered这个排序接口，先看下我关注的类ConfigurationClassPostProcessor，看下该类的类图： 他有实现PriorityOrdered接口，所以会进入到方法 1beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class) beanFactory的对象是DefaultListableBeanFactory，这个getBean方法会触发Spring Bean的初始化，作用就是是实例化ConfigurationClassPostProcessor对象，并完成控制反转（IOC）、依赖注入（DI）。更进一步说，就是实例化实现了BeanDefinitionRegistryPostProcessor接口和PriorityOrdered接口的类。 接着把实例化的对象放入到 1List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); 这个集合中。最后把beanName放入 1Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); 这个集合中。代码再往下走。 根据PriorityOrdered接口对currentRegistryProcessors集合排下序，接着把currentRegistryProcessors放到了这个集合中 1List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); 接着就是重点方法了， 1invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry); 这个方法就是去对调用刚刚创建的实现了BeanDefinitionRegistryPostProcessor接口的对象的postProcessBeanDefinitionRegistry方法，这里只调用了一个方法，还有另一个方法postProcessBeanFactory会在之后被调用。 上面讲的是实现了BeanDefinitionRegistryPostProcessor接口和PriorityOrdered接口的，没实现的呢？继续看代码： 还是同样的味道，同样的套路。。。。。。。代码继续走 之前的都是调用了BeanDefinitionRegistryPostProcessor的postProcessBeanBefinitionRegistry方法，那最后就是调用BeanDefinitionRegistryPostProcessor的postProcessBeanFactory方法了。都是和上边同样的流程， 不过这里需要注意，最后的集合regularPostProcessors在默认的情况下是没有的，因为它需要手动调用ApplicationContext.addBeanFactoryPostProcessor方法才会有。 代码继续走，这次是获取实现了BeanFactoryPostProcessor接口的类了 之后的逻辑和排序都和上边的一样。 总结这个方法方法很重要，甚至比前面第一节中，BeanFactory的创建还重要。因为在第一节中的讲的BeanDefinition的创建和注册是在obtainFreshBeanFactory完成的，这只是针对基于xml文件的，但现在随着注解的形式已经成为了主流，而基于注解的BeanDefinition的创建和注册不是在obtainFreshBeanFactory完成的，而是在这个方法中调用了ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry完成了BeanDefinition的创建和注册的。所以这个方法是一个非常非常重要的方法！！ 看下默认排序的OrderComparator： 下面对这个方法中的BeanDefinitionRegistyPostProcess的调用顺序进行总结： PriorityOrdered &gt; Ordered &gt; 非PriorityOrdered非Ordered order越小越先被执行 还有一个AnnotationAwareOrderComparator.INSTANCE，这个排序是OrderComparator的子类，它支持@Priority、和@Order注解，排序规则还是和上边一样。 流程图","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"01-Spring中BeanDefinition的创建和注册","slug":"spring/5.2.8/01-Spring中BeanDefinition的创建和注册","date":"2021-11-20T12:00:07.000Z","updated":"2022-03-14T09:04:24.972Z","comments":true,"path":"blog/spring/5.2.8/01-Spring中BeanDefinition的创建和注册/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/01-Spring%E4%B8%ADBeanDefinition%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C/","excerpt":"","text":"01Spring中BeanDefinition的创建和注册以ClassPathXmlApplicationContext为ApplicationContext 1234方法重要程度： 0：不重要，可以不看 1：一般重要，可看可不看 5：非常重要，一定要看 必须读的 ：重要程度 5 12345678910public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125;&#125; refresh()方法是重要方法，ClassPathXmlApplicationContext没有重写该方法所以用的是从父类AbstractApplicationContext继承过来的refresh()， 该方法是spring容器启动的核心方法，该类是一个典型的父类模板设计模式的运用，提供一个钩子方法，通过继承，子类实现对应的钩子方法来完成不同的功能。 根据不同的上下文对象，会调用不同的上下文对象子类方法中 核心上下文子类有： ClassPathXmlApplicationContext FileSystemXmlApplicationContext AnnotationConfigApplicationContext AnnotationConfigWebApplicationContext EmbeddedWebApplicationContext(springboot) …. 这里关注的重点只有两个ClassPathXmlApplicationContext和AnnotationConfigApplicationContext。先看第一ClassPathXmlApplicationContext。ClassPathXmlApplicationContext的类图： 看回refresh()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; //为容器初始化做准备，重要程度：0 // Prepare this context for refreshing. prepareRefresh(); /* * 重要程度：5 * */ // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); /* * 给beanFactory设置一些属性值，可以不看 * */ // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); /* * BeanDefinitionRegistryPostProcessor * BeanFactoryPostProcessor * 完成对这两个接口的调用 * */ // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); /* * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中 * */ // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); /* * 国际化,重要程度2 * */ // Initialize message source for this context. initMessageSource(); //初始化事件管理类 // Initialize event multicaster for this context. initApplicationEventMulticaster(); //这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的 // Initialize other special beans in specific context subclasses. onRefresh(); /* * 往事件管理类中注册事件类 * */ // Check for listener beans and register them. registerListeners(); /* * 这个方法是spring中最重要的方法，没有之一 * 所以这个方法一定要理解要具体看 * 1、bean实例化过程 * 2、ioc * 3、注解支持 * 4、BeanPostProcessor的执行 * 5、Aop的入口 * */ // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 首先refresh()方法是AbstractApplicationContext的核心，从上面源码看到，该方法里面定义的Spring整个初始化阶段的操作。而且提供一些钩子方法，让不同的类去重写钩子方法，实现不同的功能。该方法是线程安全的，不过该方法也就掉用哥一次，没谁调用多次 吧。 这一节看 1ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); 对于ClassPathXmlApplicationContext这个方法的作用： 创建BeanFactory对象 xml解析 传统标签解析：bean、import等自定义标签解析 如：&lt;context:component-scan base-package&#x3D;”com.xiangxue.jack”&#x2F;&gt;自定义标签解析流程： a、根据当前解析标签的头信息找到对应的namespaceUri b、加载spring所有jar中的spring.handlers文件。并建立映射关系 c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类 d、调用类的init方法，init方法是注册了各种自定义标签的解析类 e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析 把解析出来的xml标签封装成BeanDefinition对象 开始看源码，该方法是在AbstractApplicationContext中的， 12345protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; //核心方法，必须读，重要程度：5 refreshBeanFactory(); return getBeanFactory();&#125; refreshBeanFactory()方法是一个抽象的钩子方法，它的实现是交由子类来完成的， AbstractRefreshableApplicationContext#refreshBeanFactory： 12345678910111213141516171819202122232425protected final void refreshBeanFactory() throws BeansException &#123; //如果BeanFactory不为空，则清除BeanFactory和里面的实例 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; //BeanFactory 实例工厂 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); //设置是否可以循环依赖 allowCircularReferences //是否允许使用相同名称重新注册不同的bean实现. customizeBeanFactory(beanFactory); //解析xml，并把xml中的标签封装成BeanDefinition对象 loadBeanDefinitions(beanFactory); this.beanFactory = beanFactory; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex); &#125;&#125;protected DefaultListableBeanFactory createBeanFactory() &#123; return new DefaultListableBeanFactory(getInternalParentBeanFactory());&#125; DefaultListableBeanFactory beanFactory = createBeanFactory();返回的是DefaultListableBeanFactory customizeBeanFactory(beanFactory);这里面主要设置两个参数： 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; //设置允许Bean定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; //设置是否可以循环依赖 if (this.allowCircularReferences != null) &#123; beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; 重点看loadBeanDefinitions(beanFactory)，该方法又是钩子方法，它由AbstractXmlApplicationContext实现： 123456789101112131415161718protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. //创建xml的解析器，这里是一个委托模式 XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&#x27;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); //这里传一个this进去，因为ApplicationContext是实现了ResourceLoader接口的 beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. initBeanDefinitionReader(beanDefinitionReader); //主要看这个方法 重要程度 5 loadBeanDefinitions(beanDefinitionReader);&#125; XmlBeanDefinitionReader是xml的解析器，DefaultListableBeanFactory不完成XML解析的工作，该工作委托给了XmlBeanDefinitionReader来完成，看下类图： XmlBeanDefinitionReader上面的代码的重点方法是AbstractXmlApplicationContext.loadBeanDefinitions(beanDefinitionReader)： 1234567891011protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; //获取需要加载的xml配置文件 String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; configLocations就是一个资源数组，里面保存的就是指定解析的xml配置文件： 经过调用 12XmlBeanDefinitionReader.loadBeanDefinitions(configLocations) ---&gt;AbstractBeanDefinitionReader.loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) AbstractBeanDefinitionReader.loadBeanDefinitions： 1234567891011121314151617181920212223242526272829303132public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; ......//不重要代码 &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; //把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流 //的方式加载配置文件，然后封装成Resource对象，不重要，可以不看 Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); //主要看这个方法 ** 重要程度 5 int count = loadBeanDefinitions(resources); if (actualResources != null) &#123; Collections.addAll(actualResources, resources); &#125; //不重要代码 ...... return count; &#125; catch (IOException ex) &#123; //不重要代码 ...... &#125; &#125; else &#123; //不重要代码 ...... return count; &#125;&#125; 参数location我们已经知道了，是一个字符串，而且是xml文件名字活匹配串，该方法中调用了 1Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); 该方法的实际作用就是通过流的方法去获取到xml文件，并且封装成一个Resource对象。而之所以是数组，是应为 可能会是这样的匹配串： 1classpath*:user/**/*-context.xml 好了，到重点方法int count &#x3D; loadBeanDefinitions(resources);了 12345678910@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123; Assert.notNull(resources, &quot;Resource array must not be null&quot;); int count = 0; for (Resource resource : resources) &#123; //模板设计模式，调用到子类中的方法 count += loadBeanDefinitions(resource); &#125; return count;&#125; loadBeanDefinitions又是钩子方法，它的实现由子类XmlBeanDefinitionReader完成 12345@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; //EncodedResource带编码的对Resource对象的封装 return loadBeanDefinitions(new EncodedResource(resource));&#125; loadBeanDefinitions(EncodedResource encodedResource): 12345678910111213141516171819202122232425262728293031323334public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;); if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;); &#125; //获取Resource对象中的xml文件流对象 try (InputStream inputStream = encodedResource.getResource().getInputStream()) &#123; //InputSource是jdk中的sax xml文件解析对象 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; //主要看这个方法 ** 重要程度 5 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; catch (IOException ex) &#123; ........ &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 这里就是开始加载xml文件，为xml文件生成一个InputStream。 重点是doLoadBeanDefinitions(inputSource, encodedResource.getResource());方法 1234567891011121314151617181920212223protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; //把inputSource 封装成Document文件对象，这是jdk的API Document doc = doLoadDocument(inputSource, resource); //主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition int count = registerBeanDefinitions(doc, resource); //....log return count; &#125; ..........&#125;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; //又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析 BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); //主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; 上面兜兜转转，XmlBeanDefinitionReader其实就一个目的，读取xml的内容，并封装成一个Document对象，在 doLoadDocument(inputSource, resource)里完成这一过程。那有了xml文件的信息了，接下来就是去解析xml信息并封装成对象了，从单一职责原则看，XmlBeanDefinitionReader的职责已经完成了，所以它创建了BeanDefinitionDocumentReader类，将解析工作交给它。 BeanDefinitionDocumentReader该接口的实现类为DefaultBeanDefinitionDocumentReader，registerBeanDefinitions就是该类的核心方法 12345public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; //主要看这个方法，把root节点传进去 doRegisterBeanDefinitions(doc.getDocumentElement());&#125; doc.getDocumentElement()，用来获取XMl的root节点，也就是spring配置文件的beans元素。 1234567891011protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); ........ preProcessXml(root); //主要看这个方法，标签具体解析过程 parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; 注意，这里又是一个委托，看createDelegate，这个方法返回了BeanDefinitionParserDelegate，从名字上看该类是真正将xml的信息封装成BeanDefinition的。往下看， 有两个空方法preProcessXml和postProcessXml，这两个在默认的实现类中什么都不做，这是为了扩展才提供了，看重点方法parseBeanDefinitions(root, this.delegate); 12345678910111213141516171819202122protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //默认标签解析 parseDefaultElement(ele, delegate); &#125; else &#123; //自定义标签解析 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 该方法就是遍历beans里面的元素。而这里又分为默认标签解析和自定义标签解析 默认标签解析传统标签解析：bean、beans、import和alias parseDefaultElement(ele, delegate)，解析默认标签解析： 12345678910111213141516171819private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //import标签解析 重要程度 1 ，可看可不看 if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; //alias标签解析 别名标签 重要程度 1 ，可看可不看 else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; //bean标签，重要程度 5，必须看 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; // 这里是解析beans，其实可以看作是遍历bean而已 else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 我们值看bean标签的解析，processBeanDefinition： 123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; //重点看这个方法，重要程度 5 ，解析document，封装成BeanDefinition BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; //该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; //完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册 // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; ......... &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 现在已经有xml的bean标签的对应的对象了，如果是我做的会解析该xml的bean标签的信息并把这些信息封装到一个对象中，而spring也是这样做的，spring会把信息封装成BeanDefinition 重点看BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);，这个方法就是去解析document，封装成BeanDefinition的，跟踪代码到BeanDefinitionParserDelegate.parseBeanDefinitionElement： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Nullablepublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; ........ &#125; //检查beanName是否重复 if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; //&lt;bean&gt;标签解析的核心方法，重要程度5 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot; + &quot;using generated bean name [&quot; + beanName + &quot;]&quot;); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 首先获取id和name（也就是bean的别名），别名逗号切割，放入List&lt;String&gt; aliases中 而id会赋值给beanName引用，这也是bean的名字，而name会作为bean的别名，一直到 1AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); 该方法是&lt;bean&gt;标签解析的核心方法，会创建一个BeanDefinition对象，这个BeanDefinition的类型为GenericBeanDefinition parseBeanDefinitionElement： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; try &#123; //创建GenericBeanDefinition对象 AbstractBeanDefinition bd = createBeanDefinition(className, parent); //解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //解析bean中的meta标签 parseMetaElements(ele, bd); //解析bean中的lookup-method标签 重要程度：2，可看可不看 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //解析bean中的replaced-method标签 重要程度：2，可看可不看 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析bean中的constructor-arg标签 重要程度：2，可看可不看 parseConstructorArgElements(ele, bd); //解析bean中的property标签 重要程度：2，可看可不看 parsePropertyElements(ele, bd); //可以不看，用不到 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; ...... finally &#123; this.parseState.pop(); &#125; return null; &#125;//createBeanDefinition(className, parent) protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName) throws ClassNotFoundException &#123; return BeanDefinitionReaderUtils.createBeanDefinition( parentName, className, this.readerContext.getBeanClassLoader()); &#125;//BeanDefinitionReaderUtils.createBeanDefinition(// parentName, className, this.readerContext.getBeanClassLoader()); public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd; &#125; 好了，终于看到GenericBeanDefinition bd = new GenericBeanDefinition()了 下图是GenericBeanDefinition的重要属性属性 好了，现在已经获取到了BeanDefinition，并把BeanDefinition在封装成了BeanDefinitionHolder了，那最后就是注册了吧，这步放到自定义标签（包扫描）上讲。 自定义标签自定义标签解析 如：&lt;context:component-scan base-package&#x3D;”com.xiangxue.jack”&#x2F;&gt;自定义标签解析流程： a、根据当前解析标签的头信息找到对应的namespaceUri b、加载spring所有jar中的spring.handlers文件。并建立映射关系 c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类 d、调用NamespaceHandler类的init方法，init方法是注册了各种自定义标签的解析类 e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析 回到DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)， 12345678910111213141516171819202122protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; //默认标签解析 parseDefaultElement(ele, delegate); &#125; else &#123; //自定义标签解析 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 看delegate.parseCustomElement(ele)，该方法就是去解析自定义标签的。 可以看到自定义标签的解析是交给了BeanDefinitionParserDelegate完成，看 BeanDefinitionParserDelegate#parseCustomElement 123456789101112131415public BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;public BeanDefinition parseCustomElement(Element ele, @Nullable BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); if (namespaceUri == null) &#123; return null; &#125; NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; ....... &#125; return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 有个namespaceUri，这个就是这些值 看下方法 1NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); NamespaceHandlerResolver的默认实现是DefaultNamespaceHandlerResolver DefaultNamespaceHandlerResolver#resolve： 1234567891011121314151617181920212223242526272829public NamespaceHandler resolve(String namespaceUri) &#123; //获取spring中所有jar包里面的 &quot;META-INF/spring.handlers&quot;文件，并且建立映射关系 Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); //根据namespaceUri：http://www.springframework.org/schema/context，获取到这个命名空间的处理类 Object handlerOrClassName = handlerMappings.get(namespaceUri); ........ else &#123; String className = (String) handlerOrClassName; try &#123; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; ...... &#125; NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); //调用处理类的init方法，在init方法中完成标签元素解析类的注册 namespaceHandler.init(); //这里还做了缓存，第一次获取的是clasName，通过className来创建对象，第二次去获取的时候就能直接获取到对应的namespaceHandler对象了 handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125; catch (ClassNotFoundException ex) &#123; ...... &#125; catch (LinkageError err) &#123; ...... &#125; &#125;&#125; 方法：Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();该方法会去获所有的”META-INF&#x2F;spring.handlers”文件，并解析，然后建立映射关系(这让我想到java SPI和Dubbo SPI) 看下该方法的返回值： 好了这就是Spring的SPI了，和dubbo一样，都是使用key，value的方式 看下spring.handlers: 这些类都是继承了NamespaceHandlerSupport 方法registerBeanDefinitionParser的定义 可以看到registerBeanDefinitionParser其实就是把BeanDefinitionParser放入到了一个parsers的Map中。这些解析类是什么时候调用的呢？往下看。 上面已经获取了得到了对应关系&lt;自定义标签名,NamespaceHandler&gt;，接着执行了方法： 1Object handlerOrClassName = handlerMappings.get(namespaceUri); 就可以根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类，一开始时，返回值是类的全限定名，这时就需要创建并缓存了。 接着就会创建该NamespaceHandler对象并执行到了NamespaceHandler的init方法 123456789101112try &#123; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; ...... &#125; NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); //调用处理类的init方法，在init方法中完成标签元素解析类的注册 namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler;&#125; 从上边的介绍可知init方法是注册了各种自定义标签的解析类，把这些标签的解析类入了一个Map中。 好了，现在已经获取了自定义标签的NamespaceHandler，而且已经把对应的解析类都注册了，也就是说，比如xml文件这样写了 12345&lt;!--自定义标签--&gt;&lt;context:component-scan base-package=&quot;com.enjoy.jack&quot;&gt;&lt;/context:component-scan&gt;&lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt; 经过上面的步骤，我通过context，得到了uri，也就是这个 然后根据URI，并使用了SPI获取到了这个URI对应的NamespaceHandlerSupport，也就是ContextNamespaceHandler，而ContextNamespaceHandler的定义也很简单，就是重写了init方法， 接着就创建ContextNamespaceHandler对象并调用了这个init方法，把component-scan、property-placeholder等这些对应的BeanDefinitionParser做了一个对应关系，并放入了一个Map中。 最后就只剩下解析了，回到BeanDefinitionParserDelegate#parseCustomElement方法。该方法最后执行了 1handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); handler就是之前获取的ContextNamespaceHandler，也就是ContextNamespaceHandler。上面介绍了ContextNamespaceHandler的定义，他是没有重写parse方法的，所以这方法是从父类NamespaceHandlerSupport中继承过来的 看NamespaceHandlerSupport#parse 也就是根据标签获取对应的BeanDefinitionParser，接着执行了parse方法。 我们最关注的肯定是扫描标签: 所以根据上面的介绍可知component-scan对应的解析类是ComponentScanBeanDefinitionParser ComponentScanBeanDefinitionParser#parse 1234567891011121314151617public BeanDefinition parse(Element element, ParserContext parserContext) &#123; //获取basePackage属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); //可以用逗号分开 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); //创建注解扫描器 // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); //扫描并把扫描的类封装成beanDefinition对象 核心方法，重要程度 5 Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null;&#125; 先获取basePackage属性，就是包路径，然后调用configureScanner，创建注解扫描器ClassPathBeanDefinitionScanner。 包扫描——ClassPathBeanDefinitionScanner看下该类的类图： 该类会去扫描有这些注解的类： @Component @Service @Repository @Configuration 看下ClassPathBeanDefinitionScanner的创建，useDefaultFilters默认就是true，不信自己看源码吧 123456789101112public ClassPathBeanDefinitionScanner(BeanDefinitionRegistry registry, boolean useDefaultFilters, Environment environment, @Nullable ResourceLoader resourceLoader) &#123; Assert.notNull(registry, &quot;BeanDefinitionRegistry must not be null&quot;); this.registry = registry; if (useDefaultFilters) &#123; registerDefaultFilters(); &#125; setEnvironment(environment); setResourceLoader(resourceLoader);&#125; useDefaultFilters默认情况下为true，重点看下registerDefaultFilters： 123456protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); //不重要的方法 .........&#125; 逻辑很简单，就是把需要扫描的注解的class对象封装成AnnotationTypeFilter，然后放到了一个内部的集合includeFilters中 回到代码，这里就放了Component.class这个注解！和上面说的不同，那我们就看下其他注解的定义 其他3个注解都加了Component注解！也就是这些注解都能被识别 回到 ComponentScanBeanDefinitionParser.parse(Element element, ParserContext parserContext)方法 123456//创建注解扫描器// Actually scan for bean definitions and register them.ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);//扫描并把扫描的类封装成beanDefinition对象 核心方法，重要程度 5Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);registerComponents(parserContext.getReaderContext(), beanDefinitions, element); 创建完了ClassPathBeanDefinitionScanner后就执行了doScan，方法，看下该方法： 1234567891011protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;(); for (String basePackage : basePackages) &#123; //扫描到有注解的类并封装成BeanDefinition对象 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); ..... //还有其他代码，放在后面讲 &#125; return beanDefinitions;&#125; 重点看findCandidateComponents，该方法会扫描到有Component注解的类并封装成BeanDefinition对象 好，看scanCandidateComponents方法 先创建了一个Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;(); 作用猜都猜到了，就是放包含注解的BeanDefintition的，看下resources有什么。 可以看到，resources就是指向一个类文件的对象。接着就是去遍历这些文件，并检查是否有Component注解。 看for循环的代码主要代码。 1234567891011121314151617MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);//如果类上面有includeFilters注解if (isCandidateComponent(metadataReader)) &#123; ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setSource(resource); if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug(&quot;Identified candidate component class: &quot; + resource); &#125; candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug(&quot;Ignored because not a concrete top-level class: &quot; + resource); &#125; &#125;&#125; 代码很好理解，就是把类的的信息封装成MetadataReader对象，然后检查是否有对应的注解，有就创建一个ScannedGenericBeanDefinition对象。 这里先重点说下这段代码 1MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource); getMetadataReaderFactory()返回的是CachingMetadataReaderFactory 接着getMetadataReader方法，这里 里面的源码不说，不过这里有个疑问，spring会不会去触发类的加载，如果有触发，那传个ClassLoader进去是可以理解的，因为一个类的最终确定，是要类加载器和类的全限定名来确定的，而如果有触发，那就会把类的静态存储结构转化为方法区的运行时数据结构，也就是说会占用内存，如果有大量的类是不使用的，那就浪费资源了。 我稍微看了这个getMetadataReader，没细看，而且之前生产BeanDefinition的时候是没触发类的加载的。所以猜测是用了和javap类似的技术，去解析类的静态存储结构里的数据。 回到遍历的代码，现在看下MetadataReader对象的数据 回到代码， isCandidateComponent(metadataReader)这个方法匹配会匹配是否有对应的注解，有就会去创建ScannedGenericBeanDefinition 看下ScannedGenericBeanDefinition的类图: 它是继承了GenericBeanDefinition，里面就多了个AnnotationMetadata属性，也就是保存了注解的属性 注意在这一步只是传入AnnotationMetadata属性后就放入之前创建的集合中了，类中注解里面的属性值和其他注解信息还没设置。 回到ClassPathBeanDefinitionScanner#doScan方法 12345678910111213141516171819202122232425protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; //省略了部分代码 ..... //扫描到有注解的类并封装成BeanDefinition对象 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; //bean的范围 ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; // 用注解的信息来完善BeanDefinition if (candidate instanceof AnnotatedBeanDefinition) &#123; //支持了@Lazy @DependOn注解 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; //省略的部分代码 .... 代码1 &#125; //省略了部分代码 .....&#125; 可以看到，之前讲bean标签的时候没说，String中bean的范围默认是singleton也就是单例。 上面的代码就是解析注解，然后对BeanDefinition的属性数据填充，bean的范围啊、是否懒加载。具体看BeanDefinition的信息图 好了，BeanDefinition的初始化就完成了，现在还差个注册。 beanDefinition注册到BeanFactory对象中 这里的BeanFactory真实类型就是一开始创建测DefaultListableBeanFactory，而该类又实现了BeanDefinitionRegistry接口，所以这里涉及到的BeanDefinitionRegistry的对应引用都是DefaultListableBeanFactory类型的对象 默认标签的BeanDefinition和自定义标签的BeanDefinition在创建完后都要注册器BeanFactory中。 这里以自定义标签的BeanDefinition的注册来讲。 代码接着上面doScan代码 最后检查BeanDefinition是否已经已经注册了，没有就去注册。执行代码1(是在doScan的for循环里面的) 12345678// 检查是否已经注册过了if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); //BeanDefinition注册 registerBeanDefinition(definitionHolder, this.registry);&#125; 又是包装，这里会把把BeanDefinition，包装成了一个BeanDefinitionHolder，然后执行了 registerBeanDefinition(definitionHolder, this.registry); 这个BeanDefinitionRegistry的实现是DefaultListableBeanFactory！终于看到BeanFactory了！ DefaultListableBeanFactory实现了BeanDefinitionRegistry这个接口，看名字就知道作用是什么了。 看DefaultListableBeanFactory#registerBeanDefinition方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; //省略校验代码 ..... //先判断BeanDefinition是否已经注册 BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); if (existingDefinition != null) &#123; //是否允许覆盖 if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); &#125; //只是打印信息而已 ..... this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; removeManualSingletonName(beanName); &#125; &#125; else &#123; //把beanDefinition缓存到map中 // Still in startup registration phase this.beanDefinitionMap.put(beanName, beanDefinition); //把beanName放到beanDefinitionNames list中，这个list着重记住，bean实例化的时候需要用到 this.beanDefinitionNames.add(beanName); removeManualSingletonName(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; if (existingDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125; else if (isConfigurationFrozen()) &#123; clearByTypeCache(); &#125;&#125; 注册实际上就是放入DefaultListableBeanFactory中的beanDefinitionMap中，并且把beanDefinition对应的名字放入DefaultListableBeanFactory的beanDefinitionNames的集合中。而这个beanName，默认规则是类的名字，头字母小写。 这里涉及到两个集合beanDefinitionMap和beanDefinitionNames，看下这两个属性的定义 好了，现在BeanDefinition已经注册到beanFactory中了，看下之后的代码 别名也去注册了，不过别名是和beanName做映射的。(这让我想起了Innodb中聚集索引和非聚集索引的关系) 也就是说，通过别名找bean，实际上是找到了bean的beanName，然后才找到bean的 现在已经完成了BeanDefinition的注册了，回到调用的地方ComponentScanBeanDefinitionParser#parse 注册完BeanDefinition后，还执行了一行 1registerComponents(parserContext.getReaderContext(), beanDefinitions, element); 这代码的核心是在 由于这是扫描注解的，annotationConfig是为true的，所以会执行AnnotationConfigUtils#registerAnnotationConfigProcessors添加各种的PostProcessor，而重点的PostProcessor如下： 添加ConfigurationClassPostProcessor 添加AutowiredAnnotationBeanPostProcessor 添加CommonAnnotationBeanPostProcessor 上面的3处代码都会检查下刚刚注册的beanDefinition中有没有名字为下面的： org.springframework.context.annotation.internalConfigurationBeanNameGenerator org.springframework.context.annotation.internalAutowiredAnnotationProcessor org.springframework.context.annotation.internalCommonAnnotationProcessor 这些的BeanDefinition如果没有就创建对应的RootBeanDefinition 123RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); 然后把创建好的RootBeanDefinition作为后置处理器（BeanDefinitionRegistryPostProcessor）注册到注册器beanFactory中。 这三个类很重要，和之后的流程有关，这里就记下是在什么时候到把这些PostProcessor注册到beanFactory中的： CommonAnnotationBeanPostProcessor.class AutowiredAnnotationBeanPostProcessor.class ConfigurationClassPostProcessor.class 看下各个类的类图 xml解析和BeanDefinition封装核心方法 扫描的流程图","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00在SpringBoot项目中实现自己的WebMvcConfigurer需要注意的","slug":"spring/5.2.8/00在SpringBoot项目中实现自己的WebMvcConfigurer需要注意的","date":"2021-11-20T12:00:06.000Z","updated":"2022-03-14T09:04:24.764Z","comments":true,"path":"blog/spring/5.2.8/00在SpringBoot项目中实现自己的WebMvcConfigurer需要注意的/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/00%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84WebMvcConfigurer%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84/","excerpt":"","text":"我在一个Spring boot的项目中实现了自己的WebMvcConfigurer，并重写了自己的configureMessageConverters。如下 123456789101112131415161718public class WebConfig implements WebMvcConfigurer &#123; @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = converter.getFastJsonConfig(); config.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); config.setSerializerFeatures(SerializerFeature.PrettyFormat); converter.setDefaultCharset(UTF_8); List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;&gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); converter.setSupportedMediaTypes(supportedMediaTypes);// converters.add(new StringHttpMessageConverter()); converters.add(converter); &#125;&#125; 但返回结果中仍然把null都返回了，比如: 1234&#123; &quot;res&quot;: null, &quot;data&quot;: 1&#125; 也就是在对返回结果解析时使用的HttpMessageConverter并不是我定义的FastJsonHttpMessageConverter。结合SpringMVC的知识（只关注注解的），参数解析器和结果解析器中的用到的HttpMessageConverter是在RequestMappingHandlerAdapter创建的时候set进去的： 而configureMessageConverters是钩子方法，他的实现是在DelegatingWebMvcConfiguration中的，无论Spring还是Spring boot都是一样的。debug： 可以看到，这时已经有值了，也就是说在在执行WebConfig的configureMessageConverters之前，已经执行了某个WebMvcConfigurer的configureMessageConverters了，这就去看DelegatingWebMvcConfiguration的configureMessageConverters了： 可以看到，我定义的WebMvcConfigurer前面有个WebMvcAutoConfiguration，就是先执行了这个类的configureMessageConverters方法，添加了很多默认的HttpMessageConverter，而这个类中有这样一个注解： 是用来排序的，也就是说，如果想要我定义的在第一位，那只需要添加@Order(Ordered.HIGHEST_PRECEDENCE)上这个注解就好了 @Order的值可以是 &lt; Ordered.HIGHEST_PRECEDENCE+10 也可以修改自己的configureMessageConverters方法，最后代码改成这样converters.add(0, converter);修改后： 123456789101112131415@Overridepublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = converter.getFastJsonConfig(); config.setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); config.setSerializerFeatures(SerializerFeature.PrettyFormat); converter.setDefaultCharset(UTF_8); List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;&gt;(); supportedMediaTypes.add(MediaType.APPLICATION_JSON); supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); converter.setSupportedMediaTypes(supportedMediaTypes); converters.add(0, converter);&#125;","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-Spring中重要的接口","slug":"spring/5.2.8/00-Spring中重要的接口","date":"2021-11-20T12:00:05.000Z","updated":"2022-03-14T09:04:24.745Z","comments":true,"path":"blog/spring/5.2.8/00-Spring中重要的接口/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/00-Spring%E4%B8%AD%E9%87%8D%E8%A6%81%E7%9A%84%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"BeanPostProcessor BeanDefinitionRegistryPostProcessor解析看这里02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机 先看下定义： 从refresh，可以看到在执行invokeBeanFactoryPostProcessors方法的时候，这个时间短只是完成了BeanDefinition的创建和注册到BeanFactory中而已。而且从接口BeanDefinitionRegistryPostProcessor定义的抽象方法可以看到，它们都是带着注册中心的，也就是说，这个借口的实现类完全可以获取到之前创建并注册完成的BeanDefinition！那我们可以做一些扩展，比如自己再注册个BeanDefinition或者修改下BeanDefinition也可以去实现扫描我们自定义的注解！也就是要增删改查BeanDefinition时可以实现这个接口！ 这里定义了两个抽象方法，不过这两个方法的调用时机是不同的。从方法名可以了解一些信息 postProcessBeanDefinitionRegistry的重点是对BeanDefinition的处理 postProcessBeanFactory的重点是对BeanFactory对象属性的修改 参考类： 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class BeanPro implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, Ordered &#123; @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; //查询BeanDefinition final String[] beanDefinitionNames = registry.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; BeanDefinition beanDefinition = registry.getBeanDefinition(beanDefinitionName); System.out.println(beanDefinition); &#125; GenericBeanDefinition genericBeanDefinition = new GenericBeanDefinition(); genericBeanDefinition.setBeanClass(BeanDefinitionBean.class); MutablePropertyValues propertyValues = genericBeanDefinition.getPropertyValues(); propertyValues.add(&quot;name&quot;,&quot;Jack&quot;); registry.registerBeanDefinition(&quot;beanDefinitionBean&quot;,genericBeanDefinition);// ClassPathBeanDefinitionScanner scanner = new ClassPathBeanDefinitionScanner(registry);// //需要过滤的注解// scanner.addIncludeFilter(new AnnotationTypeFilter(MyService.class));// scanner.scan(&quot;com.enjoy.jack.customBean&quot;); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; String[] beanDefinitionNames = registry.getBeanDefinitionNames(); DefaultListableBeanFactory beanFactory1 = (DefaultListableBeanFactory)beanFactory; beanFactory1.setAllowBeanDefinitionOverriding(true); beanFactory1.setAllowCircularReferences(true); beanFactory1.setAllowRawInjectionDespiteWrapping(true); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; SmartInstantiationAwareBeanPostProcessor这个是看这里实例化带有@Autowired注解的构造函数 这个接口出了上边的作用还有 引用循环依赖的解决过程 MergedBeanDefinitionPostProcessor这个是看这里收集注解–applyMergedBeanDefinitionPostProcessors InstantiationAwareBeanPostProcessor这个看这里ioc di（控制反转），依赖注入的核心方法—-populateBean DestructionAwareBeanPostProcessor看registerDisposableBeanIfNecessary—bean销毁前需要做的操作类DisposableBeanAdapter AbstractAutowireCapableBeanFactory记住这个类，它定义基于注解的的bean的初始化阶段的整个流程。 BeanPostProcessor非常重要的一个接口，贯穿了Spring的bean的初始化流程和功能的扩展 看这这么多BeanPostProcessor了，都是在循环中的，而且都是对一个Bean循环的，可以看到，如果某个类对对应的方法感兴趣了，就在对应的方法了做一些对类的操作，不感兴趣了就直接返回就好了。而且，BeanPostProcessor这种使用方式感觉就是使用了装饰器模式，虽然没有装饰器模式的形，但有装饰器模式模式的魂—-给原始类添加增强功能 ApplicationListener12345678910@Component@Order(2)public class EnjoyApplicationListener1 implements ApplicationListener &#123; @Override public void onApplicationEvent(ApplicationEvent event) &#123; if(event instanceof EnjoyEvent) &#123; System.out.println(&quot;==EnjoyApplicationListener1&quot;); &#125; &#125;&#125; 或者使用注解 Spring Bean完成依赖注入后调用的接口按顺序（有部顺序是不对的）： BeanNameAware BeanClassLoaderAware BeanFactoryAware InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization—-处理@PostConstruct EnvironmentAware EmbeddedValueResolverAware ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware ApplicationContextAware ImportAware比如这样写了一个类 是触发不到这段代码的，需要这样写也就是说只有通过@Import()注解注入的类才能调用到ImportAware#setImportMetadata方法。这个原因就是在收集注解的BeanPostProcessor，也就是ConfigurationClassPostProcessor来完成收集，这个过程是发生在BeanDefinition创建阶段的。完成了Spring bean的依赖注入（DI)阶段后，也就是调用AbstractAutowireCapableBeanFactory#initializeBean中时，会调用ImportAwareBeanPostProcessor接口的postProcessBeforeInitialization方法来完成ImportAware接口的调用。 ServletContextAware，ServletConfigAware InitializingBean 调用init-method配置的方法 调用方法ApplicationListenerDetector#postProcessAfterInitialization把之前注册的事件–ApplicationListener注册到事件管理器中 DisposableBean，AutoCloseable在JVM关闭前，调用的方法。 Spring Bean初始化完成后调用的接口方法 SmartInitializingSingleton 在初始化入口方法DefaultListableBeanFactory#preInstantiateSingletons 执行完getBean后： ImportSelector、DeferredImportSelector和ImportBeanDefinitionRegistrar看07-Spring中基于注解–ConfigurationClassPostProcessor 都是引入类，交给Spring管理","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-Spring中的BeanDefinition","slug":"spring/5.2.8/00-Spring中的BeanDefinition","date":"2021-11-20T12:00:04.000Z","updated":"2022-03-14T09:04:24.669Z","comments":true,"path":"blog/spring/5.2.8/00-Spring中的BeanDefinition/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/00-Spring%E4%B8%AD%E7%9A%84BeanDefinition/","excerpt":"","text":"BeanDefinition BeanDefinition的重要属性 这里解析下BeanDefinition，BeanDefinition在Spring中有很多实现，先下图： 每个BeanDefinition，有些许差别，但目的都是一样的，就是作为spring bean实例化前的载体，保存bean的原始信息。 RootBeanDefinition是在需要实例化时，就会把其他类型的BeanDefinition转化成该类。相当于其他BeanDefinition的汇总。在AbstractBeanFactory#doGetBean（也就是beanFactory.getBean）时会调用 GenericBeanDefinition 在默认标签bean解析完后把对应的信息封装成该对象，这个是一个通用的BeanDefinition，其他BeanDefinition都会继承它 ScannedGenericBeanDefinition 通过扫描得到就会创建该对象，特点就是有注解的信息 AnnotatedGenericBeanDefinition 需要获取注解信息时会把类封装成这个BeanDefinition @Import进来的和内部类都会把这些封装成这个BeanDefinition ConfigurationClassBeanDefinition这个是在@Bean封装成BeanDefinition时会创建这个，不过这个类是私有的内部类。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-Spring中一些重要的图","slug":"spring/5.2.8/00-Spring中一些重要的图","date":"2021-11-20T12:00:03.000Z","updated":"2022-03-14T09:04:24.642Z","comments":true,"path":"blog/spring/5.2.8/00-Spring中一些重要的图/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/00-Spring%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%9B%BE/","excerpt":"","text":"BeanDefinition的信息图","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00 Spring源码中经常出现的工具类","slug":"spring/5.2.8/00 Spring源码中经常出现的工具类","date":"2021-11-20T12:00:02.000Z","updated":"2022-03-14T09:04:24.613Z","comments":true,"path":"blog/spring/5.2.8/00 Spring源码中经常出现的工具类/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/5.2.8/00%20Spring%E6%BA%90%E7%A0%81%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"BeanUtils 对Bean的操作类 12345# 对根据class对象实例化对象instantiateClasscopyProperties(Object source, Object target, String... ignoreProperties)findPropertyType(String propertyName, Class&lt;?&gt;... beanClasses)findPropertyForMethod(Method method, Class&lt;?&gt; clazz) BeanDefinitionBuilder 用来创建BeanDefinition的工具类 AnnotationUtils 注解工具类 AnnotationAttributes 用来保存注解的属性 PropertiesLoaderUtils 用来读取配置文件 ReflectionUtils 这个是Spring中的反射工具类 ClassUtils 12//这个是用来获取原始方法，因为method有可能是接口的方法，而通过这个方法能获取到具体类上的方法。Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass) AopUtils 12345//拿原始方法对象，这个方法上才有注解Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);//选择可调用的方法Method invocableMethod = AopUtils.selectInvocableMethod(method, userType); AnnotatedElementUtils 这个可以获取注解中的属性值 1234567// 判断Clazz对象中是否有Controller注解。AnnotatedElementUtils.hasAnnotation(beanType, Controller.class)//获取类上注解的信息RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);//或者AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(target, Switch.class); 获取注解信息——AnnotationMetadata 在源码中，通过ClassPathBeanDefinitionScanner扫描类时会获取到类的注解信息，而这些类的注解信息Spring是通过类SimpleMetadataReaderFactory获取的，而SimpleMetadataReaderFactory的内部又是这样获取的 12345private static final int PARSING_OPTIONS = ClassReader.SKIP_DEBUG | ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES;SimpleAnnotationMetadataReadingVisitor visitor = new SimpleAnnotationMetadataReadingVisitor(classLoader);new ClassReader(InputStream).accept(visitor, PARSING_OPTIONS);AnnotationMetadata annotationMetadata = visitor.getMetadata(); 在开发中可以使用Spring已经封装好的类这样获取： 12345FileSystemResource fileSystemResource = new FileSystemResource(&quot;class文件的绝对路径&quot;);//这个是带缓存的MetadataReaderFactory，如果不需要缓存可以使用CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory();MetadataReader metadataReader = cachingMetadataReaderFactory.getMetadataReader(fileSystemResource);AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); 看测试方法： 123456789101112131415161718192021222324@Testpublic void test1() &#123; FileSystemResource fileSystemResource = new FileSystemResource(&quot;E:\\\\idea\\\\xiangxueedu-vip-3\\\\spring-source\\\\target\\\\classes\\\\com\\\\enjoy\\\\jack\\\\bean\\\\Jack.class&quot;); CachingMetadataReaderFactory cachingMetadataReaderFactory = new CachingMetadataReaderFactory(); try &#123; MetadataReader metadataReader = cachingMetadataReaderFactory.getMetadataReader(fileSystemResource); System.out.println(metadataReader); Set&lt;MethodMetadata&gt; annotatedMethods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Component.class.getName()); for (MethodMetadata annotatedMethod : annotatedMethods) &#123; System.out.println(annotatedMethod.getMethodName() + &quot;--&quot; + annotatedMethod.getReturnTypeName()); &#125; Map&lt;String, Object&gt; annotationAttributes = metadataReader.getAnnotationMetadata().getAnnotationAttributes(Component.class.getName(), false); System.out.println(annotationAttributes); MergedAnnotations annotations = metadataReader.getAnnotationMetadata().getAnnotations(); System.out.println(annotations); MergedAnnotation&lt;Component&gt; componentMergedAnnotation = annotations.get(Component.class); System.out.println(componentMergedAnnotation); AnnotationAttributes annotationAttributes1 = componentMergedAnnotation.asAnnotationAttributes(MergedAnnotation.Adapt.ANNOTATION_TO_MAP); System.out.println(annotationAttributes1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 也可以使用这种模式 123AnnotationMetadata metadata = AnnotationMetadata.introspect(ScanBean.class);Set&lt;String&gt; sets = metadata.getAnnotationTypes();Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(PropertySource.class.getName(), false); 获取类上注解的属性 AnnotationConfigUtils在源码中，通过ClassPathBeanDefinitionScanner扫描类时同这样的方式获取注解上的属性： 123456789101112131415161718//AnnotationScopeMetadataResolverpublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) &#123; ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) &#123; AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); if (attributes != null) &#123; metadata.setScopeName(attributes.getString(&quot;value&quot;)); ScopedProxyMode proxyMode = attributes.getEnum(&quot;proxyMode&quot;); if (proxyMode == ScopedProxyMode.DEFAULT) &#123; proxyMode = this.defaultProxyMode; &#125; metadata.setScopedProxyMode(proxyMode); &#125; &#125; return metadata;&#125; 或者，某些注解在使用上有父子关系的 比如ComponentScans和ComponentScan，可以通过 12Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable( sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class) 来获取ComponentScan注解集合。 TransactionSynchronizationManager——这个是在使用@Transaction注解的时候，在方法内能通过TransactionSynchronizationManager来获取链接的信息，或链接等，比如： 1ConnectionHolder connectionHolder = (ConnectionHolder)TransactionSynchronizationManager.getResource(dataSource); 更多的看这里14-Spring中使用事物 RequestContextHolder——这个是在SpringMVC中，用来获取Request对象的 123ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();HttpServletRequest request = servletRequestAttributes.getRequest(); WebUtils——SpringWeb中的工具类，获取请求链接或者Cookie等 12static Cookie getCookie(HttpServletRequest request, String name) static String findParameterValue(ServletRequest request, String name) UrlPathHelper——SpringWeb中的工具类，有很多对HttpServletRequest操作的方法比如： 123UrlPathHelper uriPathHelper = new UrlPathHelper();//获取请求路径，比如http://127.0.0.1:9090/common/query2?areaCode=1，通过这个方法后返回/common/query2String lookupPath = uriPathHelper.getLookupPathForRequest(request); DefaultParameterNameDiscoverer——获取参数名称 这个类实现了接口ParameterNameDiscoverer，这个接口的定义也很简单 123456789public interface ParameterNameDiscoverer &#123; @Nullable String[] getParameterNames(Method method); @Nullable String[] getParameterNames(Constructor&lt;?&gt; ctor);&#125; 就是获取方法的参数名称，和构造器的参数名称 使用也很简单 1ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); CollectionUtils 看名字就知道，就是对集合的操作工具类 MethodIntrospector——可以用来获取某个类的Method对象。使用：(SpringMVC中的AbstractHandlerMethodMapping中) 123456789101112Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; 。。。。。。 &#125; &#125;);if (logger.isTraceEnabled()) &#123; logger.trace(formatMappings(userType, methods));&#125; BeanFactoryUtils AnnotationUtils ProxyFactory 创建代理对象，看源码AbstractAutoProxyCreator的createProxy方法 12345678910111213141516171819202122232425262728293031323334protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) &#123; if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123; AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); &#125; ProxyFactory proxyFactory = new ProxyFactory(); //把AnnotationAwareAspectJAutoProxyCreator中的某些属性copy到proxyFactory中 proxyFactory.copyFrom(this); if (!proxyFactory.isProxyTargetClass()) &#123; if (shouldProxyTargetClass(beanClass, beanName)) &#123; proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; //组装advisor Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); //把advisor加入到proxyFactory proxyFactory.addAdvisors(advisors); //把targetSource对象加入到proxyFactory proxyFactory.setTargetSource(targetSource); customizeProxyFactory(proxyFactory); proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; //获取代理对象 return proxyFactory.getProxy(getProxyClassLoader());&#125; MethodParameter 获取方法的参数 12MethodParameter par = nwe MethodParameter(method, 0) ResolvableType 获取方法参数的范型类型 12MethodParameter returnType = nwe MethodParameter(method, -1)Class&lt;?&gt; bodyType = ResolvableType.forMethodParameter(returnType).getGeneric().resolve(); StandardAnnotationMetadata 1new StandardAnnotationMetadata(Object.class); 获取类的注解信息","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]},{"title":"00-DeferredImportSelector接口的作用、初始化和执行原理","slug":"spring/00-DeferredImportSelector接口的作用、初始化和执行原理","date":"2021-11-20T12:00:01.000Z","updated":"2022-03-14T09:04:24.611Z","comments":true,"path":"blog/spring/00-DeferredImportSelector接口的作用、初始化和执行原理/","link":"","permalink":"http://sv.pointcut.cc/blog/spring/00-DeferredImportSelector%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"","text":"DeferredImportSelector接口的作用、初始化和执行原理实例化该接口是在实例化是发生在ConfigurationClassParser#processImports方法中的。在该方法执行了来实例化 12ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); ImportSelector是DeferredImportSelector的父类 看ParserStrategyUtils.instantiateClass的源码 123456789101112131415161718// ParserStrategyUtilsstatic &lt;T&gt; T instantiateClass(Class&lt;?&gt; clazz, Class&lt;T&gt; assignableTo, Environment environment, ResourceLoader resourceLoader, BeanDefinitionRegistry registry) &#123; Assert.notNull(clazz, &quot;Class must not be null&quot;); Assert.isAssignable(assignableTo, clazz); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;); &#125; ClassLoader classLoader = (registry instanceof ConfigurableBeanFactory ? ((ConfigurableBeanFactory) registry).getBeanClassLoader() : resourceLoader.getClassLoader()); // 这个方法会检查clazz的构造函数是否有一个，如果是一个的话，还会检查该构造的参数是否有 // BeanFactory(也就是BeanDefinitionRegistry)，Environment和ResourceLoader // 有的话就会把对应的对象作为参数传入来完成对应的实例化 T instance = (T) createInstance(clazz, environment, resourceLoader, registry, classLoader); ParserStrategyUtils.invokeAwareMethods(instance, environment, resourceLoader, registry, classLoader); return instance;&#125; 通过createInstance方法可知，通过定义如下类 123456789101112131415161718192021// ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现类也支持这中模式public class DeferredImportSelectorDemo implements DeferredImportSelector &#123; /** * 可以通过强制类型转换，转成需要的beanFactory */ private BeanFactory beanFactory; private Environment environment; public DeferredImportSelectorDemo(BeanFactory beanFactory, Environment environment) &#123; this.beanFactory = beanFactory; this.environment = environment; &#125; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; System.out.println(&quot;=====DeferredImportSelectorDemo.selectImports&quot;); return new String[]&#123;SelectImportBean.class.getName()&#125;; &#125;&#125; 通过提供一个带有BeanFactory或Environment参数的构造方法，来注入BeanFactory和Environment。通过这种模式和DeferredImportSelector接口方法的执行时机，可以实现一些特殊的功能 注意，这种注入方式要生效的前提是——只能提供一个构造方法 ImportSelector接口和ImportBeanDefinitionRegistrar接口的实现类也支持这中模式 或者ParserStrategyUtils.invokeAwareMethods可知： 1234567891011121314151617181920212223242526272829303132@Orderpublic class DeferredImportSelectorDemo implements DeferredImportSelector, BeanClassLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; /** * 可以通过强制类型转换，转成需要的beanFactory */ private BeanFactory beanFactory; private Environment environment; @Override public void setBeanClassLoader(ClassLoader classLoader) &#123; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; &#125; @Override public void setEnvironment(Environment environment) &#123; this.environment = environment; &#125; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; System.out.println(&quot;=====DeferredImportSelectorDemo.selectImports&quot;); return new String[]&#123;SelectImportBean.class.getName()&#125;; &#125;&#125; 也可以通过如上的定义来完成BeanFactory和Environment的注入。 作用作用有两点： 对于有依赖关系的类，延迟一些类的BeanDefinition创建时机。也就是说实现如下流程。 这个作用之所以能实现，是由于该接口的方法的执行时机。这一点后面讲。 12检查某个类的BeanDefinition是否存在，存在的话就不引入某个类，或者把引入的类作为某个类的属性。通过某个环境变量的或配置的值，来判断某个类是否需要引入 单从该接口提供的方法看，是完成不了上边的流程的，因为没有BeanFactory和Environment这个入参。但可以通过提供提供一个构造方法，该构造方法有BeanFactory和Environment这两个参数，通过这种模式来引入这两个对象。还可以通过实现BeanClassLoaderAware, BeanFactoryAware, EnvironmentAware接口来引入对应的属性 按组来引入类，而且这些组也是支持排序的，只需在定义的类上加上@Order或实现Ordered等排序结构，就支持组的排序了。 这样就可以控制方法调用的顺序 ，从而控制类注册到Spring容器的时机。这样就可以起到了控制类间的依赖关系。 调用时机该接口的方法调用时机是发生在ConfigurationClassParser.parse方法的最用： 123456//ConfigurationClassParser public void parse(Set&lt;BeanDefinitionHolder&gt; configCandidates) &#123; .... // 这行代码不能忽视 this.deferredImportSelectorHandler.process();&#125; 在这时调用就意味着配置已经加载完成；已经通过包扫描，把扫描到的类有生成BeanDefinition，并注册到Spring容器中了；已经把某些注解比如@Import、@bean和@ImportResource等注解的信息保存到ConfigurationClass中，但还没有执行对应方法。 执行原理12345678910111213141516// DeferredImportSelectorHandlerpublic void process() &#123; List&lt;DeferredImportSelectorHolder&gt; deferredImports = this.deferredImportSelectors; this.deferredImportSelectors = null; try &#123; if (deferredImports != null) &#123; DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler(); deferredImports.sort(DEFERRED_IMPORT_COMPARATOR); deferredImports.forEach(handler::register); handler.processGroupImports(); &#125; &#125; finally &#123; this.deferredImportSelectors = new ArrayList&lt;&gt;(); &#125;&#125; DeferredImportSelectorHolder其实就是DeferredImportSelector和ConfigurationClass的包装类 创建完DeferredImportSelectorGroupingHandler后，对之前收集的DeferredImportSelectorHolder列表做排序，排序个规则依赖于该Hodler里面的DeferredImportSelector对象 123private static final Comparator&lt;DeferredImportSelectorHolder&gt; DEFERRED_IMPORT_COMPARATOR = (o1, o2) -&gt; AnnotationAwareOrderComparator.INSTANCE.compare(o1.getImportSelector(), o2.getImportSelector());也就是说，依赖于@Order注解、Order等排序接口 排序完后对DeferredImportSelectorHolder列表遍历 遍历执行DeferredImportSelectorGroupingHandler.register 123456789101112// DeferredImportSelectorGroupingHandlerpublic void register(DeferredImportSelectorHolder deferredImport) &#123; //调用getImportGroup方法，返回实现了Group接口的类 Class&lt;? extends Group&gt; group = deferredImport.getImportSelector().getImportGroup(); //建立实现了Group接口类和DeferredImportSelectorGrouping的映射关系 DeferredImportSelectorGrouping grouping = this.groupings.computeIfAbsent( (group != null ? group : deferredImport), key -&gt; new DeferredImportSelectorGrouping(createGroup(group))); grouping.add(deferredImport); this.configurationClasses.put(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getConfigurationClass());&#125; 这代码很简单，做了两件事 分组。先通过DeferredImportSelector.getImportGroup获取到分组的依据，如果没有重写该方法，那么就使用DeferredImportSelectorHolder对象本身。最终形成的结果就是形成如下关系： 1234567891011121314151617181920212223242526272829Class&lt;Group1&gt;=&gt;DeferredImportSelectorGrouping(Group1) &#123; Group group = Group1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; Group1.DeferredImportSelectorHolder1, Group1.DeferredImportSelectorHolder2, &#125;&#125;;Class&lt;Group2&gt;=&gt;DeferredImportSelectorGrouping(Group2) &#123; Group group = Group2; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; Group2.DeferredImportSelectorHolder2, Group2.DeferredImportSelectorHolder3, &#125;&#125;;DeferredImportSelectorHolder1=&gt;DeferredImportSelectorGrouping(null) &#123; Group group = DefaultDeferredImportSelectorGroup1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; DeferredImportSelectorHolder1, &#125;&#125;;DeferredImportSelectorHolder2=&gt;DeferredImportSelectorGrouping(null) &#123; Group group = DefaultDeferredImportSelectorGroup2; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; DeferredImportSelectorHolder2, &#125;&#125; 最后把这个关系保存在groupings这个Map中 通过DeferredImportSelectorHolder获取把这个DeferredImportSelector对象对应的ConfigurationClass对象后，保存在了configurationClasses这个Map中。为之后的生成BeanDefinition做准备 最后执行了DeferredImportSelectorGroupingHandler.processGroupImports方法 12345678910111213141516171819202122232425262728293031323334// DeferredImportSelectorGroupingHandlerpublic void processGroupImports() &#123; for (DeferredImportSelectorGrouping grouping : this.groupings.values()) &#123; Predicate&lt;String&gt; exclusionFilter = grouping.getCandidateFilter(); //这里调用了 group.selectImports() grouping.getImports().forEach(entry -&gt; &#123; ConfigurationClass configurationClass = this.configurationClasses.get(entry.getMetadata()); try &#123; //又递归处理每一个返回的Entry processImports(configurationClass, asSourceClass(configurationClass, exclusionFilter), Collections.singleton(asSourceClass(entry.getImportClassName(), exclusionFilter)), exclusionFilter, false); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( &quot;Failed to process import candidates for configuration class [&quot; + configurationClass.getMetadata().getClassName() + &quot;]&quot;, ex); &#125; &#125;); &#125;&#125;// DeferredImportSelectorGroupingpublic Iterable&lt;Group.Entry&gt; getImports() &#123; for (DeferredImportSelectorHolder deferredImport : this.deferredImports) &#123; this.group.process(deferredImport.getConfigurationClass().getMetadata(), deferredImport.getImportSelector()); &#125; //在这里调用了实现了Group接口的selectImports方法 return this.group.selectImports();&#125; 上边方法的核心就是getImports方法 这个方法遍历上边初始化的groupingsMap。 了解了groupings这个Map的关系后，那processGroupImports的源码就很好理解了，就是按组来完成Group对象的process方法调用，然后调用Group.selectImports的调用，遍历该方法的返回值，最后把类的信息封保存到ConfigurationClass对象，收集完信息后，保存在了configurationClasses这个Map中。为之后的BeanDefinition做准备。 这里有两种情况，也就是对应下面的关系 1234567891011121314Class&lt;Group1&gt;=&gt;DeferredImportSelectorGrouping(Group1) &#123; Group group = Group1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; Group1.DeferredImportSelectorHolder1, Group1.DeferredImportSelectorHolder2, &#125;&#125;;DeferredImportSelectorHolder1=&gt;DeferredImportSelectorGrouping() &#123; Group group = DefaultDeferredImportSelectorGroup1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; DeferredImportSelectorHolder1, &#125;&#125;; 如果DeferredImportSelector的实现类没有重写getImportGroup，对应的groupings&#96;关系如下 123456DeferredImportSelectorHolder1=&gt;DeferredImportSelectorGrouping() &#123; Group group = DefaultDeferredImportSelectorGroup1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; DeferredImportSelectorHolder1, &#125;&#125;; 那么在这里的Group等于DefaultDeferredImportSelectorGroup1，看下该类的逻辑 12345678910111213141516private static class DefaultDeferredImportSelectorGroup implements Group &#123; private final List&lt;Entry&gt; imports = new ArrayList&lt;&gt;(); @Override public void process(AnnotationMetadata metadata, DeferredImportSelector selector) &#123; for (String importClassName : selector.selectImports(metadata)) &#123; this.imports.add(new Entry(metadata, importClassName)); &#125; &#125; @Override public Iterable&lt;Entry&gt; selectImports() &#123; return this.imports; &#125;&#125; 其实就是执行了该组的DeferredImportSelector的selectImports方法，把这些方法的返回值收集起来，最后把收集的结果作为Group.selectImports的返回值。 总结：在这种关系下，需要引入的类依赖于DeferredImportSelector类的selectImports方法的返回值 如果DeferredImportSelector的实现类重写getImportGroup方法，并返回了一个Group接口的实现类 ，对应的关系如下 1234567Class&lt;Group1&gt;=&gt;DeferredImportSelectorGrouping(Group1) &#123; Group group = Group1; List&lt;DeferredImportSelectorHolder&gt; deferredImports = &#123; Group1.DeferredImportSelectorHolder1, Group1.DeferredImportSelectorHolder2, &#125;&#125;; 这种关系下，需要引入的类就依赖于Group接口的实现类的selectImports方法了。而该方法的返回值时可以使用Group#process方法来进行一些处理。 总结 12345678910111213@Component//Import虽然是实例化一个类，Import进来的类可以实现一些接口@Import(&#123;DeferredImportSelectorDemo.class,AwareBean.class&#125;)//@ImportResource(&quot;classpath:spring.xml&quot;)public class ImportBean &#123;&#125;public class DeferredImportSelectorDemo implements DeferredImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; System.out.println(&quot;=====DeferredImportSelectorDemo.selectImports&quot;); return new String[]&#123;SelectImportBean.class.getName()&#125;; &#125;&#125; 这种情况下SelectImportBean类就能被SpringIOC容器管理 12345678910111213141516171819202122232425262728293031323334353637public class DeferredImportSelectorDemo implements DeferredImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; System.out.println(&quot;=====DeferredImportSelectorDemo.selectImports&quot;); return new String[]&#123;SelectImportBean.class.getName()&#125;; &#125; /** * 要返回一个实现了Group接口的类 */ @Override public Class&lt;? extends Group&gt; getImportGroup() &#123; return DeferredImportSelectorGroupDemo.class; &#125; private static class DeferredImportSelectorGroupDemo implements DeferredImportSelector.Group &#123; List&lt;Entry&gt; list = new ArrayList&lt;&gt;(); /** 收集需要实例化的类 */ @Override public void process(AnnotationMetadata metadata, DeferredImportSelector selector) &#123; System.out.println(&quot;=====DeferredImportSelectorGroupDemo.process&quot;); String[] strings = selector.selectImports(metadata); for (String string : strings) &#123; list.add(new Entry(metadata,string)); &#125; &#125; @Override public Iterable&lt;Entry&gt; selectImports() &#123; System.out.println(&quot;=====DeferredImportSelectorGroupDemo.selectImports&quot;); return list; &#125; &#125;&#125; 这种情况下，引入的类就看DeferredImportSelectorGroupDemo的selectImports的返回值。","categories":[{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]}],"categories":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/categories/springcloud/"},{"name":"feign","slug":"springcloud/feign","permalink":"http://sv.pointcut.cc/categories/springcloud/feign/"},{"name":"markdown","slug":"markdown","permalink":"http://sv.pointcut.cc/categories/markdown/"},{"name":"开源框架","slug":"开源框架","permalink":"http://sv.pointcut.cc/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"http://sv.pointcut.cc/tags/springcloud/"},{"name":"spring","slug":"spring","permalink":"http://sv.pointcut.cc/tags/spring/"}]}