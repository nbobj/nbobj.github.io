<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>02Store源码分析md | XYZhi's学习笔记</title><meta name="keywords" content="rocketmq"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RocketMq的消息存储看这里《04消息存储》 要理解Store，先看零拷贝与MMAP 消息存储结构 存储文件 CommitLog之Message格式   字段 字段含义 字段大小    msgSize 代表这个消息的大小 4   MagicCode 魔数 4   BodeCRC 消息体 BODY CRC 4   queueId 消息队列ID 4   flag 可能是为了兼容老版本的Messag">
<meta property="og:type" content="article">
<meta property="og:title" content="02Store源码分析md">
<meta property="og:url" content="https://nbobj.github.io/blog/rocketmq/02Store%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90md/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="RocketMq的消息存储看这里《04消息存储》 要理解Store，先看零拷贝与MMAP 消息存储结构 存储文件 CommitLog之Message格式   字段 字段含义 字段大小    msgSize 代表这个消息的大小 4   MagicCode 魔数 4   BodeCRC 消息体 BODY CRC 4   queueId 消息队列ID 4   flag 可能是为了兼容老版本的Messag">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nbobj.github.io/linear-gradient(#0062be)">
<meta property="article:published_time" content="2022-01-14T00:00:02.000Z">
<meta property="article:modified_time" content="2022-04-13T09:50:32.335Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="rocketmq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nbobj.github.io/linear-gradient(#0062be)"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nbobj.github.io/blog/rocketmq/02Store%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90md/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '02Store源码分析md',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-13 17:50:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(#0062be)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">02Store源码分析md</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-14T00:00:02.000Z" title="发表于 2022-01-14 08:00:02">2022-01-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-13T09:50:32.335Z" title="更新于 2022-04-13 17:50:32">2022-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="02Store源码分析md"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>RocketMq的消息存储看这里<a href="./04%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8">《04消息存储》</a></p>
<p>要理解Store，先看<a href="../../../%E9%9B%B6%E6%8B%B7%E8%B4%9D%E4%B8%8EMMAP">零拷贝与MMAP</a></p>
<h2 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729491.png" alt="image-20211117005923594"></p>
<h2 id="存储文件"><a href="#存储文件" class="headerlink" title="存储文件"></a>存储文件</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729492.png" alt="image-20211117005951209"></p>
<h2 id="CommitLog之Message格式"><a href="#CommitLog之Message格式" class="headerlink" title="CommitLog之Message格式"></a>CommitLog之Message格式</h2><table>
<thead>
<tr>
<th>字段</th>
<th>字段含义</th>
<th>字段大小</th>
</tr>
</thead>
<tbody><tr>
<td>msgSize</td>
<td>代表这个消息的大小</td>
<td>4</td>
</tr>
<tr>
<td>MagicCode</td>
<td>魔数</td>
<td>4</td>
</tr>
<tr>
<td>BodeCRC</td>
<td>消息体 BODY CRC</td>
<td>4</td>
</tr>
<tr>
<td>queueId</td>
<td>消息队列ID</td>
<td>4</td>
</tr>
<tr>
<td>flag</td>
<td>可能是为了兼容老版本的Message格式</td>
<td>4</td>
</tr>
<tr>
<td>QueueOffset</td>
<td>消息队列的逻辑偏移</td>
<td>8</td>
</tr>
<tr>
<td>PhysicalOffset</td>
<td>消息的物理存储位置</td>
<td>8</td>
</tr>
<tr>
<td>Sysflag</td>
<td>Compressed&#x2F;MultiTags&#x2F;prepared&#x2F;commit &#x2F;rollback</td>
<td>4</td>
</tr>
<tr>
<td>BornTimeStamp</td>
<td>消息产生端(producer)的时间戳</td>
<td>8</td>
</tr>
<tr>
<td>BornHost</td>
<td>消息产生端(producer)地址(address:port)</td>
<td>8</td>
</tr>
<tr>
<td>StoreTimeStamp</td>
<td>消息在broker存储时间</td>
<td>8</td>
</tr>
<tr>
<td>StoreHostAddress</td>
<td>消息存储端(broker)地址(address:port)</td>
<td>8</td>
</tr>
<tr>
<td>ReconsumeTimes</td>
<td>消息被某个订阅组重新消费的次数</td>
<td>8</td>
</tr>
<tr>
<td>PreparedTransaction Offset</td>
<td>表示是prepared状态的事物消息</td>
<td>8</td>
</tr>
<tr>
<td>messagebodyLength</td>
<td>消息体大小值</td>
<td>4</td>
</tr>
<tr>
<td>messagebody</td>
<td>消息体内容</td>
<td>bodyLength</td>
</tr>
<tr>
<td>topicLength</td>
<td>topic名称内容大小</td>
<td>1</td>
</tr>
<tr>
<td>topic</td>
<td>topic的内容值</td>
<td>topicLength</td>
</tr>
<tr>
<td>propertiesLength</td>
<td>属性值大小</td>
<td>2</td>
</tr>
<tr>
<td>properties</td>
<td>propertiesLength大小的属性数据（key、tag都是根据这个拓展）</td>
<td>propertiesLength</td>
</tr>
</tbody></table>
<h2 id="Store服务的启动"><a href="#Store服务的启动" class="headerlink" title="Store服务的启动"></a>Store服务的启动</h2><p>Store服务是在Broker服务启动的时候启动的，看<a href="./broker%E5%90%AF%E5%8A%A8">Brokerq启动</a></p>
<p>在BrokerController的initialize方法中，先生成<code>messageStore</code>对象，默认下，他的类型为<code>DefaultMessageStore</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729493.png" alt="image-20211117012107619"></p>
<p>执行了<code>DefaultMessageStore#load</code>方法后，会生成commitlog、consumequeue和index文件的<code>MappedFile</code>对象。接着在同一个方法内，会执行了<code>registerProcessor()</code>方法，注册各种请求处理器<code>NettyRequestProcessor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SendMessageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//todo 收到消息之后的核心处理</span></span><br><span class="line">    <span class="type">SendMessageProcessor</span> <span class="variable">sendProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendMessageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    sendProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line">    sendProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line">    <span class="comment">//注册一系列的任务请求</span></span><br><span class="line">    <span class="comment">//todo 注册消息发送</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_MESSAGE_V2, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_BATCH_MESSAGE, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.CONSUMER_SEND_MSG_BACK, sendProcessor, <span class="built_in">this</span>.sendMessageExecutor);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PullMessageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.PULL_MESSAGE, <span class="built_in">this</span>.pullMessageProcessor, <span class="built_in">this</span>.pullMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.pullMessageProcessor.registerConsumeMessageHook(consumeMessageHookList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReplyMessageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ReplyMessageProcessor</span> <span class="variable">replyMessageProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyMessageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    replyMessageProcessor.registerSendMessageHook(sendMessageHookList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE, replyMessageProcessor, replyMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.SEND_REPLY_MESSAGE_V2, replyMessageProcessor, replyMessageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * QueryMessageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">NettyRequestProcessor</span> <span class="variable">queryProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryMessageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, <span class="built_in">this</span>.queryMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, <span class="built_in">this</span>.queryMessageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.QUERY_MESSAGE, queryProcessor, <span class="built_in">this</span>.queryMessageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.VIEW_MESSAGE_BY_ID, queryProcessor, <span class="built_in">this</span>.queryMessageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ClientManageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ClientManageProcessor</span> <span class="variable">clientProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientManageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.HEART_BEAT, clientProcessor, <span class="built_in">this</span>.heartbeatExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientProcessor, <span class="built_in">this</span>.clientManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientProcessor, <span class="built_in">this</span>.clientManageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.HEART_BEAT, clientProcessor, <span class="built_in">this</span>.heartbeatExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.UNREGISTER_CLIENT, clientProcessor, <span class="built_in">this</span>.clientManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.CHECK_CLIENT_CONFIG, clientProcessor, <span class="built_in">this</span>.clientManageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConsumerManageProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ConsumerManageProcessor</span> <span class="variable">consumerManageProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsumerManageProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.GET_CONSUMER_LIST_BY_GROUP, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.UPDATE_CONSUMER_OFFSET, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.QUERY_CONSUMER_OFFSET, consumerManageProcessor, <span class="built_in">this</span>.consumerManageExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * EndTransactionProcessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerProcessor(RequestCode.END_TRANSACTION, <span class="keyword">new</span> <span class="title class_">EndTransactionProcessor</span>(<span class="built_in">this</span>), <span class="built_in">this</span>.endTransactionExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerProcessor(RequestCode.END_TRANSACTION, <span class="keyword">new</span> <span class="title class_">EndTransactionProcessor</span>(<span class="built_in">this</span>), <span class="built_in">this</span>.endTransactionExecutor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">AdminBrokerProcessor</span> <span class="variable">adminProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdminBrokerProcessor</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.remotingServer.registerDefaultProcessor(adminProcessor, <span class="built_in">this</span>.adminBrokerExecutor);</span><br><span class="line">    <span class="built_in">this</span>.fastRemotingServer.registerDefaultProcessor(adminProcessor, <span class="built_in">this</span>.adminBrokerExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在NameSpace中，就已经讲过了，所用的请求都会根据RequestCode选择<code>NettyRequestProcessor</code>和一个<code>ExecutorService</code>来处理这个请求。而上边就是定义了某些请求的的<code>NettyRequestProcessor</code>。</p>
<p>最后，Store会随着Broker的启动而启动了。</p>
<h2 id="Store架构设计"><a href="#Store架构设计" class="headerlink" title="Store架构设计"></a>Store架构设计</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729494.png" alt="image-20211118045012455"></p>
<blockquote>
<p>上图中，PullMessageProcessor是用来处理Consumer拉取消息的，SendMessageProcessor是用来处理Producer发送消息的，QueryMessageProcessor是用来处理客户端查询消息的（按时间戳、偏移量等）。</p>
</blockquote>
<p>上图就是Store的架构图，对应的类都在启动阶段都已经准备好了。比如有一个发送消息的请求到达Broker，它的处理链路是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SendMessaegProcessor --&gt;</span><br><span class="line">DefaultMessageStore --&gt;</span><br><span class="line">CommitLog  --&gt;</span><br><span class="line">ConsumeQueue --&gt;</span><br><span class="line">MappedFile --&gt;</span><br><span class="line">MappedByteBuffer</span><br></pre></td></tr></table></figure>

<p>而其中<code>MappedFile</code>作为物理文件的抽象，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中，封装了MappedByteBuffer对文件进行读写的操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729495.png" alt="image-20211117023102011"></p>
<p><code>MappedFile</code>可以看作是一个物理文件。所以整个存储层的关系如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729496.png" alt="image-20211118083039075"></p>
<p>而上图中IndexFile是对应Index文件夹的抽象；CommitLog是对commitlog文件夹的抽象；ConsumeQueue是对consumequeue文件的夹的抽象。</p>
<p>而TransientStorePool是一个缓冲区池；StoreChekcPoint，对应的是checkpoint文件。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="接收消息——commitlog的生成"><a href="#接收消息——commitlog的生成" class="headerlink" title="接收消息——commitlog的生成"></a>接收消息——commitlog的生成</h3><p>当一个Producer向Broker发送消息时，这个请求经过ChannelHandler后，会交给某个<code>NettyRequestProcessor</code>来处理，处理的方法为<code>processRequest</code>，而这个Processor就是<code>SendMessageProcessor</code>。最终，请求会会交给方法<code>asyncSendMessage</code>处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompletableFuture&lt;RemotingCommand&gt; <span class="title function_">asyncSendMessage</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request,</span></span><br><span class="line"><span class="params">                                                            SendMessageContext mqtraceContext,</span></span><br><span class="line"><span class="params">                                                            SendMessageRequestHeader requestHeader)</span> &#123;</span><br><span class="line">    <span class="comment">//todo 在发送前的处理，标识RPC的SeqNumber,检查队列的读写权限、自动创建Topic等等</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">RemotingCommand</span> <span class="variable">response</span> <span class="operator">=</span> preSend(ctx, request, requestHeader);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SendMessageResponseHeader</span> <span class="variable">responseHeader</span> <span class="operator">=</span> (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.getCode() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] body = request.getBody();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">queueIdInt</span> <span class="operator">=</span> requestHeader.getQueueId();</span><br><span class="line">    <span class="type">TopicConfig</span> <span class="variable">topicConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    <span class="comment">//todo  如果没有指定QueueID,系统随机指定一个</span></span><br><span class="line">    <span class="keyword">if</span> (queueIdInt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo 构造Broker内部使用的Message（包装一层）</span></span><br><span class="line">    <span class="type">MessageExtBrokerInner</span> <span class="variable">msgInner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageExtBrokerInner</span>();</span><br><span class="line">    msgInner.setTopic(requestHeader.getTopic()); <span class="comment">//主题</span></span><br><span class="line">    msgInner.setQueueId(queueIdInt);          <span class="comment">//queueId</span></span><br><span class="line">    <span class="comment">//todo 死信消息的处理逻辑--如果是消费重试次数达到上线，就会进入死信队列</span></span><br><span class="line">    <span class="keyword">if</span> (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgInner.setBody(body);</span><br><span class="line">    msgInner.setFlag(requestHeader.getFlag());  <span class="comment">//flag</span></span><br><span class="line">    MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">    msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());  <span class="comment">//在客户端的生产时间</span></span><br><span class="line">    msgInner.setBornHost(ctx.channel().remoteAddress());          <span class="comment">//在客户端的地址</span></span><br><span class="line">    msgInner.setStoreHost(<span class="built_in">this</span>.getStoreHost());</span><br><span class="line">    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == <span class="literal">null</span> ? <span class="number">0</span> : requestHeader.getReconsumeTimes());</span><br><span class="line">    <span class="type">String</span> <span class="variable">clusterName</span> <span class="operator">=</span> <span class="built_in">this</span>.brokerController.getBrokerConfig().getBrokerClusterName();</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;PutMessageResult&gt; putMessageResult = <span class="literal">null</span>;</span><br><span class="line">    Map&lt;String, String&gt; origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">    <span class="type">String</span> <span class="variable">transFlag</span> <span class="operator">=</span> origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">    <span class="keyword">if</span> (transFlag != <span class="literal">null</span> &amp;&amp; Boolean.parseBoolean(transFlag)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(</span><br><span class="line">                    <span class="string">&quot;the broker[&quot;</span> + <span class="built_in">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                            + <span class="string">&quot;] sending transaction message is forbidden&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 事务消息的Prepare消息</span></span><br><span class="line">        putMessageResult = <span class="built_in">this</span>.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//todo 处理普通消息，和事务消息的Commit/Rollback消息</span></span><br><span class="line">        putMessageResult = <span class="built_in">this</span>.brokerController.getMessageStore().asyncPutMessage(msgInner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个方法实际上只是对消息做一些预处理，最后交给了<code>BrokerController</code>的messageStore，也就是<code>DefaultMessageStore</code>处理，这也符合架构的图中业务层的设计，而<code>DefaultMessageStore</code>处理消息的方法为<code>asyncPutMessage</code>，看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(MessageExtBrokerInner msg)</span> &#123;</span><br><span class="line">    <span class="type">PutMessageStatus</span> <span class="variable">checkStoreStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.checkStoreStatus();</span><br><span class="line">    <span class="keyword">if</span> (checkStoreStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(checkStoreStatus, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PutMessageStatus</span> <span class="variable">msgCheckStatus</span> <span class="operator">=</span> <span class="built_in">this</span>.checkMessage(msg);</span><br><span class="line">    <span class="keyword">if</span> (msgCheckStatus == PutMessageStatus.MESSAGE_ILLEGAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(msgCheckStatus, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">beginTime</span> <span class="operator">=</span> <span class="built_in">this</span>.getSystemClock().now();</span><br><span class="line">    <span class="comment">//这里会进入commitLog的消息处理逻辑</span></span><br><span class="line">    CompletableFuture&lt;PutMessageResult&gt; putResultFuture = <span class="built_in">this</span>.commitLog.asyncPutMessage(msg);</span><br><span class="line"></span><br><span class="line">    putResultFuture.thenAccept((result) -&gt; &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> <span class="built_in">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">        <span class="keyword">if</span> (elapsedTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;putMessage not in lock elapsed time(ms)=&#123;&#125;, bodyLength=&#123;&#125;&quot;</span>, elapsedTime, msg.getBody().length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.storeStatsService.setPutMessageEntireTimeMax(elapsedTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == result || !result.isOk()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.storeStatsService.getPutMessageFailedTimes().incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putResultFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个方法也是会将请求交给了<code>CommitLog</code>类的<code>asyncPutMessage</code>方法处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title function_">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> &#123;</span><br><span class="line">    <span class="comment">// Set the storage time</span></span><br><span class="line">    <span class="comment">//Message存储到Broker的时间</span></span><br><span class="line">    msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">    <span class="comment">// Set the message body BODY CRC (consider the most appropriate setting</span></span><br><span class="line">    <span class="comment">// on the client)</span></span><br><span class="line">    <span class="comment">//Message body的crc校验码，防止消息内容被篡改和破坏</span></span><br><span class="line">    msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">    <span class="comment">// Back to Results</span></span><br><span class="line">    <span class="type">AppendMessageResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//存储耗时相关的信息，可以收集这些指标，上报给监控系统</span></span><br><span class="line">    <span class="type">StoreStatsService</span> <span class="variable">storeStatsService</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMessageStore.getStoreStatsService();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> msg.getTopic();</span><br><span class="line">    <span class="type">int</span> <span class="variable">queueId</span> <span class="operator">=</span> msg.getQueueId();</span><br><span class="line">    <span class="comment">//处理延时消息(定时消息)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="built_in">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="built_in">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//延迟队列的主题名</span></span><br><span class="line">            topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;</span><br><span class="line">          	<span class="comment">//根据延迟级别选择对应的队列</span></span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId</span></span><br><span class="line">            <span class="comment">// 备份原来的主图和队列id，这种替换队列的模式在rocketMQ很常见</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">elapsedTimeInLock</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">unlockMappedFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//获取最近的一个CommitLog文件的内容映射文件(零拷贝)</span></span><br><span class="line">    <span class="type">MappedFile</span> <span class="variable">mappedFile</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">    <span class="comment">//todo putMessgae会有多个线程并行处理，需要上锁，可以在broker中配置是可重入锁还是自旋锁(useReentrantLockWhenPutMessage )</span></span><br><span class="line">    <span class="comment">//默认是false，使用自旋锁。异步刷盘建议使用自旋锁，同步刷盘建议使用重入锁</span></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">beginLockTimestamp</span> <span class="operator">=</span> <span class="built_in">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">        <span class="built_in">this</span>.beginTimeInLock = beginLockTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here settings are stored timestamp, in order to ensure an orderly</span></span><br><span class="line">        <span class="comment">// global</span></span><br><span class="line">        <span class="comment">//拿到锁之后，再设置一次，这样可以做到全局有序</span></span><br><span class="line">        msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">        <span class="comment">//最近的Commtlog文件写满了，再创建一个新的。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == mappedFile) &#123;</span><br><span class="line">            beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.CREATE_MAPEDFILE_FAILED, <span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo  3.1把Broker内部的这个Message刷新到MappedFile的内存（注意，这个时候还没有刷盘）</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="built_in">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                <span class="comment">// 进入到这个case 表示当前的文件不够空间写入消息，需要新建一个文件，然后写入到新建的文件上</span></span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="built_in">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">&quot;create mapped file2 error, topic: &quot;</span> + msg.getTopic() + <span class="string">&quot; clientAddr: &quot;</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="built_in">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 不重要</span></span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        elapsedTimeInLock = <span class="built_in">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != unlockMappedFile &amp;&amp; <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">PutMessageResult</span> <span class="variable">putMessageResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutMessageResult</span>(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statistics</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 提交刷盘任务 task1</span></span><br><span class="line">    CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);</span><br><span class="line">    <span class="comment">// 提交master同步复制任务 task2</span></span><br><span class="line">    CompletableFuture&lt;PutMessageStatus&gt; replicaResultFuture = submitReplicaRequest(result, msg);</span><br><span class="line">    <span class="comment">// 只有task1和task2都完成，才会返回。</span></span><br><span class="line">    <span class="keyword">return</span> flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (flushStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">            putMessageResult.setPutMessageStatus(flushStatus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (replicaStatus != PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">            putMessageResult.setPutMessageStatus(replicaStatus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> putMessageResult;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是Borker接收消息的核心方法。整个方法的处理流程如下：</p>
<ol>
<li>Message body的crc校验码，防止消息内容被篡改和破坏</li>
<li>如果是延迟消息，则替换topic和queueId。</li>
<li>获取最新的commitlog文件，也就是MappedFile对象。</li>
<li>加锁，这里的加锁导致一个Broker同一时间内只能有一条线程处理消息，可以在broker中配置是可重入锁还是自旋锁(useReentrantLockWhenPutMessage )。默认是false，使用自旋锁。异步刷盘建议使用自旋锁，同步刷盘建议使用重入锁</li>
<li>把Message刷新到MappedFile的内存中（注意，这里没有刷屏）</li>
<li>第5部可能会不成功，因为这是commitlog文件不够空间放入Message了。这时RocketMq会在第3步获取到commitlog文件尾部加入8个字节的内容，分别为4个字节的这个文件的消息总大小，4个字节的magic code。接着会新建一个commitlog文件并获取该文件对应的MappedFile，把Message刷新到该文件的映射的内存中。也就是重复了3和5步的操作。</li>
<li>提交一个刷屏任务</li>
<li>提交一个master同步复制任务（主从）</li>
<li>7和8对应的任务都完成了之后返回。</li>
</ol>
<h4 id="把Message刷新到MappedFile的内存中"><a href="#把Message刷新到MappedFile的内存中" class="headerlink" title="把Message刷新到MappedFile的内存中"></a>把Message刷新到MappedFile的内存中</h4><p>这段代码对应的是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appedFile.appendMessage(msg, this.appendMessageCallback)</span><br></pre></td></tr></table></figure>

<p>其中<code>appendMessageCallback</code>是在CommitLog的构造方法中定义的</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729497.png" alt="image-20211118055028519"></p>
<p>看<code>MappedFile#appendMessage</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MappedFile#appendMessage -&gt;</span></span><br><span class="line"><span class="comment">//  MappedFile#appendMessagesInner</span></span><br><span class="line"><span class="keyword">public</span> AppendMessageResult <span class="title function_">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当前这个MaapedFile的写入位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentPos</span> <span class="operator">=</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="built_in">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">//异步输盘时还有两种刷盘模式可以选择</span></span><br><span class="line">        <span class="comment">//TODO 如果writeBuffer!= null开启了堆外内存缓冲，使用writeBuffer,否则使用mappedByteBuffer（也是继承的ByteBuffer）</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> writeBuffer != <span class="literal">null</span> ? writeBuffer.slice() : <span class="built_in">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            <span class="comment">//todo 非批量处理</span></span><br><span class="line">            result = cb.doAppend(<span class="built_in">this</span>.getFileFromOffset(), byteBuffer, <span class="built_in">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="built_in">this</span>.getFileFromOffset(), byteBuffer, <span class="built_in">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果文件不够空间的话，这里的result.getWroteBytes()会返回（this.fileSize - currentPos）的值，这个值就是剩余的空间</span></span><br><span class="line">        <span class="comment">// 这样设置后，就可以表示这个文件已经满了，因为isFull()方法成立了</span></span><br><span class="line">        <span class="comment">// 这时就需要新建一个文件了</span></span><br><span class="line">        <span class="built_in">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="built_in">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">&quot;MappedFile.appendMessage return null, wrotePosition: &#123;&#125; fileSize: &#123;&#125;&quot;</span>, currentPos, <span class="built_in">this</span>.fileSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的<code>slice</code>是ByteBuffer提供的api，作用是创建一个新的ByteBuffer。这个新的与旧的指向相同的字节数组。</p>
</blockquote>
<p>可以看到，最用是调用了cb.doAppend，这里就是把消息刷入内存的核心方法，其中cb就是<code>DefaultAppendMessageCallback</code>。下面列出daApend和核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断文件是否够空间写入，如果不够就会返回END_OF_FILE。表示需要新建一个文件，然后再写入</span></span><br><span class="line"><span class="comment">// 这里之所以要留下8个字节，是为了写入这个文件的总大小和结尾的MAGIC CODE</span></span><br><span class="line"><span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">    <span class="built_in">this</span>.resetByteBuffer(<span class="built_in">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">    <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">    <span class="comment">// 记录这个文件的消息总大小</span></span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">    <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">    <span class="comment">// 设置文件结尾的MAGIC CODE</span></span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">    <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">    <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginTimeMills</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.now();</span><br><span class="line">    byteBuffer.put(<span class="built_in">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">        queueOffset, CommitLog.<span class="built_in">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialization of storage space</span></span><br><span class="line"><span class="built_in">this</span>.resetByteBuffer(msgStoreItemMemory, msgLen);</span><br><span class="line"><span class="comment">// 1 TOTALSIZE</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgLen);</span><br><span class="line"><span class="comment">// 2 MAGICCODE</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);</span><br><span class="line"><span class="comment">// 3 BODYCRC</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgInner.getBodyCRC());</span><br><span class="line"><span class="comment">// 4 QUEUEID</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgInner.getQueueId());</span><br><span class="line"><span class="comment">// 5 FLAG</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgInner.getFlag());</span><br><span class="line"><span class="comment">// 6 QUEUEOFFSET</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putLong(queueOffset);</span><br><span class="line"><span class="comment">// 7 PHYSICALOFFSET</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putLong(fileFromOffset + byteBuffer.position());</span><br><span class="line"><span class="comment">// 8 SYSFLAG</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgInner.getSysFlag());</span><br><span class="line"><span class="comment">// 9 BORNTIMESTAMP</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());</span><br><span class="line"><span class="comment">// 10 BORNHOST</span></span><br><span class="line"><span class="built_in">this</span>.resetByteBuffer(bornHostHolder, bornHostLength);</span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.put(msgInner.getBornHostBytes(bornHostHolder));</span><br><span class="line"><span class="comment">// 11 STORETIMESTAMP</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());</span><br><span class="line"><span class="comment">// 12 STOREHOSTADDRESS</span></span><br><span class="line"><span class="built_in">this</span>.resetByteBuffer(storeHostHolder, storeHostLength);</span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.put(msgInner.getStoreHostBytes(storeHostHolder));</span><br><span class="line"><span class="comment">// 13 RECONSUMETIMES</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());</span><br><span class="line"><span class="comment">// 14 Prepared Transaction Offset</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());</span><br><span class="line"><span class="comment">// 15 BODY</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putInt(bodyLength);</span><br><span class="line"><span class="keyword">if</span> (bodyLength &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.put(msgInner.getBody());</span><br><span class="line"><span class="comment">// 16 TOPIC</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.put((<span class="type">byte</span>) topicLength);</span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.put(topicData);</span><br><span class="line"><span class="comment">// 17 PROPERTIES</span></span><br><span class="line"><span class="built_in">this</span>.msgStoreItemMemory.putShort((<span class="type">short</span>) propertiesLength);</span><br><span class="line"><span class="keyword">if</span> (propertiesLength &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">this</span>.msgStoreItemMemory.put(propertiesData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">beginTimeMills</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.now();</span><br><span class="line"><span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">byteBuffer.put(<span class="built_in">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppendMessageResult</span>(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line">    msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="built_in">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br></pre></td></tr></table></figure>

<p>可以看到，这里就体现了CommitLog的Message格式了。而且也说明了<code>asyncPutMessage</code>第6步中，的commitlog文件满了之后的处理逻辑。</p>
<h4 id="提交一个刷屏任务"><a href="#提交一个刷屏任务" class="headerlink" title="提交一个刷屏任务"></a>提交一个刷屏任务</h4><p>对应的代码是<code>submitFlushRequest</code>，这个方法很简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;PutMessageStatus&gt; <span class="title function_">submitFlushRequest</span><span class="params">(AppendMessageResult result, MessageExt messageExt)</span> &#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">GroupCommitService</span> <span class="variable">service</span> <span class="operator">=</span> (GroupCommitService) <span class="built_in">this</span>.flushCommitLogService;</span><br><span class="line">        <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line">            <span class="type">GroupCommitRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupCommitRequest</span>(result.getWroteOffset() + result.getWroteBytes(),</span><br><span class="line">                    <span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line">            service.putRequest(request);</span><br><span class="line">            <span class="keyword">return</span> request.future();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            service.wakeup();</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">            flushCommitLogService.wakeup();</span><br><span class="line">        &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">            commitLogService.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(PutMessageStatus.PUT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里有同步刷盘和异步刷盘，而且代码很简单。其实对于这两种刷盘方式，都是使用了其他线程来完成的。没错，在RocketMQ中，同步刷盘是异步的，而对比异步刷盘，不同点在于2</p>
<ol>
<li>刷盘的的时间间隔</li>
<li>刷盘时的数据量</li>
</ol>
<p>而刷盘的线程的处理逻辑就封装在<code>flushCommitLogService</code>变量中，这个变量的具体类型在CommitLog的构造函数中定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 同步刷盘</span></span><br><span class="line"><span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.flushCommitLogService = <span class="keyword">new</span> <span class="title class_">GroupCommitService</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//todo 异步刷盘</span></span><br><span class="line">    <span class="comment">//FlushRealTimeService线程默认每500ms将MappedByteBuffer中新追加的内存刷写到磁盘</span></span><br><span class="line">    <span class="built_in">this</span>.flushCommitLogService = <span class="keyword">new</span> <span class="title class_">FlushRealTimeService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面对这两种刷盘方式分析。</p>
<h5 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h5><p>对于这种方式，Message刷新到内存后，会往<code>GroupCommitService</code>线程中，放入一个任务类。而处理消息的方法需要等待这个任务处理完了，才会返回。所以，之后刷盘看刷盘的线程处理逻辑就好了。看处理的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GroupCommitService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">this</span>.doCommit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.swapRequests();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.doCommit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在RocketMq中，说用的线程都是继承了ServiceThread类，这个类是对Thread的进一步封装，作为RocketMq中的所用线程类的模版。</p>
<p>其中waitForRunning从方法名就可以知道，就是等待多久后启动。</p>
</blockquote>
<p>从上边可以看到， 没10毫秒执行一次同步刷盘。而处理刷的doComit源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GroupCommitService</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GroupCommitRequest req : <span class="built_in">this</span>.requestsRead) &#123;</span><br><span class="line">                <span class="comment">// There may be a message in the next file, so a maximum of</span></span><br><span class="line">                <span class="comment">// two times the flush</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flushOK</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                <span class="comment">//todo 这里因为消息可能跨文件（满了又生成了一个，所以这里要刷两次）</span></span><br><span class="line">                <span class="comment">// 可能需要刷盘两次，而需要刷盘两次的情况如下：</span></span><br><span class="line">                <span class="comment">// 文件的剩余空间小于消息的大小时，这时rocketMQ会新建一个文件用来写入消息，之前的文件就会标为已满了。</span></span><br><span class="line">                <span class="comment">// 在这种情况下，第一次就是把倒数第二个文件刷盘，</span></span><br><span class="line">                <span class="comment">// 这时刷入的内容只有8个字节的的大小，4个字节表示文件的消息总大小，4个自己为magic code。</span></span><br><span class="line">                <span class="comment">// 可以看MappedFile#appendMessagesInner --&gt; AppendMessageResult#doAppend。</span></span><br><span class="line">                <span class="comment">// 而第二次就是把新建的文件，越就是最后一个commitLog文件进行刷屏，这时刷的就是消息内容</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; !flushOK; i++) &#123;</span><br><span class="line">                    <span class="comment">//刷盘</span></span><br><span class="line">                    CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//todo 刷盘指针大于等于提交指针，代表刷盘成功</span></span><br><span class="line">                    flushOK = CommitLog.<span class="built_in">this</span>.mappedFileQueue.getFlushedWhere() &gt;= req.getNextOffset();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒发送消息客户端</span></span><br><span class="line">                req.wakeupCustomer(flushOK ? PutMessageStatus.PUT_OK : PutMessageStatus.FLUSH_DISK_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新刷盘监测点</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                CommitLog.<span class="built_in">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Because of individual messages is set to not sync flush, it</span></span><br><span class="line">            <span class="comment">// will come to this process</span></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷盘的逻辑最用都是会通过<code>mappedFileQueue</code>的<code>flush</code>方法，而这个方法的入参为0，为0就表示需要把整内存中的commitlog文件映射的内存中的全部脏页都刷新到硬盘。</p>
<p><code>mappedFileQueue#flush</code>方法会在找到需要刷盘的commitLog文件的抽象MappedFile，然后调用<code>MappedFile#flush</code>方法。而<code>MappedFile#flush</code>的方法在底层就调用<code>MappedByteBuffer#force</code>方法来强制刷盘。</p>
<blockquote>
<p>如果启用了堆外缓冲，那么就是<code>fileChannel#force</code></p>
</blockquote>
<h5 id="异步刷盘"><a href="#异步刷盘" class="headerlink" title="异步刷盘"></a>异步刷盘</h5><p>对于这种方式，wakeup()方法来唤醒线程，然后就直接放回一个了，处理消息的方法不需要等待刷盘完成，就可以返回了。现在看这个异步刷盘线程的处理逻辑。这个线程逻辑封装在<code>FlushRealTimeService</code>中。看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flushCommitLogTimed</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().isFlushCommitLogTimed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷盘延迟，默认500毫秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushIntervalCommitLog();</span><br><span class="line">        <span class="comment">// 刷盘的最少页数 默认是4</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flushPhysicQueueLeastPages</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogLeastPages();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两次刷盘的最大间隔,默认200ms，如果超过这个值就全部提交脏页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flushPhysicQueueThoroughInterval</span> <span class="operator">=</span></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushCommitLogThoroughInterval();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">printFlushProgress</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print flush progress</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="built_in">this</span>.lastFlushTimestamp + flushPhysicQueueThoroughInterval)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">            flushPhysicQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">            printFlushProgress = (printTimes++ % <span class="number">10</span>) == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 延迟</span></span><br><span class="line">            <span class="keyword">if</span> (flushCommitLogTimed) &#123;</span><br><span class="line">                Thread.sleep(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.waitForRunning(interval);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (printFlushProgress) &#123;</span><br><span class="line">                <span class="built_in">this</span>.printFlushProgress();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 刷盘</span></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(flushPhysicQueueLeastPages);</span><br><span class="line">            <span class="type">long</span> <span class="variable">storeTimestamp</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.getStoreTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (storeTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                CommitLog.<span class="built_in">this</span>.defaultMessageStore.getStoreCheckpoint().setPhysicMsgTimestamp(storeTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">past</span> <span class="operator">=</span> System.currentTimeMillis() - begin;</span><br><span class="line">            <span class="keyword">if</span> (past &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Flush data to disk costs &#123;&#125; ms&quot;</span>, past);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            CommitLog.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">            <span class="built_in">this</span>.printFlushProgress();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal shutdown, to ensure that all the flush before exit</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">        result = CommitLog.<span class="built_in">this</span>.mappedFileQueue.flush(<span class="number">0</span>);</span><br><span class="line">        CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service shutdown, retry &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; times &quot;</span> + (result ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;Not OK&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.printFlushProgress();</span><br><span class="line"></span><br><span class="line">    CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，异步刷盘是默认500毫秒执行一次。而且，刷盘的最少的脏页数要默认4个。</p>
<h5 id="开启了堆外缓冲区后的刷盘"><a href="#开启了堆外缓冲区后的刷盘" class="headerlink" title="开启了堆外缓冲区后的刷盘"></a>开启了堆外缓冲区后的刷盘</h5><p>开启异步刷盘的的的前提提交是在broker的配置文件中设置<code>transientStorePoolEnable=true</code>。</p>
<p>而且通过MessageStoreConfig&#96;的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTransientStorePoolEnable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//todo 开启堆外内存缓冲区，必须是异步刷盘+主节点</span></span><br><span class="line">    <span class="keyword">return</span> transientStorePoolEnable &amp;&amp; FlushDiskType.ASYNC_FLUSH == getFlushDiskType()</span><br><span class="line">        &amp;&amp; BrokerRole.SLAVE != getBrokerRole();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以开启堆外内存缓冲区，还需要是采用异步刷盘+Broker节点是master节点。</p>
<p>开启后，在创建MappedFile时会使用这个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedFile(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="type">int</span> fileSize, <span class="keyword">final</span> TransientStorePool transientStorePool)</span><br></pre></td></tr></table></figure>

<p>其中，TransientStorePool就是缓冲区池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientStorePool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;<span class="comment">//缓冲池数量 默认5个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> fileSize;<span class="comment">//每个ByteBuffer大小 默认是1G</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;ByteBuffer&gt; availableBuffers;<span class="comment">//ByteBuffer容器。双端队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageStoreConfig storeConfig;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransientStorePool</span><span class="params">(<span class="keyword">final</span> MessageStoreConfig storeConfig)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.storeConfig = storeConfig;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = storeConfig.getTransientStorePoolSize();</span><br><span class="line">        <span class="built_in">this</span>.fileSize = storeConfig.getMappedFileSizeCommitLog();</span><br><span class="line">        <span class="built_in">this</span>.availableBuffers = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * It&#x27;s a heavy init method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(fileSize);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> ((DirectBuffer) byteBuffer).address();</span><br><span class="line">            <span class="type">Pointer</span> <span class="variable">pointer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pointer</span>(address);</span><br><span class="line">            LibC.INSTANCE.mlock(pointer, <span class="keyword">new</span> <span class="title class_">NativeLong</span>(fileSize));</span><br><span class="line"></span><br><span class="line">            availableBuffers.offer(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  	<span class="comment">// 回收缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnBuffer</span><span class="params">(ByteBuffer byteBuffer)</span> &#123;</span><br><span class="line">        byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">        byteBuffer.limit(fileSize);</span><br><span class="line">        <span class="built_in">this</span>.availableBuffers.offerFirst(byteBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓存</span></span><br><span class="line">    <span class="keyword">public</span> ByteBuffer <span class="title function_">borrowBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> availableBuffers.pollFirst();</span><br><span class="line">        <span class="keyword">if</span> (availableBuffers.size() &lt; poolSize * <span class="number">0.4</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;TransientStorePool only remain &#123;&#125; sheets.&quot;</span>, availableBuffers.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在<code>CommitLog</code>中，除了开启了刷盘的线程外，还开启了一个提交线程，这个线程就是<code>CommitRealTimeService</code>。这个线程的代码其实和异步刷盘的逻辑很像，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="comment">//间隔时间,默认200ms</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitIntervalCommitLog();</span><br><span class="line">        <span class="comment">//一次提交的至少页数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">commitDataLeastPages</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogLeastPages();</span><br><span class="line">        <span class="comment">//两次真实提交的最大间隔,默认200ms</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">commitDataThoroughInterval</span> <span class="operator">=</span></span><br><span class="line">            CommitLog.<span class="built_in">this</span>.defaultMessageStore.getMessageStoreConfig().getCommitCommitLogThoroughInterval();</span><br><span class="line">        <span class="comment">//上次提交间隔超过commitDataThoroughInterval,则忽略提交commitDataThoroughInterval参数,直接提交</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= (<span class="built_in">this</span>.lastCommitTimestamp + commitDataThoroughInterval)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastCommitTimestamp = begin;</span><br><span class="line">            commitDataLeastPages = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行提交操作,将待提交数据提交到物理文件的内存映射区</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> CommitLog.<span class="built_in">this</span>.mappedFileQueue.commit(commitDataLeastPages);</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lastCommitTimestamp = end; <span class="comment">// result = false means some data committed.</span></span><br><span class="line">                <span class="comment">//now wake up flush thread.</span></span><br><span class="line">                flushCommitLogService.wakeup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end - begin &gt; <span class="number">500</span>) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Commit data to file costs &#123;&#125; ms&quot;</span>, end - begin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(interval);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            CommitLog.log.error(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; RETRY_TIMES_OVER &amp;&amp; !result; i++) &#123;</span><br><span class="line">        result = CommitLog.<span class="built_in">this</span>.mappedFileQueue.commit(<span class="number">0</span>);</span><br><span class="line">        CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service shutdown, retry &quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; times &quot;</span> + (result ? <span class="string">&quot;OK&quot;</span> : <span class="string">&quot;Not OK&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    CommitLog.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个线程的提交延迟是200，之后的代码都和异步刷盘线程的代码很像，但是在这个线程中调用的是<code>mappedFileQueue.commit</code>方法，也就是调用了<code>MappedFile.commit</code>方法。这个commit方法的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">commit</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> commitLeastPages)</span> &#123;</span><br><span class="line">    <span class="comment">//todo 没有开启堆外缓冲，则不用处理直接返回写地址即可</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//no need to commit data to file channel, so just regard wrotePosition as committedPosition.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isAbleToCommit(commitLeastPages)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.hold()) &#123;</span><br><span class="line">            <span class="comment">//todo 开启堆外缓冲，则需要先写到fileChannel中</span></span><br><span class="line">            commit0(commitLeastPages);</span><br><span class="line">            <span class="built_in">this</span>.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;in commit, hold failed, commit offset = &quot;</span> + <span class="built_in">this</span>.committedPosition.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All dirty data has been committed to FileChannel.</span></span><br><span class="line">    <span class="comment">// 当这个文件的都提交完成时</span></span><br><span class="line">    <span class="keyword">if</span> (writeBuffer != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.transientStorePool != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.fileSize == <span class="built_in">this</span>.committedPosition.get()) &#123;</span><br><span class="line">        <span class="comment">// 回收缓冲</span></span><br><span class="line">        <span class="built_in">this</span>.transientStorePool.returnBuffer(writeBuffer);</span><br><span class="line">        <span class="built_in">this</span>.writeBuffer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">commit0</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> commitLeastPages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">writePos</span> <span class="operator">=</span> <span class="built_in">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lastCommittedPosition</span> <span class="operator">=</span> <span class="built_in">this</span>.committedPosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (writePos - lastCommittedPosition &gt; commitLeastPages) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> writeBuffer.slice();</span><br><span class="line">            byteBuffer.position(lastCommittedPosition);</span><br><span class="line">            byteBuffer.limit(writePos);</span><br><span class="line">            <span class="built_in">this</span>.fileChannel.position(lastCommittedPosition);</span><br><span class="line">            <span class="comment">//写入文件</span></span><br><span class="line">            <span class="built_in">this</span>.fileChannel.write(byteBuffer);</span><br><span class="line">            <span class="built_in">this</span>.committedPosition.set(writePos);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Error occurred when commit data to FileChannel.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是把<code>writeBuffer</code>也就是堆外缓冲的内容写到fileChannel中。当这个文件的内容都提交完时，就会回收这个堆外缓冲。记住，这里只是写到fileChannel ，这是还未进行刷盘的。真正的刷盘还是要靠异步刷盘线程。在刷屏的<code>MappedFile.flush</code>方法中有这样的一行代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729498.png" alt="image-20211118074637233"></p>
<p>执行了这个行代码，才会把fileChannel这个通道的内容刷新到硬盘中。</p>
<p>所以，RocketMq中的堆外内存，先用来临时存储数据，数据先写入该内存映射中，然后 由 commit 线程定时将数据从该内存复制到与目标物理文件对应的内存映射中。</p>
<p>RocketMQ 引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。同时因为是堆外内存， 这么设计可以避免频繁的 GC</p>
<p>所以RocketMq开启了堆外内存后，消息发送就有两条线</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729499.png" alt="image-20211118074848891"></p>
<ol>
<li>走传统的 MMAP 内存映射，数据写 mappedByteBuffer，然后通过 flush 刷盘</li>
<li>走堆外内存缓冲区，数据先写 writeBuffer，再通过 commit 提交到 FileChannel 中，最后再 flush 刷盘</li>
</ol>
<p>以上两种方式，处理的都是基于 bytebuffer 的实现，所以都通过 put 方法可以写入内存</p>
<p>所以对应前面讲的刷盘。</p>
<p>你会发现为什么异步刷盘线程有两个。一个是强制刷盘，一个是把消息写到FileChannel。所以了堆外内存缓冲区一定是要异步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729500.png" alt="image-20211118075722240"></p>
<h5 id="堆外缓冲的好处"><a href="#堆外缓冲的好处" class="headerlink" title="堆外缓冲的好处"></a>堆外缓冲的好处</h5><p>RocketMQ 引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。同时因为是堆外内存， 这么设计可以避免频繁的 GC。</p>
<p>默认方式，Mmap+PageCache 的方式，读写消息都走的是 pageCache，这样子读写都在 pagecache 里面不可避免会有锁的问题，在并发的读写操 作情况下，会出现缺页中断降低，内存加锁，污染页的回写(脏页面)。</p>
<p>堆外缓冲区，DirectByteBuffer(堆外内存)+PageCache 的两层架构方式，这样子可以实现读写消息分离，写入消息时候写到的是 DirectByteBuffer ——堆外内存中,读消息走的是 PageCache(对于,DirectByteBuffer 是两步刷盘，一步是刷到 PageCache，还有一步是刷到磁盘文件中)，带来的好处就是，避 免了内存操作的很多容易堵的地方，降低了时延，比如说缺页中断降低，内存加锁，脏页的回写。</p>
<p>所以使用堆外缓冲区的方式相对来说会比较好，但是肯定的是，需要消耗一定的内存，如果服务器内存吃紧就不推荐这种模式，同时的话，堆外缓 冲区的话也需要配合异步刷盘才能使用。</p>
<h3 id="ConsumeQueue——逻辑队列的生成"><a href="#ConsumeQueue——逻辑队列的生成" class="headerlink" title="ConsumeQueue——逻辑队列的生成"></a>ConsumeQueue——逻辑队列的生成</h3><p>在消息进入到CommitLog后，接着就是生成逻辑队列了。生成逻辑队列ConsumeQueue，这个操作也是通过一个独立的线程来完成，这个线程是<code>ReputMessageService</code>，看这个类的逻辑:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReputMessageService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service started&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.doReput();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultMessageStore.log.info(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReput</span><span class="params">()</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">boolean</span> <span class="variable">doNext</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="built_in">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">            &amp;&amp; <span class="built_in">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="built_in">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主要是构建ConsumerQueue和Index</span></span><br><span class="line">        <span class="comment">//reputFromOffset:构建ConsumerQueue和Index的进度</span></span><br><span class="line">        <span class="type">SelectMappedBufferResult</span> <span class="variable">result</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                    <span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span></span><br><span class="line">                        DefaultMessageStore.<span class="built_in">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//todo  跳转到 CommitLogDispatcherBuildConsumeQueue.dispatch()方法</span></span><br><span class="line">                            DefaultMessageStore.<span class="built_in">this</span>.doDispatch(dispatchRequest);</span><br><span class="line">                            ......</span><br><span class="line">                            <span class="built_in">this</span>.reputFromOffset += size;</span><br><span class="line">                            readSize += size;</span><br><span class="line">                            ......</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.reputFromOffset = DefaultMessageStore.<span class="built_in">this</span>.commitLog.rollNextFile(<span class="built_in">this</span>.reputFromOffset);</span><br><span class="line">                            readSize = result.getSize();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                      .......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                result.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doNext = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个线程就是遍历commitlog，然后生成的逻辑都是委托给了<code>DefaultMessageStore</code>的<code>doDispatch</code>方法。看这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(DispatchRequest req)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (CommitLogDispatcher dispatcher : <span class="built_in">this</span>.dispatcherList) &#123;</span><br><span class="line">        dispatcher.dispatch(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>dispatcherList</code>的初始化如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.dispatcherList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildConsumeQueue</span>());</span><br><span class="line"><span class="built_in">this</span>.dispatcherList.addLast(<span class="keyword">new</span> <span class="title class_">CommitLogDispatcherBuildIndex</span>());</span><br></pre></td></tr></table></figure>

<p>其中<code>CommitLogDispatcherBuildIndex</code>是用来构建index文件的。这个不是我们关注的。我们看<code>CommitLogDispatcherBuildConsumeQueue</code>的<code>dispatch</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(DispatchRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">    <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">            <span class="comment">//todo 构建供消费端使用的逻辑队列数据</span></span><br><span class="line">            DefaultMessageStore.<span class="built_in">this</span>.putMessagePositionInfo(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>。。。。最终还是回到了<code>DefaultMessageStore</code>的<code>putMessagePositionInfo</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> &#123;</span><br><span class="line">    <span class="type">ConsumeQueue</span> <span class="variable">cq</span> <span class="operator">=</span> <span class="built_in">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，后面的代码就不更了，<code>findConsumeQueue</code>就是更具topic和queueId获取到对应的<code>ConsumeQueue</code>，然后执行<code>ConsumeQueue#putMessagePositionInfoWrapper</code>，该方法的逻辑其实就做了两件事，就是将消息在commitlog的偏移量、消息的大小和tag的hashCode写入到内存。</p>
<h4 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h4><p>ConsumeQueue也涉及到刷盘，刷盘是通过<code>FlushConsumeQueueService</code>线程完成的。源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//默认值1s</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getFlushIntervalConsumeQueue();</span><br><span class="line">            <span class="built_in">this</span>.waitForRunning(interval);</span><br><span class="line">            <span class="built_in">this</span>.doFlush(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            DefaultMessageStore.log.warn(<span class="built_in">this</span>.getServiceName() + <span class="string">&quot; service has exception. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.doFlush(RETRY_TIMES_OVER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，默认1s刷盘。接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo ConsumeQueue的独立刷盘</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doFlush</span><span class="params">(<span class="type">int</span> retryTimes)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flushConsumeQueueLeastPages</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getFlushConsumeQueueLeastPages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retryTimes == RETRY_TIMES_OVER) &#123;</span><br><span class="line">        flushConsumeQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">logicsMsgTimestamp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">flushConsumeQueueThoroughInterval</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getFlushConsumeQueueThoroughInterval();</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTimeMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (currentTimeMillis &gt;= (<span class="built_in">this</span>.lastFlushTimestamp + flushConsumeQueueThoroughInterval)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastFlushTimestamp = currentTimeMillis;</span><br><span class="line">        flushConsumeQueueLeastPages = <span class="number">0</span>;</span><br><span class="line">        logicsMsgTimestamp = DefaultMessageStore.<span class="built_in">this</span>.getStoreCheckpoint().getLogicsMsgTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ConsumeQueue&gt;&gt; tables = DefaultMessageStore.<span class="built_in">this</span>.consumeQueueTable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ConcurrentMap&lt;Integer, ConsumeQueue&gt; maps : tables.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumeQueue cq : maps.values()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; retryTimes &amp;&amp; !result; i++) &#123;</span><br><span class="line">                result = cq.flush(flushConsumeQueueLeastPages);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == flushConsumeQueueLeastPages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logicsMsgTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="built_in">this</span>.getStoreCheckpoint().setLogicsMsgTimestamp(logicsMsgTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        DefaultMessageStore.<span class="built_in">this</span>.getStoreCheckpoint().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这个方法也没什么好说的了，但有一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultMessageStore.<span class="built_in">this</span>.getStoreCheckpoint().flush();</span><br></pre></td></tr></table></figure>

<p>这里行代码就是调用<code>StoreCheckpoint</code>的flush方法，也就是触发checkpoint文件的刷盘操作。这个类的里面的三个变量都在更新逻辑队列内存的时候就设置了。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/rocketmq/5575707863509729501.png" alt="image-20211118083831758"></p>
<p>连续发送 5 条消息，消息是不定长，首先所有信息先放入 Commitlog 中，每一条消息放入 Commitlog 的时候都需要上锁，确保顺序的写入。当 Commitlog 写成功了之后。数据再同步到 ConsunmeQueue 中。并且数据一条条分发，这个是一个典型的轮训。</p>
<p>Queue Offset 代表一个 Queue 中的第几条消息</p>
<p>Logic Offset 就是 Queue Offset*20 因为每一条 ConsumeQueue 中的消息长度都是 20</p>
<p>Physical Offset,这个是在 Commitlog 中每一条消息偏移量。</p>
<p>这种设计非常的巧妙，</p>
<p>查找消息的时候，可以直按根据队列的消息序号，计算出索引的全局位置(比如序号 2，就知道偏移量是 20)，然后直接读取这条索引，再根据索 引中记录的消息的全局位置，找到消息、这里面比较耗时两个操作就是分别找到索引和消息所在文件，这两次查找是差不多的，都可以抽象成:</p>
<p>因为每个索引文件或者消息文件的长度的是固定的，对于每一组文件，都维护了一个由小到大有序的文件数组。查找文件的时候，直接通过计算即 可获取文件在数组中的序号:</p>
<p>文件在数组中的序号&#x3D;(全局位置-第一个文件的文件名)&#x2F;文件固定大小</p>
<p>在通过序号在数组中获取数据的时间复杂度是 0(1)，二次查找文件的时间复杂度也是是:0(1)+0(1) &#x3D;0 (1)，所以消费时查找数据的时间复杂度也是 O(1)。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nbobj.github.io/blog/rocketmq/02Store%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90md/">https://nbobj.github.io/blog/rocketmq/02Store源码分析md/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nbobj.github.io" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/rocketmq/">rocketmq</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/rocketmq/03%E6%B6%88%E6%81%AF/">03消息</a><a class="next" href="/blog/rocketmq/01NameServer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">01NameServer源码分析</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">消息存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text">存储文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitLog%E4%B9%8BMessage%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">CommitLog之Message格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Store%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">4.</span> <span class="toc-text">Store服务的启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Store%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">Store架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF%E2%80%94%E2%80%94commitlog%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">接收消息——commitlog的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8AMessage%E5%88%B7%E6%96%B0%E5%88%B0MappedFile%E7%9A%84%E5%86%85%E5%AD%98%E4%B8%AD"><span class="toc-number">6.1.1.</span> <span class="toc-text">把Message刷新到MappedFile的内存中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%B8%80%E4%B8%AA%E5%88%B7%E5%B1%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.1.2.</span> <span class="toc-text">提交一个刷屏任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">同步刷盘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%88%B7%E7%9B%98"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">异步刷盘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%86%E5%A0%86%E5%A4%96%E7%BC%93%E5%86%B2%E5%8C%BA%E5%90%8E%E7%9A%84%E5%88%B7%E7%9B%98"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">开启了堆外缓冲区后的刷盘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E5%A4%96%E7%BC%93%E5%86%B2%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">堆外缓冲的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConsumeQueue%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E9%98%9F%E5%88%97%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">ConsumeQueue——逻辑队列的生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E7%9B%98"><span class="toc-number">6.2.1.</span> <span class="toc-text">刷盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/broker%E5%90%AF%E5%8A%A8/" title="broker启动">broker启动</a><time datetime="2022-01-14T00:00:16.000Z" title="发表于 2022-01-14 08:00:16">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/13%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4/" title="13消息过滤">13消息过滤</a><time datetime="2022-01-14T00:00:15.000Z" title="发表于 2022-01-14 08:00:15">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/12broker%E5%A4%84%E7%90%86Consumer%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82/" title="12broker处理Consumer拉取消息请求">12broker处理Consumer拉取消息请求</a><time datetime="2022-01-14T00:00:14.000Z" title="发表于 2022-01-14 08:00:14">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/11%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="11消费者的负载均衡">11消费者的负载均衡</a><time datetime="2022-01-14T00:00:13.000Z" title="发表于 2022-01-14 08:00:13">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/10DefaultMQPushConsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="10DefaultMQPushConsumer源码分析">10DefaultMQPushConsumer源码分析</a><time datetime="2022-01-14T00:00:12.000Z" title="发表于 2022-01-14 08:00:12">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(#0062be)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>