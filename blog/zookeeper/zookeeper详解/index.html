<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>zookeeper详解 | XYZhi's学习笔记</title><meta name="keywords" content="zookeeper"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分布式架构从集中式到分布式所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。也就是说，在集中式系统中，每个终端或客户端机器仅仅负责数据的录人和输出，而数据的存储与控制处理完全交由主机来完成。 分布式的特点分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息">
<meta property="og:type" content="article">
<meta property="og:title" content="zookeeper详解">
<meta property="og:url" content="http://sv.pointcut.cc/blog/zookeeper/zookeeper%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="分布式架构从集中式到分布式所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。也就是说，在集中式系统中，每个终端或客户端机器仅仅负责数据的录人和输出，而数据的存储与控制处理完全交由主机来完成。 分布式的特点分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sv.pointcut.cc/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)">
<meta property="article:published_time" content="2021-11-14T02:00:10.000Z">
<meta property="article:modified_time" content="2022-03-23T09:33:51.082Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sv.pointcut.cc/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://sv.pointcut.cc/blog/zookeeper/zookeeper%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'zookeeper详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 17:33:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">301</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">zookeeper详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-14T02:00:10.000Z" title="发表于 2021-11-14 10:00:10">2021-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T09:33:51.082Z" title="更新于 2022-03-23 17:33:51">2022-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="zookeeper详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><h3 id="从集中式到分布式"><a href="#从集中式到分布式" class="headerlink" title="从集中式到分布式"></a>从集中式到分布式</h3><p>所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。也就是说，在集中式系统中，每个终端或客户端机器仅仅负责数据的录人和输出，而数据的存储与控制处理完全交由主机来完成。</p>
<h3 id="分布式的特点"><a href="#分布式的特点" class="headerlink" title="分布式的特点"></a>分布式的特点</h3><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
<p>分布式架构都会有如下几个特征：</p>
<ul>
<li><p>分布性<br>分布式系统中的多台计算机都会在空间上随意分布，同时，机器的分布情况也会随时变动。</p>
</li>
<li><p>对等性</p>
<p>分布式系统中的计算机没有主&#x2F;从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。</p>
<p>副本( Replica)是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。</p>
<p>在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。</p>
<p>数据副本是指在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，这是解决分布式系统数据丢失问题最为有效的手段。</p>
<p>另一类副本是服务副本，指多个节点提供同样的服务，毎个节点都有能力接收来自外部的请求并进行相应的处理。</p>
</li>
<li><p>并发性</p>
<p>在一个计算机网络中，程序运行过程中的并发性操作是非常常见的行为，例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之</p>
</li>
<li><p>缺乏全局时钟</p>
</li>
<li><p>故障总是会发生</p>
<p>组成分布式系统的所有计算机，都有可能发生任何形式的故障。一个被大量工程实践所检验过的黄金定理是：任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生，并且，在系统实际运行过程中还会遇到很多在设计时未能考虑到的异常故障。所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</p>
</li>
</ul>
<h3 id="分布式环境的各种问题"><a href="#分布式环境的各种问题" class="headerlink" title="分布式环境的各种问题"></a>分布式环境的各种问题</h3><ul>
<li><p>通信异常<br>从集中式向分布式演变的过程中，必然引入了网络因素，而由于网络本身的不可靠性， 因此也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险。</p>
</li>
<li><p>网络分区<br>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够进行正常通信，而另一些节点则不能一一我们将这个现象称为网络分区，就是俗称的“脑裂”。当网络分区出现时， 分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统オ能完成的功能，包括对数据的事务处理，这就对分布式一致性提出了非常大的挑战。</p>
</li>
<li><p>三态<br>从上面的介绍中，我们已经了解到了在分布式环境下，网络可能会出现各式各样的问题， 因此分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。</p>
<ol>
<li>由于网络原因，该请求(消息)并没有被成功地发送到接收方，而是在发送过程就发生了消息丢失现象。</li>
<li>该请求(消息)成功的被接收方接收后，并进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。</li>
</ol>
<p>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的。</p>
</li>
<li><p>节点故障<br>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或“僵死”现象。</p>
</li>
</ul>
<h3 id="从ACID-到-CAP-x2F-BASE"><a href="#从ACID-到-CAP-x2F-BASE" class="headerlink" title="从ACID 到 CAP&#x2F;BASE"></a>从ACID 到 CAP&#x2F;BASE</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元（Unit），狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时数据库即使在宕机了数据仍然存在。<br>事务具有四个特征，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称为事务的ACID特性。<br>其中，原子性（Atomicity）、隔离性（Isolation）和持久性（Durability）是因，一致性（Consistency）是果。AID都是为了保证C而采用的方法。</p>
<ul>
<li><p>原子性</p>
<p>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。<br>· 全部成功执行。<br>· 全部不执行。<br>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
</li>
<li><p>一致性</p>
<p>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库只包含成功事务提交的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p>
</li>
<li><p>隔离性</p>
<p>事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>在标准 SQL 规范中，定义了 4 个事务隔离级别，不同的隔离级别对事务的处理不同，如包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>READ UNCOMMITTED</code></td>
<td align="center">Possible</td>
<td align="center">Possible</td>
<td align="center">Possible</td>
</tr>
<tr>
<td align="center"><code>READ COMMITTED</code></td>
<td align="center">Not Possible</td>
<td align="center">Possible</td>
<td align="center">Possible</td>
</tr>
<tr>
<td align="center"><code>REPEATABLE READ</code></td>
<td align="center">Not Possible</td>
<td align="center">Not Possible</td>
<td align="center">Possible</td>
</tr>
<tr>
<td align="center"><code>SERIALIZABLE</code></td>
<td align="center">Not Possible</td>
<td align="center">Not Possible</td>
<td align="center">Not Possible</td>
</tr>
</tbody></table>
</li>
<li><p>持久性</p>
<p>事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p>
</li>
</ul>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>CAP理论是分布式计算领域的公认定理。</p>
<p>CAP理论告诉我们，一个分布式系统不可能同时满足一致性(C： Consistency)、可用性(A： Availability)和分区容错性(P： Partition tolerance)这三个基本需求，最多只能同时满足其中的两项。</p>
<ul>
<li><p>一致性(C： Consistency)</p>
<p>在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</p>
<p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。</p>
</li>
<li><p>可用性(A： Availability)</p>
<p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。这里我们重点看下“有限的时间内”和“返回结果”。</p>
<p>“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间（即响应时间）内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。另外，“有限的时间内”是一个在系统设计之初就设定好的系统运行指标，通常不同的系统之间会有很大的不同。</p>
<p>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，即成功或失败</p>
</li>
<li><p>分区容错性(P： Partition tolerance)</p>
<p>分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p>
</li>
</ul>
<p>既然在上文中我们提到，一个分布式系统无法同时满足上述三个需求，而只能满足其中的两项，因此在进行对CAP定理的应用时，我们就需要抛弃其中的一项.</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354208.png" alt="image-20211123034816967"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354209.jpg" alt="a298"></p>
<p>从CAP定理中我们可以看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求。另一方面，需要明确的一点是，对于一个分布式系统而言，分区容错性可以说是一个最基本的要求。为什么这样说，其实很简单，因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在C(一致性)和A(可用性)之间寻求平衡</p>
<blockquote>
<p>如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是 A 又不允许，所以分布式系统理论上 不可能选择 <strong>CA</strong> 架构，只能选择 <strong>CP</strong> 或者 <strong>AP</strong> 架构。</p>
</blockquote>
<h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>BASE是 Basically Available(基本可用)、Soft state(软状态)和  ()</p>
<p>BASE是对CAP中一致性和可用性权衡的结果，其来源于大规模互联网分布式实践的总结。</p>
<p>其核心思想是即使无法做到强一致性( Strong consistency)，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性( Eventual consistency)。</p>
<ul>
<li><p>基本可用（ Basically Available）</p>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。以下两个就是“基本可用”的典型例子。</p>
<ol>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1～2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ol>
</li>
<li><p>软状态（Soft state）</p>
<p>软状态和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
</li>
<li><p>最终一致性（Eventually consistent）</p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>在现代关系型数据库中，大多都会采用同步和异步方式来实现主备数据复制技术。而对于异步模式，数据库还是能够保证最终数据达到一致——这就是系统提供最终一致性保证的经典案例。</p>
</blockquote>
</li>
</ul>
<p>总的来说，BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID特性是相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。</p>
<h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>2PC，是Two-Phase Commit的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够&#x3D;&#x3D;保持原子性和一致性而设计的一种算法&#x3D;&#x3D;。通常，二阶段提交协议也被认为是一种一致性协议，用来保证分布式系统数据的一致性。目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的（XA协议），利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据一致性，因此二阶段提交协议被广泛地应用在许多分布式系统中。</p>
<h4 id="阶段一：提交事务请求"><a href="#阶段一：提交事务请求" class="headerlink" title="阶段一：提交事务请求"></a>阶段一：提交事务请求</h4><ol>
<li><p>事务询问。</p>
<p>协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>执行事务。</p>
<p>各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应。</p>
<p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。</p>
</li>
</ol>
<p>由于上面讲述的内容在形式上近似是协调者组织各参与者对一次事务操作的投票表态过程，因此二阶段提交协议的阶段一也被称为“投票阶段”，即各参与者投票表明是否要继续执行接下去的事务提交操作。</p>
<h4 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h4><p>在阶段二中，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。</p>
<ul>
<li><p>执行事务提交</p>
<p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务提交。</p>
<ol>
<li><p>发送提交请求</p>
<p>协调者向所有参与者节点发出Commit请求。</p>
</li>
<li><p>事务提交</p>
<p>参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</p>
</li>
<li><p>反馈事务提交结果</p>
<p>参与者在完成事务提交之后，向协调者发送Ack消息。</p>
</li>
<li><p>完成事务</p>
<p>协调者接收到所有参与者反馈的Ack消息后，完成事务。</p>
</li>
</ol>
</li>
<li><p>中断事务</p>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li>发送回滚请求。<br> 协调者向所有参与者节点发出Rollback请求。</li>
<li>事务回滚。<br> 参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li>
<li>反馈事务回滚结果。<br> 参与者在完成事务回滚之后，向协调者发送Ack消息。</li>
<li>中断事务。<br> 协调者接收到所有参与者反馈的Ack消息后，完成事务中断。</li>
</ol>
</li>
</ul>
<p>以上就是二阶段提交过程中，前后两个阶段分别进行的处理逻辑。简单地讲，二阶段提交将一个事务的处理过程分为了投票和执行两个阶段，其核心是对每个事务都采用先尝试后提交的处理方式，因此也可以将二阶段提交看作一个强一致性的算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354210.png" alt="image-20211123041512609"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354211.png" alt="image-20211123041606765"></p>
<h4 id="2PC优缺点"><a href="#2PC优缺点" class="headerlink" title="2PC优缺点"></a>2PC优缺点</h4><p>二阶段提交协议的优点：原理简单，实现方便。<br>二阶段提交协议的缺点：同步阻塞、单点问题、脑裂、太过保守。</p>
<ul>
<li><p>同步阻塞</p>
<p>二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。</p>
</li>
<li><p>单点问题</p>
<p>协调者的角色在整个二阶段提交协议中起到了非常重要的作用。一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。（具体的实现会添加参与者超时处理）</p>
</li>
<li><p>数据不一致</p>
<p>在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了Commit请求。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致性现象。</p>
</li>
<li><p>太过保守</p>
<p>二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</p>
</li>
</ul>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>3PC，是 Three-Phase Commit的缩写，即三阶段提交，是2PC的改进版，其将二阶段提交协议的“提交事务请求（阶段一）”过程一分为二，形成了由 CanCommit、Precommit和 doCommit 三个阶段组成的事务处理协议</p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<p>  1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>  2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354212.jpg" alt="a402"></p>
<h4 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h4><ol>
<li><p>事务询问。</p>
<p>协调者向所有的参与者发送一个包含事务内容的 canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应。</p>
<p>参与者在接收到来自协调者的 canCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。</p>
</li>
</ol>
<h4 id="阶段二：Precommit"><a href="#阶段二：Precommit" class="headerlink" title="阶段二：Precommit"></a>阶段二：Precommit</h4><p>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况下，包含两种可能。</p>
<ul>
<li><p>执行事务预提交</p>
<p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。</p>
<ol>
<li><p>发送预提交请求。</p>
<p>协调者向所有参与者节点发出preCommit的请求，并进入Prepared阶段。</p>
</li>
<li><p>事务预提交。</p>
<p>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</p>
</li>
<li><p>各参与者向协调者反馈事务执行的响应。</p>
<p>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令：提交（commit）或中止（abort）。</p>
</li>
</ol>
</li>
<li><p>中断事务</p>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li><p>发送中断请求。</p>
<p>协调者向所有参与者节点发出abort请求。</p>
</li>
<li><p>中断事务。</p>
<p>无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</p>
</li>
</ol>
</li>
</ul>
<h4 id="阶段三：doCommit"><a href="#阶段三：doCommit" class="headerlink" title="阶段三：doCommit"></a>阶段三：doCommit</h4><p>和2PC的阶段二一样。但是对2PC的第二阶段做了优化。在2PC中的第二阶段中，如果协调者出现宕机了，参与者会一直等待下去。而在3PC中，无论协调者出现问题，还是协调者和参与者之间的网络出现故障，最终都会导致参与者无法及时接收到来自协调者的doCommit或是abort请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>三阶段提交协议的优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。（参与者超时就回滚）</p>
<p>三阶段提交协议的缺点：三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性（部分节点由于无法及时接收到来自协调者的doCommit或是abort请求，而后会继续执行事务提交；部分节点接收到了调者的abort请求，而事务回滚）。</p>
<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p>Paxos算法是一种基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。</p>
<p>之前已经提到，在常见的分布式系统中，总会发生诸如机器宕机或网络异常等情况。Paxos算法需要解决的问题就是如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<p>在该一致性算法中，有三种参与角色，我们用 Proposer、Acceptor 和 Learner 来表示。而且提案是由编号和 Value 组成的组合体，因此我们以“[编号，Value]”来表示一个提案。</p>
<h4 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h4><ul>
<li><p>阶段一</p>
<ol>
<li>Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的子集成员发送编号为Mn的Prepare请求。</li>
<li>如果一个Acceptor收到一个编号为Mn的Prepare请求，且编号Mn大于该Acceptor已经响应的所有 Prepare 请求的编号，那么它就会将它已经批准过的最大编号的提案作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案</li>
</ol>
<p>举个例子来说，假定一个Acceptor已经响应过的所有Prepare请求对应的提案编号分别为 1、2、…、5和 7，那么该Acceptor在接收到一个编号为 8的 Prepare请求后，就会将编号为7的提案作为响应反馈给Proposer。</p>
</li>
<li><p>阶段二</p>
<ol>
<li>如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的响应，那么它就会发送一个针对[Mn，Vn]提案的Accept请求给Acceptor。注意，Vn的值就是收到的响应中编号最大的提案的值，如果响应中不包含任何提案，那么它就是任意值。</li>
<li>如果Acceptor收到这个针对[Mn，Vn]提案的Accept请求，只要该Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案。最终，Acceptor会将通过的提案通知leader。</li>
</ol>
<p>当然，在实际运行过程中，每一个 Proposer 都有可能会产生多个提案，但只要每个Proposer都遵循如上所述的算法运行，就一定能够保证算法执行的正确性。值得一提的是，每个Proposer都可以在任意时刻丢弃一个提案，哪怕针对该提案的请求和响应在提案被丢弃后会到达，但根据Paxos算法的一系列规约，依然可以保证其在提案选定上的正确性。事实上，如果某个Proposer已经在试图生成编号更大的提案，那么丢弃一些旧的提案未尝不是一个好的选择。因此，如果一个 Acceptor 因为已经收到过更大编号的Prepare请求而忽略某个编号更小的Prepare或者Accept请求，那么它也应当通知其对应的Proposer，以便该Proposer也能够将该提案进行丢弃。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354213.png" alt="image-20210220202718278"></p>
<h4 id="提案的获取"><a href="#提案的获取" class="headerlink" title="提案的获取"></a>提案的获取</h4><p>上边就是一个提案的选定，下面我们再来看看如何让 Learner 获取提案，大体可以有以下几种方案。</p>
<ul>
<li><p>方案一</p>
<p>Learner 获取一个已经被选定的提案的前提是，该提案已经被半数以上的 Acceptor批准。因此，最简单的做法就是一旦Acceptor批准了一个提案，就将该提案发送给所有的Learner。</p>
<p>很显然，这种做法虽然可以让Learner尽快地获取被选定的提案，但是却需要让每个Acceptor与所有的Learner逐个进行一次通信，通信的次数至少为二者个数的乘积。</p>
</li>
<li><p>方案二</p>
<p>另一种可行的方案是，我们可以让所有的Acceptor将它们对提案的批准情况，统一发送给一个特定的 Learner（下文中我们将这样的 Learner 称为“主 Learner”），在不考<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98/265656?fr=aladdin">拜占庭将军问题</a>的前提下，我们假定Learner之间可以通过消息通信来互相感知提案的选定情况。基于这样的前提，当主Learner被通知一个提案已经被选定时，它会负责通知其他的Learner。</p>
<p>在这种方案中，Acceptor首先会将得到批准的提案发送给主 Learner，再由其同步给其他 Learner，因此较方案一而言，方案二虽然需要多一个步骤才能将提案通知到所有的 Learner，但其通信次数却大大减少了，通常只是 Acceptor 和Learner 的个数总和。但同时，该方案引入了一个新的不稳定因素：主 Learner随时可能出现故障。</p>
</li>
<li><p>方案三</p>
<p>在讲解方案二的时候，我们提到，方案二最大的问题在于主 Learner存在单点问题，即主 Learner随时可能出现故障。因此，对方案二进行改进，可以将主 Learner的范围扩大，即 Acceptor 可以将批准的提案发送给一个特定的 Learner 集合，该集合中的每个 Learner 都可以在一个提案被选定后通知所有其他的 Learner。这个 Learner集合中的 Learner个数越多，可靠性就越好，但同时网络通信的复杂度也就越高。</p>
</li>
</ul>
<h4 id="通过选取主Proposer保证算法的活性"><a href="#通过选取主Proposer保证算法的活性" class="headerlink" title="通过选取主Proposer保证算法的活性"></a>通过选取主Proposer保证算法的活性</h4><p>假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的议案，但是最终都无法被选定，具体流程如下：</p>
<p>Proposer P1提出了一个编号为M1的提案，并完成了上述阶段一的流程。但与此同时，另外一个Proposer P2提出了一个编号为M2（M2＞M1）的提案，同样也完成了阶段一的流程，于是Acceptor已经承诺不再批准编号小于M2的提案了。因此，当P1进入阶段二的时候，其发出的Accept请求将被Acceptor忽略，于是 P1再次进入阶段一并提出了一个编号为 M3（M3＞M2）的提案，而这又导致P2在第二阶段的Accept请求被忽略，以此类推，提案的选定过程将陷入死循环，如图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354214.png" alt="image-20211123051821184"></p>
<p>为了保证 Paxos 算法流程的可持续性，以避免陷入上述提到的“死循环”，就必须选择一个主Proposer，并规定只有主Proposer才能提出议案。这样一来，只要主Proposer和过半的Acceptor能够正常进行网络通信，那么但凡主Proposer提出一个编号更高的提案，该提案终将会被批准。当然，如果Proposer发现当前算法流程中已经有一个编号更大的提案被提出或正在接受批准，那么它会丢弃当前这个编号较小的提案，并最终能够选出一个编号足够大的提案。因此，如果系统中有足够多的组件（包括 Proposer、Acceptor和其他网络通信组件）能够正常工作，那么通过选择一个主Proposer，整套Paxos算法流程就能够保持活性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们主要从协议设计和原理实现角度详细讲解了二阶段提交协议、三阶段提交协议和Paxos这三种典型的一致性算法。可以说，这三种一致性协议都是非常优秀的分布式一致性协议，都从不同方面不同程度地解决了分布式数据一致性问题，使用范围都非常广泛。其中二阶段提交协议解决了分布式事务的原子性问题，保证了分布式事务的多个参与者要么都执行成功，要么都执行失败。但是，在二阶段解决部分分布式事务问题的同时，依然存在一些难以解决的诸如同步阻塞、无限期等待和“脑裂”等问题。三阶段提交协议则是在二阶段提交协议的基础上，添加了PreCommit过程和超时提交事务，从而避免了二阶段提交协议中的无限期等待问题。而Paxos算法引入了“过半”的理念，通俗地讲就是少数服从多数的原则。同时，Paxos 算法支持分布式节点角色之间的轮换，这极大地避免了分布式单点的出现，因此Paxos算法既解决了无限期等待问题，也解决了“脑裂”问题，是目前来说最优秀的分布式一致性协议之一。</p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>ZooKeeper是一个开放源代码的分布式协调服务，由知名互联网公司雅虎创建，是Google Chubby的开源实现。ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<p>ZooKeeper 是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。ZooKeeper可以保证如下分布式一致性特性。</p>
<ul>
<li><p>顺序一致性</p>
<p>从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到ZooKeeper中去。</p>
</li>
<li><p>原子性</p>
<p>所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群所有机器都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</p>
</li>
<li><p>单一视图（Single System Image）</p>
<p>无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</p>
</li>
<li><p>可靠性</p>
<p> 一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
</li>
<li><p>实时性</p>
<p>通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</p>
</li>
</ul>
<h3 id="Zookeeper的基本概念"><a href="#Zookeeper的基本概念" class="headerlink" title="Zookeeper的基本概念"></a>Zookeeper的基本概念</h3><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h4><p>通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式就是 Master&#x2F;Slave 模式（主备模式）。在这种模式中，我们把能够处理所有写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器称为Slave机器。</p>
<p>在ZooKeeper中引入了 Leader、Follower和 Observer三种角色。ZooKeeper集群中的所有机器通过一个<code>Leader</code>选举过程来选定一台被称为“ Leader”的机器， <code>Leader</code>服务器为客户端提供读和写服务。除 <code>Leader</code>外，其他机器就是 <code>Follower</code>和 <code>Observer</code>其中一个角色。 <code>Follower</code>和 <code>Observer</code>只能够提供读服务，唯一的区别在于， Observer机器不参与 Leader选举过程，也不参与写操作的“过半写成功”策略，因此 Observer可以在不影响写性能的情况下提升集群的读性能。</p>
<h4 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话( Session)"></a>会话( Session)</h4><p>Session是指客户端会话，在讲解会话之前，我们首先来了解一下容户端连接。在Zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。ZooKeeper对外的服务端口默认是2181，客户端启动的时候，首先会与服务器建立一个TCP连接， 从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向ZooKeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watch事件通知。 Session的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<h4 id="数据节点-Znode"><a href="#数据节点-Znode" class="headerlink" title="数据节点( Znode)"></a>数据节点( Znode)</h4><p>在ZooKeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点 ZNode。 Zookeeper 将所有数据存储在内存中，数据模型是一棵树( Znode Tree)，由斜杠(&#x2F;)进行分割的路径，就是一个 Znode，例如&#x2F;foo&#x2F;pahl。每个 Znode上都会保存自己的数据内容，同时还会保存一系列属性信息</p>
<p>在 Zookeeper中， Znode可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个 Znode被创建了，除非主动进行 Znode的移除操作，否则这个 Znode将一直保存在ZooKeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性： SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候， ZooKeeper会自动在其节点名后面追加上一个整型数字， 这个整型数字是一个由父节点维护的自增数字。</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>在前面我们已经提到ZooKeeper的每个 Znode上都会存储数据，对应于每个 Znode， ZooKeeper都会为其维护一个叫作Stat的数据结构，Stat中记录了这个 Znode的三个数据版本，分别是 version(当前 Znode的版本)、cversion(当前 Znode子节点的版本) 和 aversion(当前 Znode的ACL版本)。</p>
<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>Watcher(事件监听器)，是 Zookeeper中的一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p>
<h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>ZooKeeper采用ACL（Access Control Lists）策略来进行权限控制，类似于UNIX文件系统的权限控制。ZooKeeper定义了如下5种权限。</p>
<ul>
<li>CREATE：创建子节点的权限。</li>
<li>READ：获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE：删除子节点的权限。</li>
<li>ADMIN：设置节点ACL的权限。</li>
</ul>
<h3 id="ZooKeeper的ZAB协议"><a href="#ZooKeeper的ZAB协议" class="headerlink" title="ZooKeeper的ZAB协议"></a>ZooKeeper的ZAB协议</h3><p>ZooKeeper 并没有直接采用 Paxos 算法，而是采用了一种被称为 ZAB （ZooKeeper Atomic Broadcast）的一致性协议。ZAB协议是为分布式协调服务ZookKeeper专门设计的一种支持崩溃恢复的原子广播协议。</p>
<p>ZAB协议要求，所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader服务器，而余下的其他服务器则成为 Follower 服务器。Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal（提议），并将该 Proposal 分发给集群中所有的Follower 服务器。之后 Leader 服务器需要等待所有 Follower 服务器的反馈，一旦超过半数的 Follower 服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。而且当Leader出现崩溃或宕机等异常时，需要在Follower中重新选择一个Leader。</p>
<h4 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h4><p>ZAB协议包括两种基本的模式，分別是崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当 Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入崩溃恢复模式并选举产生新的 Leader服务器。当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该 Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和 Leader服务器的数据状态保持一致。</p>
<p>当集群中已经有过半的 Follower服务器完成了和 Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个 Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到 Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>
<p>ZooKeeper设计成只允许唯一的一个 Leader服务器来进行事务请求的处理。 Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非 Leader服务器会首先将这个事务请求转发给Leader服务器。</p>
<p>当 Leader服务器出现崩溃退出或机器重启，亦或是集群中已经不存在过半的服务器与该Leader服务器保持正常通信时，那么在重新开始新一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此达到一个一致的状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式</p>
<p>一个机器要成为新的 Leader，必须获得过半进程的支持，同时由于每个进程都有可能会崩溃，因此，在ZAB协议运行过程中，前后会出现多个 Leader，并且每个进程也有可能会多次成为 Leader。进入崩溃恢复模式后，只要集群中存在过半的服务器能够彼此进行正常通信，那么就可以产生一个新的 Leader并再次进入消息广播模式。举个例子来说，一个由3台机器组成的ZAB服务，通常由1个Leader、2个Follower服务器组成。某一个时刻，假如其中一个 Follower服务器挂了，整个 ZAB 集群是不会中断服务的，这是因为Leader服务器依然能够获得过半机器（包括Leader自己）的支持。</p>
<h4 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h4><p>ZAB协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交过程。针对客户端的事务请求， Leader服务器会为其生成对应的事务 Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交，如图4-2所示就是ZAB协议消息广播流程的示意图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354215.png" alt="image-20211124055008383"></p>
<p>在ZAB协议的二阶段提交过程中，移除了中断逻辑，所有的Follower服务器要么正常反馈 Leader提出的事务 Proposal，要么就抛弃Leader服务器。同时，ZAB协议将二阶段提交中的中断逻辑移除意味着我们可以在过半的 Follower服务器已经反馈Ack之后就开始提交事务 Proposal了，而不需要等待集群中所有的 Follower服务器都反馈响应。当然，在这种简化了的二阶段提交模型下，是无法处理 Leader服务器崩溃退出而带来的数据不一致问题的，因此在ZAB协议中添加了另一个模式，即采用崩溃恢复模式来解决这个问题。另外，整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易地保证消息广播过程中消息接收与发送的顺序性。</p>
<p>在整个消息广播过程中， Leader服务器会为每个事务请求生成对应的 Proposal来进行广播，并且在广播事务 Proposal之前， Leader服务器会首先为这个事务 Proposal分配一个全局单调递增的唯一ID，我们称之为事务ID(即ZXID)。由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每一个事务 Proposal按照其ZXID的先后顺序来进行排序与处理。</p>
<p>具体的，在消息广播过程中， Leader服务器会为每一个 Follower服务器都各自分配一个单独的队列，然后将需要广播的事务 Proposal依次放入这些队列中去，并且根据FIFO 策略进行消息发送。毎一个 Follower服务器在接收到这个事务 Proposal之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给 Leader服务器个Ack响应。当 Leader服务器接收到超过半数 FollowerI的Ack响应后，就会广播一个Commit消息给所有的 Follower服务器以通知其进行事务提交，同时 Leader自身也会完成对事务的提交，而每一个 Follower服务器在接收到 Commit消息后，也会完成对事务的提交。</p>
<h4 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h4><p>一且 Leader服务器出现崩溃，或者说由于网络原因导致 Leader服务器失去了与过半 Follower的联系，那么就会进入崩溃</p>
<ul>
<li><p>ZAB协议需要确保那些已经在 Leader服务器上提交的事务最终被所有服务器都提交</p>
<p>假设一个事务在 Leader 服务器上被提交了，并且已经得到过半 Follower 服务器的Ack反馈，但是在它将Commit消息发送给所有Follower机器之前，Leader服务器挂了</p>
<p>例如：在集群正常运行过程中的某一个时刻，Server1 是 Leader 服务器，其先后广播了消息 P1、P2、C1、P3 和 C2，其中，当Leader服务器将消息C2（C2是Commit Of Proposal2的缩写，即提交事务Proposal2）发出后就立即崩溃退出了。针对这种情况，ZAB协议就需要确保事务Proposal2最终能够在所有的服务器上都被提交成功，否则将出现不一致。</p>
<blockquote>
<p>P1 位Proposal1，C1是Commit Of Proposal1</p>
</blockquote>
</li>
<li><p>ZAB协议需要确保丢弃那些只在 Leader服务器上被提出的事</p>
<p>相反，如果在崩溃恢复过程中出现一个需要被丢弃的提案，那么在崩溃恢复结束后需要跳过该事务Proposal。</p>
<p>例如： 假设初始的 Leader 服务器 Server1 在提出了一个事务Proposal3 之后就崩溃退出了，从而导致集群中的其他服务器都没有收到这个事务Proposal。于是，当 Server1 恢复过来再次加入到集群中的时候，ZAB 协议需要确保丢弃Proposal3这个事务。</p>
</li>
</ul>
<p>根据上面的问题，Leader选举算法需要能确保提交已经被 Leader提交的事务Proposal，同时丢弃已经被跳过的事务 Proposal。</p>
<p>针对这个要求，如果让 Leader选举算法能够保证新选举出来的 Leader服务器拥有集群中所有机器最高編号(即ZXID最大)的事务 Proposal， 那么就可以保证这个新选举出来的 Leader一定具有所有已经提交的提案。更为重要的是， 如果让具有最高编号事务 Proposal的机器来成为 Leader，就可以省去 Leader服务器检査 Proposal的提交和丢弃工作的这一操作。</p>
<h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h5><p>完成 Leader选举之后，在正式开始工作(即接收客户端的事务请求，然后提出新的提案) 之前， Leader 服务器会首先确认事务日志中的所有 Proposal是否都已经被集群中过半的机器提交了，即是否完成数据同步。</p>
<p>Leader服务器需要确保所有的 Follower服务器能够接收到每一条事务 Proposal，并且能够正确地将所有已经提交了的事务 Proposal应用到内存数据库中去。具体的，Leader服务器会为每一个 Follower服务器都准备一个队列，并将那些没有被各 Follower服务器同步的事务以 Proposal消息的形式逐个发送给 Follower服务器，并在每一个 Proposal消息后面紧接着再发送一个 Commit消息，以表示该事务已经被提交。等到 Follower服务器将所有其尚未同步的事务 Proposal都从 Leader服务器上同步过来并成功应用到本地数据库中后， Leader服务器就会将该 Follower服务器加入到真正的可用 Follower列表中， 并开始之后的其他流程。</p>
<p>上面讲到的是正常情况下的数据同步逻辑，下面来看ZAB协议是如何处理那些需要被丢弃的事务 Proposal的。在ZAB协议的事务编号ZXID设计中，<strong>ZXID是一个64位的数字，其中低32位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务 Proposal的时候，都会对该计数器进行加1 操作；而高32位则代表了 Leader周期 epoch的编号，每当选举产生一个新的 Leader服务器，就会从这个 Leader服务器上取出其本地日志中最大事务 Proposal的ZXID，并从该ZXID中解析出对应的 epoch值，然后再对其进行加1操作，之后就会以此编号作为新的 epoch，并将低32位置从0来开始生成新的ZXID。ZAB协议中的这一通过 epoch编号来区分 Leader周期变化的策略，能够有效地避免不同的 Leader服务器错误地使用相同的ZXID编号提出不一样的事务 Proposal的异常情况</strong>，这对于识别在 Leader崩溃恢复前后生成的 Proposal非常有帮助，大大简化和提升了数据恢复流程。</p>
<p>基于这样的策略，当一个包含了上一个 Leader周期中尚未提交过的事务 Proposal的服务器启动时，其肯定无法成为 Leader，原因很简单，因为当前集群中一定包含一个Quorum集合，该集合中的机器一定包含了更高 epoch的事务 Proposal，因此这台机器的事务 Proposal肯定不是最高，也就无法成为 Leader了。当这台机器加入到集群中，以Follower角色连接上 Leader服务器之后， Leader服务器会根据自己服务器上最后被提交的 Proposal来和 Follower 服务器的 Proposal进行比对，比对的结果当然是 Leader会要求 Follower进行一个回退操作一一回退到一个确实已经被集群中过半机器提交的最新的事务 Proposal。</p>
<h3 id="ZAB协议的内部原理"><a href="#ZAB协议的内部原理" class="headerlink" title="ZAB协议的内部原理"></a>ZAB协议的内部原理</h3><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354216.png" alt="image-20211124061404591"></p>
<p>下面就从发现、同步和广播这三个阶段展开来讲解ZAB协议的内部原理。</p>
<h4 id="阶段一：发现"><a href="#阶段一：发现" class="headerlink" title="阶段一：发现"></a>阶段一：发现</h4><p>阶段一主要就是Leader选举过程，用于在多个分布式进程中选举出主进程，准Leader L和Follower F的工作流程分别如下。</p>
<p>步骤F.1.1 Follower F将自己最后接受的事务Proposal的epoch值CEPOCH（F.p）发送给准Leader L。</p>
<p>步骤L.1.1 当接收到来自过半 Follower 的 CEPOCH（F.p）消息后，准 Leader L 会生成NEWEPOCH（e′）消息给这些过半的Follower。</p>
<p>关于这个epoch值e′，准Leader L会从所有接收到的CEPOCH（F.p）消息中选取出最大的epoch值，然后对其进行加1操作，即为e′。</p>
<p>步骤F.1.2 当Follower接收到来自准Leader L的NEWEPOCH（e′）消息后，如果其检测到当前的CEPOCH（F.p）值小于e′，那么就会将CEPOCH（F.p）赋值为e′，同时向这个准Leader L反馈Ack消息。在这个反馈消息（ACK-E（F.p，hf））中，包含了当前该Follower的epoch CEPOCH（F.p），以及该Follower的历史事务Proposal集合：hf。</p>
<p>当Leader L接收到来自过半Follower的确认消息Ack之后，Leader L就会从这过半服务器中选取出一个Follower F，并使用其作为初始化事务集合Ie’。</p>
<p>关于这个Follower F的选取，对于Quorum中其他任意一个Follower F′，F需要满足以下两个条件中的一个：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354217.png" alt="image-20211124062024755"></p>
<blockquote>
<p>也就是epoch值最大的，或者zxid最大的</p>
</blockquote>
<p>这一阶段就是选举阶段，从集群中选择一个Leader出来。</p>
<h4 id="阶段二：同步"><a href="#阶段二：同步" class="headerlink" title="阶段二：同步"></a>阶段二：同步</h4><p>在完成发现流程之后，就进入了同步阶段。在这一阶段中，Leader L和Follower F的工作流程分别如下。</p>
<p>在完成发现流程之后，就进入了同步阶段。在这一阶段中，Leader L和Follower F的工作流程分别如下。</p>
<p>步骤L.2.1 Leader L会将e’和Ie’以NEWLEADER（e’，Ie’）消息的形式发送给所有Quorum中的Follower。</p>
<p>步骤F.2.1 当 Follower 接收到来自 Leader L 的 NEWLEADER（e’，Ie’）消息后，如果Follower 发现 CEPOCH （F.p） ≠ e’，那么直接进入下一轮循环，因为此时Follower发现自己还在上一轮，或者更上轮，无法参与本轮的同步。（这时，该机器就需要执行阶段1，而由于此时集群中已经存在了一个Leader，那么该机器最后会发现 CEPOCH （F.p） &lt; e’，所以该机器会作为Follower，加入到集群中，接着才会进入到阶段二）</p>
<p>如果CEPOCH （F.p）&#x3D;e’，那么Follower就会执行事务应用操作。具体的，对于每一个事务 Proposal：＜v，z＞∈Ie′，Follower 都会接受＜e’，＜v，z＞＞。最后，Follower会反馈给Leader，表明自己已经接受并处理了所有Ie’中的事务Proposal。</p>
<p>步骤L.2.2 当Leader 接收到来自过半Follower 针对NEWLEADER（e’，Ie’）的反馈消息后，就会向所有的Follower发送Commit消息。至此Leader完成阶段二。</p>
<p>步骤F.2.2 当Follower收到来自Leader的Commit消息后，就会依次处理并提交所有在Ie′’中未处理的事务。至此Follower完成阶段二。</p>
<h4 id="阶段三：广播"><a href="#阶段三：广播" class="headerlink" title="阶段三：广播"></a>阶段三：广播</h4><p>完成同步阶段之后，ZAB协议就可以正式开始接收客户端新的事务请求，并进行消息广播流程。</p>
<p>步骤L.3.1 Leader L接收到客户端新的事务请求后，会生成对应的事务Proposal，并根据ZXID的顺序向所有Follower发送提案＜e’，＜v，z＞＞，其中epoch（z）&#x3D;e′。</p>
<p>步骤F.3.1 Follower根据消息接收的先后次序来处理这些来自Leader的事务Proposal，并将他们追加到hf中去，之后再反馈给Leader。</p>
<p>步骤L.3.1 当 Leader接收到来自过半 Follower针对事务 Proposal＜e’，＜v，z＞＞的 Ack消息后，就会发送Commit＜e’，＜v，z＞＞消息给所有的Follower，要求它们进行事务的提交。</p>
<p>步骤F.3.2 当Follower F接收到来自Leader的Commit＜e’，＜v，z＞＞消息后，就会开始提交事务Proposal＜e’，＜v，z＞＞。需要注意的是，此时该Follower F必定已经提交了事务Proposal＜v’，z’＞，其中＜v’，z’＞ 中的z’&lt; z。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354218.png" alt="image-20211125033834062"></p>
<blockquote>
<p>CEPOCH：Follower进程向准Leader发送自己处理过的最后一个事务Proposal的epoch值。<br>NEWEPOCH：准Leader进程根据接收的各进程的epoch，来生成新一轮周期的epoch值。<br>ACK-E：Follower进程反馈准Leader进程发来的NEWEPOCH消息。<br>NEWLEADER：准Leader进程确立自己的领导地位，并发送NEWLEADER消息给各进程。<br>ACK-LD：Follower进程反馈Leader进程发来的NEWLEADER消息。<br>COMMIT-LD：要求Follower进程提交相应的历史事务Proposal。<br>PROPOSE：Leader进程生成一个针对客户端事务请求的Proposal。<br>ACK：Follower进程反馈Leader进程发来的PROPOSAL消息。<br>COMMIT：Leader发送COMMIT消息，要求所有进程提交事务PROPOSE。</p>
</blockquote>
<h4 id="运行分析"><a href="#运行分析" class="headerlink" title="运行分析"></a>运行分析</h4><p>再ZAB协议中，每个进程都有可能处于下面三种状态之一:</p>
<ul>
<li>LOOKING：Leader选举阶段</li>
<li>FOLLOWING：Follower服务器和Leader保持同步状态</li>
<li>LEADING：Leader服务器作为主进程领导状态</li>
</ul>
<p>组成ZAB协议的所有进程启动的时候，其初始化状态都是LOOKING状态，此时进程组中不存在Leader。所有处于这种状态的进程，都会试图去选举出一个新的Leader。随后，如果进程发现已经选举出新的Leader了，那么它就会马上切换到FOLLOWING状态，并开始和Leader保持同步。这里，我们将处于FOLLOWING状态的进程称为Follower，将处于LEADING状态的进程称为Leader。考虑到Leader进程随时会挂掉，当检测出Leader已经崩溃或者是放弃了领导地位时，其余的Follower进程就会转换到LOOKING状态，并开始进行新一轮的Leader选举。因此在ZAB协议运行过程中，毎个进程都会在LEADING、FOLLOWING和LOOKING状态之间不断地转换。</p>
<p>Leader的选举过程发生在前面两个阶段。</p>
<p>完成Leader选举以及数据同步之后，ZAB协议就进入了原子广播阶段。在这一阶段中，Leader会以队列的形式为每一个与自己保持同步的Follower创建一个操作队列。同一时刻，一个Follower只能和一个Leader保持同步，Leader进程与所有的Follower进程之间都通过心跳检测机制来感知彼此的情况。如果Leader能够在超时时间内正常收到心跳检测，那么Follower就会一直与该Leader保持连接。而如果在指定的超时时间内Leader无法从过半的 Follower 进程那里接收到心跳检测，或者是 TCP 连接本身断开了，那么Leader就会终止对当前周期的领导，并转换到LOOKING状态，所有的Follower也会选择放弃这个 Leader，同时转换到 LOOKING 状态。之后，所有进程就会开始新一轮的Leader选举，并在选举产生新的Leader之后开始新一轮的主进程周期。</p>
<h4 id="ZAB与Paxos算法的联系与区别"><a href="#ZAB与Paxos算法的联系与区别" class="headerlink" title="ZAB与Paxos算法的联系与区别"></a>ZAB与Paxos算法的联系与区别</h4><p>ZAB协议并不是Paxos算法的一个典型实现，在讲解ZAB和Paxos之间的区别之前，我们首先来看下两者的联系。</p>
<ul>
<li>两者都存在一个类似于 Leader 进程的角色，由其负责协调多个 Follower 进程的运行。</li>
<li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提案进行提交。</li>
<li>在 ZAB 协议中，每个 Proposal 中都包含了一个 epoch 值，用来代表当前的 Leader周期，在Paxos算法中，同样存在这样的一个标识，只是名字变成了Ballot。</li>
</ul>
<p>在Paxos算法中，一个新选举产生的主进程会进行两个阶段的工作。第一阶段被称为读阶段，在这个阶段中，这个新的主进程会通过和所有其他进程进行通信的方式来收集上一个主进程提出的提案，并将它们提交。第二阶段被称为写阶段，在这个阶段，当前主进程开始提出它自己的提案。在Paxos算法设计的基础上，ZAB协议额外添加了一个同步阶段。在同步阶段之前，ZAB协议也存在一个和Paxos算法中的读阶段非常类似的过程，称为发现（Discovery）阶段。在同步阶段中，新的Leader会确保存在过半的Follower已经提交了之前Leader周期中的所有事务Proposal。这一同步阶段的引入，能够有效地保证 Leader 在新的周期中提出事务 Proposal 之前，所有的进程都已经完成了对之前所有事务 Proposal 的提交。一旦完成同步阶段后，那么 ZAB 就会执行和 Paxos 算法类似的写阶段。</p>
<p>总的来讲，ZAB 协议和 Paxos 算法的本质区别在于，两者的设计目标不太一样。ZAB协议主要用于构建一个高可用的分布式数据主备系统，例如 ZooKeeper，而 Paxos 算法则是用于构建一个分布式的一致性状态机系统。</p>
<h2 id="zookeeper的数据模型"><a href="#zookeeper的数据模型" class="headerlink" title="zookeeper的数据模型"></a>zookeeper的数据模型</h2><p>ZooKeeper的视图结构和标准的Unix文件系统类似，其中每个节点称为“数据节点”或ZNode，每个znode可以存储数据，还可以挂载子节点，因此可以称之为“树”</p>
<p>每一个znode都必须有值，如果没有值，节点是不能创建成功的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354219.png" alt="image-20210220215845583"></p>
<h3 id="Zookeeper节点类型"><a href="#Zookeeper节点类型" class="headerlink" title="Zookeeper节点类型"></a>Zookeeper节点类型</h3><ul>
<li>持久节点（PERSISTENT ）：是指一旦这个 Znode被创建了，除非主动进行 Znode的移除操作，否则这个 Znode将一直保存在ZooKeeper上。</li>
<li>临时节点（EPHEMERAL ）：它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li>
</ul>
<p>另外，ZooKeeper还允许用户为每个节点添加一个特殊的属性： SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候， ZooKeeper会自动在其节点名后面追加上一个整型数字， 这个整型数字是一个由父节点维护的自增数字。</p>
<p>所以结点类型有四种形式：</p>
<ul>
<li>PERSISTENT </li>
<li>PERSISTENT_SEQUENTIAL（持久序列&#x2F;test0000000019 ） </li>
<li>EPHEMERAL </li>
<li>EPHEMERAL_SEQUENTIAL</li>
</ul>
<p>在分布式系统中，顺序号可以被用于为所有的事件进行全局排序，这样客户端可以通过顺序号推断事件的顺序</p>
<h2 id="zookeeper集群及配置"><a href="#zookeeper集群及配置" class="headerlink" title="zookeeper集群及配置"></a>zookeeper集群及配置</h2><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><p>启动前提：安装了对应的jdk版本，并且配置了JAVA_HOME环境变量<br>在每个zookeeper配置文件中添加<br>修改${zookeeper目录}&#x2F;conf&#x2F;zoo.cfg文件，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.0=192.168.212.154:2888:3888</span><br><span class="line">server.1=192.168.212.156:2888:3888</span><br><span class="line">server.2=192.168.212.157:2888:3888</span><br></pre></td></tr></table></figure>

<p>启动${zookeeper目录}&#x2F;bin&#x2F;zkServer.sh start</p>
<h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354220.png" alt="图片1-w942"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354221.png" alt="图片2-w942"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354222.png" alt="图片3-w1185"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354223.png" alt="图片4-w942"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/zookeeper/6395355562635354224.png" alt="图片5-w942"></p>
<h2 id="zookeeper服务器和客户端常用命令使用"><a href="#zookeeper服务器和客户端常用命令使用" class="headerlink" title="zookeeper服务器和客户端常用命令使用"></a>zookeeper服务器和客户端常用命令使用</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>启动ZK服务:       sh bin&#x2F;zkServer.sh start<br>ZK服务状态:       sh bin&#x2F;zkServer.sh status<br>停止ZK服务:       sh bin&#x2F;zkServer.sh stop<br>重启ZK服务:       sh bin&#x2F;zkServer.sh restart </p>
<h3 id="客户端常用命令"><a href="#客户端常用命令" class="headerlink" title="客户端常用命令"></a>客户端常用命令</h3><h4 id="创建节点-create"><a href="#创建节点-create" class="headerlink" title="创建节点 create"></a>创建节点 create</h4><p><code>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</code>  </p>
<p><code>-s</code> 创建有序节点  </p>
<p>如果在创建znode时，我们使用排序标志的话，ZooKeeper会在我们指定的 znode 名字后面增加一个数字。我们继续加入相同名字的znode时，这个数字会不断增加。这个序号的计数器是由这些排序znode的父节点来维护的。  </p>
<p><code>-e</code> 创建临时节点  </p>
<p>znode有两种类型：ephemeral 和 persistent。在创建znode时，我们指定znode的类型，并且在之后不会再被修改。当创建znode的客户端的session结束后，ephemeral类型的znode将被删除。persistent类型的znode在创建以后，就与客户端没什么联系了，除非主动去删除它，否则他会一直存在。Ephemeral znode没有任何子节点。  </p>
<p><code>acl</code> 在下面的《 ACL 操作》中详细介绍。  </p>
<p>使用方法：  </p>
<p>普通节点  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] create /mynode hello</span><br><span class="line">Created /mynode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] create /mynode/subnode world</span><br><span class="line">Created /mynode/subnode</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] get /mynode</span><br><span class="line">hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] get /mynode/subnode</span><br><span class="line">world</span><br></pre></td></tr></table></figure>


<p>有序节点  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] create -s /mynode hello</span><br><span class="line">Created /mynode0000000004</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s /mynode world</span><br><span class="line">Created /mynode0000000005</span><br></pre></td></tr></table></figure>


<p>临时节点  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] create -e /temp hello</span><br><span class="line">Created /temp</span><br></pre></td></tr></table></figure>


<p>退出 zkCli，然后再重新打开它，&#x2F;temp 节点已经被删除了。  </p>
<h4 id="列出节点-ls"><a href="#列出节点-ls" class="headerlink" title="列出节点 ls"></a>列出节点 ls</h4><p><code>ls [-s] [-w] [-R] path</code>  </p>
<p><code>-w</code> 添加一个 watch（监视器），如果该节点发生变化，watch 可以使客户端得到通知。watch 只能被触发一次。如果要一直获得 znode 的创建和删除的通知，那么就需要不断的在znode上开启观察模式。如果在该 path 下节点发生变化，会产生 <code>NodeChildrenChanged</code> 事件，删除节点，会产生 <code>NodeDeleted</code> 事件。</p>
<p>使用方法：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] <span class="built_in">ls</span> /</span><br><span class="line">[mynode, mynode0000000003, mynode0000000004, <span class="built_in">test</span>, zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] <span class="built_in">ls</span> -s /</span><br><span class="line">[mynode, mynode0000000003, mynode0000000004, <span class="built_in">test</span>, zookeeper]</span><br><span class="line">cZxid = 0x0</span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">mZxid = 0x0</span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line">pZxid = 0x300000053</span><br><span class="line">cversion = 7</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 5</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] <span class="built_in">ls</span> /mynode</span><br><span class="line">[subnode]</span><br></pre></td></tr></table></figure>


<p>使用 <code>-w</code> 查看 &#x2F;mynode 节点，然后在它下面添加（删除）子节点，就会触发该 watch。在其他节点下创建子节点，不会触发该 watch。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] <span class="built_in">ls</span> -w /mynode</span><br><span class="line">[subnode]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] create /mynode/subnode2</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/mynode</span><br><span class="line">Created /mynode/subnode2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听父节点，删除子节点，产生 NodeChildrenChanged事件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] <span class="built_in">ls</span> -w /mynode</span><br><span class="line">[subnode, subnode2]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] delete /mynode/subnode2</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/mynode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听子节点，删除子节点，产生 NodeDeleted 事件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 51] create /mynode/subnode2</span><br><span class="line">Created /mynode/subnode2</span><br><span class="line">[zk: localhost:2181(CONNECTED) 52] <span class="built_in">ls</span> -w /mynode/subnode2</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 53] delete /mynode/subnode2</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/mynode/subnode2</span><br></pre></td></tr></table></figure>


<p>从上面的操作可以看到，在 &#x2F;mynode 下添加了 subnode2 节点之后，触发了 watch，WatchedEvent 的类型是 <code>NodeChildrenChanged</code>。之后再删除 subnode2 节点，也出发了 watch。</p>
<h4 id="获取节点信息-get"><a href="#获取节点信息-get" class="headerlink" title="获取节点信息 get"></a>获取节点信息 get</h4><p><code>get [-s] [-w] path</code>  </p>
<p><code>-w</code> 添加一个 watch（监视器），如果节点内容发生改变，会产生 <code>NodeDataChanged</code> 事件；如果删除节点，会产生 <code>NodeDeleted</code> 事件。  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 33] get /mynode</span><br><span class="line">helloo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34] get -s /mynode</span><br><span class="line">helloo</span><br><span class="line">cZxid = 0x30000004c</span><br><span class="line">ctime = Sun Apr 05 15:48:14 CST 2020</span><br><span class="line">mZxid = 0x30000005d</span><br><span class="line">mtime = Sun Apr 05 16:05:56 CST 2020</span><br><span class="line">pZxid = 0x30000005c</span><br><span class="line">cversion = 7</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 6</span><br><span class="line">numChildren = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听节点内容，发生变化后，产生 NodeDataChanged 事件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 35] get -w /mynode</span><br><span class="line">helloo</span><br><span class="line">[zk: localhost:2181(CONNECTED) 36] <span class="built_in">set</span> /mynode hello</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/mynode</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点，产生 NodeDeleted 事件</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] get -w /mynode/subnode</span><br><span class="line">world</span><br><span class="line">[zk: localhost:2181(CONNECTED) 44] delete /mynode/subnode</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDeleted path:/mynode/subnode</span><br></pre></td></tr></table></figure>


<p>每一个对znode树的更新操作，都会被赋予一个全局唯一的ID，我们称之为<code>zxid</code>（ZooKeeper Transaction ID）。更新操作的ID按照发生的时间顺序升序排序。例如，z1大于z2，那么z1的操作就早于z2操作。  </p>
<p>每个 znode 的状态信息包含以下内容：  </p>
<ul>
<li>czxid，创建（create）该 znode 的 zxid</li>
<li>mzxid，最后一次修改（modify）该 znode 的 zxid</li>
<li>pzxid，最后一次修改该 znode <strong>子节点</strong>的 zxid</li>
<li>ctime，创建该 znode 的时间</li>
<li>mtime，最后一次修改该 znode 的时间</li>
<li>dataVersion，该节点内容的版本，每次修改内容，版本都会增加</li>
<li>cversion，该节点子节点的版本</li>
<li>aclVersion，该节点的 ACL 版本</li>
<li>ephemeralOwner，如果该节点是临时节点（ephemeral node），会列出该节点所在客户端的 session id；如果不是临时节点，该值为 0</li>
<li>dataLength，该节点存储的数据长度</li>
<li>numChildren，该节点子节点的个数</li>
</ul>
<h4 id="检查状态-stat"><a href="#检查状态-stat" class="headerlink" title="检查状态 stat"></a>检查状态 stat</h4><p><code>stat [-w] path</code>  </p>
<p><code>-w</code> 添加一个 watch（监视器），如果节点内容发生改变，会产生 <code>NodeDataChanged</code> 事件；如果删除节点，会产生 <code>NodeDeleted</code> 事件。  </p>
<p>与 get 的区别是，不回列出 znode 的值。  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 56] <span class="built_in">stat</span> /mynode</span><br><span class="line">cZxid = 0x30000004c</span><br><span class="line">ctime = Sun Apr 05 15:48:14 CST 2020</span><br><span class="line">mZxid = 0x30000005e</span><br><span class="line">mtime = Sun Apr 05 16:09:32 CST 2020</span><br><span class="line">pZxid = 0x300000067</span><br><span class="line">cversion = 16</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>

<h4 id="修改节点-set"><a href="#修改节点-set" class="headerlink" title="修改节点 set"></a>修改节点 set</h4><p><code>set [-s] [-v version] path data</code>  </p>
<p>修改<strong>已经存在</strong>的节点的值  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 57] <span class="built_in">set</span> /mynode hello</span><br><span class="line">[zk: localhost:2181(CONNECTED) 58] <span class="built_in">ls</span> /mynode</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 59] <span class="built_in">stat</span> /mynode</span><br><span class="line">cZxid = 0x30000004c</span><br><span class="line">ctime = Sun Apr 05 15:48:14 CST 2020</span><br><span class="line">mZxid = 0x300000068</span><br><span class="line">mtime = Sun Apr 05 16:20:34 CST 2020</span><br><span class="line">pZxid = 0x300000067</span><br><span class="line">cversion = 16</span><br><span class="line">dataVersion = 3</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure>


<p>可以看到，在修改节点值之后，mZxid、mtime、dataVersion 都发生了变化。  </p>
<h4 id="删除节点-deleteall"><a href="#删除节点-deleteall" class="headerlink" title="删除节点 deleteall"></a>删除节点 deleteall</h4><p><code>deleteall path [-b batch size]</code>  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 34] delete /mynode</span><br></pre></td></tr></table></figure>


<p>删除 &#x2F;mynode，不会返回任何内容。如果有子节点的时候，都会删除。  </p>
<h4 id="删除节点-delete"><a href="#删除节点-delete" class="headerlink" title="删除节点 delete"></a>删除节点 delete</h4><p><code>delete [-v version] path</code>  </p>
<p>调用<code>delete</code>和<code>set</code>操作时，如果指定znode版本号，需要与当前的版本号匹配。如果版本号不匹配，操作将会失败。失败的原因可能是在我们提交之前，该znode已经被修改过了，版本号发生了增量变化。如果不指定版本号，就是直接操作最新版本的 znode。  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 15] create /mynode hello</span><br><span class="line">Created /mynode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] delete /mynode</span><br></pre></td></tr></table></figure>


<p>如果要删除的节点有子节点，不能删除  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 33] create /mynode/sub sub</span><br><span class="line">Created /mynode/sub</span><br><span class="line">[zk: localhost:2181(CONNECTED) 34] delete /mynode</span><br><span class="line">Node not empty: /mynode</span><br></pre></td></tr></table></figure>

<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><h4 id="历史记录-history"><a href="#历史记录-history" class="headerlink" title="历史记录 history"></a>历史记录 history</h4><p><code>history</code> 列出最近的10条历史记录  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 7] <span class="built_in">history</span></span><br><span class="line">0 - <span class="built_in">history</span></span><br><span class="line">1 - create /mynode hello</span><br><span class="line">2 - <span class="built_in">ls</span> /</span><br><span class="line">3 - <span class="built_in">set</span> /mynode worold</span><br><span class="line">4 - get /mynode</span><br><span class="line">5 - <span class="built_in">stat</span> /mynode</span><br><span class="line">6 - rmr /mynode</span><br><span class="line">7 - <span class="built_in">history</span></span><br></pre></td></tr></table></figure>

<h4 id="重复之前的命令-redo"><a href="#重复之前的命令-redo" class="headerlink" title="重复之前的命令 redo"></a>重复之前的命令 redo</h4><p><code>redo cmdno</code> 根据 cmdno 重复之前的命令，cmdno 就是方括号里面最后的数字，每次执行命令都会自增。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create /mynode hello</span><br><span class="line">Created /mynode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] rmr /mynode</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] redo 5</span><br><span class="line">Created /mynode</span><br></pre></td></tr></table></figure>

<h4 id="是否输出-watch-事件（printwatches）"><a href="#是否输出-watch-事件（printwatches）" class="headerlink" title="是否输出 watch 事件（printwatches）"></a>是否输出 watch 事件（printwatches）</h4><p>语法  </p>
<p><code>printwatches on|off</code>  </p>
<p>使用方法  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 43] printwatches</span><br><span class="line">printwatches is on</span><br><span class="line">[zk: localhost:2181(CONNECTED) 44] <span class="built_in">ls</span> /mynode 1</span><br><span class="line">[sub]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 45] create /mynode/child child</span><br><span class="line"></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/mynode</span><br><span class="line">Created /mynode/child</span><br></pre></td></tr></table></figure>


<p>如果设置 <code>printwatches off</code> ，就看不到上面的 WATCHER 事件了。  </p>
<h4 id="关闭连接-close"><a href="#关闭连接-close" class="headerlink" title="关闭连接 close"></a>关闭连接 close</h4><p><code>close</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 50] close</span><br><span class="line">[zk: localhost:2181(CLOSED) 51]</span><br><span class="line">[zk: localhost:2181(CLOSED) 52] <span class="built_in">ls</span> /</span><br><span class="line">Not connected</span><br></pre></td></tr></table></figure>

<h4 id="打开连接-connect"><a href="#打开连接-connect" class="headerlink" title="打开连接 connect"></a>打开连接 connect</h4><p><code>connect host:port</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CLOSED) 52] connect</span><br><span class="line">[zk: localhost:2181(CONNECTING) 53]</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:None path:null</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 53]</span><br></pre></td></tr></table></figure>


<p>指定 host:port 可以连接远程的 zk 服务。缺省的时候，会连接本地的 2181 端口。  </p>
<h4 id="退出连接-quit"><a href="#退出连接-quit" class="headerlink" title="退出连接 quit"></a>退出连接 quit</h4><p><code>quit</code>  </p>
<p>直接退出当前的 zkCli 命令行。  </p>
<h4 id="强制同步-sync"><a href="#强制同步-sync" class="headerlink" title="强制同步 sync"></a>强制同步 sync</h4><p><code>sync path</code>  </p>
<p><code>sync</code>方法会强制客户端所连接的服务器状态与leader的状态同步，这样在读取 path 的值就是最新的值了。</p>
<h2 id="zookeeper的Java客户端使用"><a href="#zookeeper的Java客户端使用" class="headerlink" title="zookeeper的Java客户端使用"></a>zookeeper的Java客户端使用</h2><p><a href="./zookeeper%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8">zookeeper的Java客户端使用</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sv.pointcut.cc/blog/zookeeper/zookeeper%E8%AF%A6%E8%A7%A3/">http://sv.pointcut.cc/blog/zookeeper/zookeeper详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sv.pointcut.cc" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/zookeeper/">zookeeper</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/zookeeper/zxid%E8%AF%A6%E8%A7%A3/">zxid详解</a><a class="next" href="/blog/zookeeper/zookeeper%E7%9A%84WatchManager%E5%AE%9E%E7%8E%B0/">zookeeper的WatchManager实现</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">301</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">分布式架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E4%B8%AD%E5%BC%8F%E5%88%B0%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">从集中式到分布式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">分布式的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E7%9A%84%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">分布式环境的各种问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8EACID-%E5%88%B0-CAP-x2F-BASE"><span class="toc-number">1.4.</span> <span class="toc-text">从ACID 到 CAP&#x2F;BASE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ACID"><span class="toc-number">1.4.1.</span> <span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">BASE理论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text">一致性协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2PC"><span class="toc-number">2.1.</span> <span class="toc-text">2PC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%E8%AF%B7%E6%B1%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">阶段一：提交事务请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E6%89%A7%E8%A1%8C%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">阶段二：执行事务提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2PC%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">2PC优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3PC"><span class="toc-number">2.2.</span> <span class="toc-text">3PC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9ACanCommit"><span class="toc-number">2.2.1.</span> <span class="toc-text">阶段一：CanCommit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9APrecommit"><span class="toc-number">2.2.2.</span> <span class="toc-text">阶段二：Precommit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9AdoCommit"><span class="toc-number">2.2.3.</span> <span class="toc-text">阶段三：doCommit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paxos%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">Paxos算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E9%99%88%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">算法陈述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E6%A1%88%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">提案的获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%80%89%E5%8F%96%E4%B8%BBProposer%E4%BF%9D%E8%AF%81%E7%AE%97%E6%B3%95%E7%9A%84%E6%B4%BB%E6%80%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">通过选取主Proposer保证算法的活性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper"><span class="toc-number">3.</span> <span class="toc-text">zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">Zookeeper的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2"><span class="toc-number">3.1.1.</span> <span class="toc-text">集群角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D-Session"><span class="toc-number">3.1.2.</span> <span class="toc-text">会话( Session)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9-Znode"><span class="toc-number">3.1.3.</span> <span class="toc-text">数据节点( Znode)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC"><span class="toc-number">3.1.4.</span> <span class="toc-text">版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Watcher"><span class="toc-number">3.1.5.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ACL"><span class="toc-number">3.1.6.</span> <span class="toc-text">ACL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper%E7%9A%84ZAB%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">ZooKeeper的ZAB协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">协议介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD"><span class="toc-number">3.2.2.</span> <span class="toc-text">消息广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">3.2.3.</span> <span class="toc-text">崩溃恢复</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">数据同步</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ZAB%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">ZAB协议的内部原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80%EF%BC%9A%E5%8F%91%E7%8E%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">阶段一：发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5"><span class="toc-number">3.3.2.</span> <span class="toc-text">阶段二：同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E5%B9%BF%E6%92%AD"><span class="toc-number">3.3.3.</span> <span class="toc-text">阶段三：广播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.3.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">3.3.5.</span> <span class="toc-text">运行分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZAB%E4%B8%8EPaxos%E7%AE%97%E6%B3%95%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.6.</span> <span class="toc-text">ZAB与Paxos算法的联系与区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">zookeeper的数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Zookeeper节点类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E9%9B%86%E7%BE%A4%E5%8F%8A%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">zookeeper集群及配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">5.1.</span> <span class="toc-text">集群启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">5.2.</span> <span class="toc-text">配置说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">zookeeper服务器和客户端常用命令使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.2.</span> <span class="toc-text">客户端常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9-create"><span class="toc-number">6.2.1.</span> <span class="toc-text">创建节点 create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E8%8A%82%E7%82%B9-ls"><span class="toc-number">6.2.2.</span> <span class="toc-text">列出节点 ls</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF-get"><span class="toc-number">6.2.3.</span> <span class="toc-text">获取节点信息 get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%8A%B6%E6%80%81-stat"><span class="toc-number">6.2.4.</span> <span class="toc-text">检查状态 stat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9-set"><span class="toc-number">6.2.5.</span> <span class="toc-text">修改节点 set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-deleteall"><span class="toc-number">6.2.6.</span> <span class="toc-text">删除节点 deleteall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-delete"><span class="toc-number">6.2.7.</span> <span class="toc-text">删除节点 delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-number">6.3.</span> <span class="toc-text">其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95-history"><span class="toc-number">6.3.1.</span> <span class="toc-text">历史记录 history</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E4%B9%8B%E5%89%8D%E7%9A%84%E5%91%BD%E4%BB%A4-redo"><span class="toc-number">6.3.2.</span> <span class="toc-text">重复之前的命令 redo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E8%BE%93%E5%87%BA-watch-%E4%BA%8B%E4%BB%B6%EF%BC%88printwatches%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">是否输出 watch 事件（printwatches）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5-close"><span class="toc-number">6.3.4.</span> <span class="toc-text">关闭连接 close</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%BF%9E%E6%8E%A5-connect"><span class="toc-number">6.3.5.</span> <span class="toc-text">打开连接 connect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E8%BF%9E%E6%8E%A5-quit"><span class="toc-number">6.3.6.</span> <span class="toc-text">退出连接 quit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5-sync"><span class="toc-number">6.3.7.</span> <span class="toc-text">强制同步 sync</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">zookeeper的Java客户端使用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/05-Nacos%E4%B8%AD%E7%9A%84AbstractNacosTaskExecuteEngine/" title="05-Nacos中的AbstractNacosTaskExecuteEngine">05-Nacos中的AbstractNacosTaskExecuteEngine</a><time datetime="2021-11-27T12:00:40.000Z" title="发表于 2021-11-27 20:00:40">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/04-Server%E5%92%8CClient%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96nacos%E5%9C%B0%E5%9D%80/" title="04-Server和Client动态获取nacos地址">04-Server和Client动态获取nacos地址</a><time datetime="2021-11-27T12:00:39.000Z" title="发表于 2021-11-27 20:00:39">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/03-Nacos%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" title="03-Nacos的发布与订阅">03-Nacos的发布与订阅</a><time datetime="2021-11-27T12:00:38.000Z" title="发表于 2021-11-27 20:00:38">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/02-Nacos%20Server%E4%B8%AD%E7%9A%84Secured%E6%B3%A8%E8%A7%A3/" title="02-Nacos Server中的Secured注解">02-Nacos Server中的Secured注解</a><time datetime="2021-11-27T12:00:37.000Z" title="发表于 2021-11-27 20:00:37">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/01-Nacos%20Server%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" title="01-Nacos Server服务注册表的写时复制">01-Nacos Server服务注册表的写时复制</a><time datetime="2021-11-27T12:00:36.000Z" title="发表于 2021-11-27 20:00:36">2021-11-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>