<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>19-锁 | XYZhi's学习笔记</title><meta name="keywords" content="mysql"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对锁的简单的描述写-写情况在写-写情况：即并发事务相继对相同的记录做出改动。 我们前边说过，在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：  当一个事务想对这">
<meta property="og:type" content="article">
<meta property="og:title" content="19-锁">
<meta property="og:url" content="https://nbobj.github.io/blog/mysql/19-%E9%94%81/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="对锁的简单的描述写-写情况在写-写情况：即并发事务相继对相同的记录做出改动。 我们前边说过，在这种情况下会发生脏写的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联的，如图所示：  当一个事务想对这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nbobj.github.io/linear-gradient(#0062be)">
<meta property="article:published_time" content="2021-11-14T00:00:19.000Z">
<meta property="article:modified_time" content="2022-03-23T12:18:13.440Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nbobj.github.io/linear-gradient(#0062be)"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nbobj.github.io/blog/mysql/19-%E9%94%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '19-锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 20:18:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(#0062be)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">19-锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-14T00:00:19.000Z" title="发表于 2021-11-14 08:00:19">2021-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T12:18:13.440Z" title="更新于 2022-03-23 20:18:13">2022-03-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="19-锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="对锁的简单的描述"><a href="#对锁的简单的描述" class="headerlink" title="对锁的简单的描述"></a>对锁的简单的描述</h2><h3 id="写-写情况"><a href="#写-写情况" class="headerlink" title="写-写情况"></a><code>写-写</code>情况</h3><p>在<code>写-写</code>情况：即并发事务相继对相同的记录做出改动。</p>
<p>我们前边说过，在这种情况下会发生<code>脏写</code>的问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过<code>锁</code>来实现的。这个所谓的<code>锁</code>其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有<code>锁结构</code>和记录进行关联的，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182957.png"></p>
<p>当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的<code>锁结构</code>，当没有的时候就会在内存中生成一个<code>锁结构</code>与之关联。比方说事务<code>T1</code>要对这条记录做改动，就需要生成一个<code>锁结构</code>与之关联：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182958.png"></p>
<blockquote>
<p>其实在<code>锁结构</code>里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p>
</blockquote>
<ul>
<li><p><code>trx信息</code>：代表这个锁结构是哪个事务生成的。</p>
</li>
<li><p><code>is_waiting</code>：代表当前事务是否在等待。</p>
</li>
</ul>
<p>如图所示，当事务<code>T1</code>改动了这条记录后，就生成了一个<code>锁结构</code>与该记录关联，因为之前没有别的事务为这条记录加锁，所以<code>is_waiting</code>属性就是<code>false</code>，我们把这个场景就称之为<span style="color:red">获取锁成功，或者加锁成功</span>，然后就可以继续执行操作了。</p>
<p>在事务<code>T1</code>提交之前，另一个事务<code>T2</code>也想对该记录做改动，那么先去看看有没有<code>锁结构</code>与这条记录关联，发现有一个<code>锁结构</code>与之关联后，然后也生成了一个<code>锁结构</code>与这条记录关联，不过<code>锁结构</code>的<code>is_waiting</code>属性值为<code>true</code>，表示当前事务需要等待，我们把这个场景就称之为<span style="color:red">获取锁失败，或者加锁失败，或者没有成功的获取到锁</span>，画个图表示就是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182959.png"></p>
<p>在事务<code>T1</code>提交之后，就会把该事务生成的<code>锁结构</code>释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务<code>T2</code>还在等待获取锁，所以把事务<code>T2</code>对应的锁结构的<code>is_waiting</code>属性设置为<code>false</code>，然后把该事务对应的线程唤醒，让它继续执行，此时事务<code>T2</code>就算获取到锁了。效果图就是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182960.png"></p>
<h3 id="读-写或写-读情况"><a href="#读-写或写-读情况" class="headerlink" title="读-写或写-读情况"></a><code>读-写</code>或<code>写-读</code>情况</h3><p><code>读-写</code>或<code>写-读</code>情况：也就是一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。</p>
<p>怎么解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些问题呢？其实有两种可选的解决方案：</p>
<ol>
<li><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</p>
<p>所谓的<code>MVCC</code>我们在前一章有过详细的描述，就是通过生成一个<code>ReadView</code>，然后通过<code>ReadView</code>找到符合条件的记录版本（历史版本是由<code>undo日志</code>构建的），其实就像是在生成<code>ReadView</code>的那个时刻做了一次时间静止（就像用相机拍了一个快照），查询语句只能读到在生成<code>ReadView</code>之前已提交事务所做的更改，在生成<code>ReadView</code>之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而&#x3D;&#x3D;写操作肯定针对的是最新版本的记录&#x3D;&#x3D;，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用<code>MVCC</code>时，<code>读-写</code>操作并不冲突。</p>
<blockquote>
<p>我们说过普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录。在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改，也就是避免了脏读现象；</p>
<p>&#x3D;&#x3D;REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样也就避免了不可重复读和幻读的问题。&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行<code>加锁</code>操作，这样也就意味着<code>读</code>操作和<code>写</code>操作也像<code>写-写</code>操作那样排队执行。</p>
</li>
</ol>
<p>很明显，采用<code>MVCC</code>+锁的方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。一般情况下我们当然愿意采用<code>MVCC</code>来解决<code>读-写</code>操作并发执行的问题，但是业务在某些特殊情况下，要求必须采用<code>加锁</code>的方式执行，那也是没有办法的事。</p>
<h2 id="一致性读（Consistent-Reads）"><a href="#一致性读（Consistent-Reads）" class="headerlink" title="一致性读（Consistent Reads）"></a>一致性读（Consistent Reads）</h2><p>用<code>MVCC</code>进行的读取操作称之为<code>一致性读</code>，或者<code>一致性无锁读</code>，有的地方也称之为<code>快照读</code>。所有普通的<code>SELECT</code>语句（<code>plain SELECT</code>）在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>一致性读</code>，</p>
<h2 id="锁定读（Locking-Reads）"><a href="#锁定读（Locking-Reads）" class="headerlink" title="锁定读（Locking Reads）"></a>锁定读（Locking Reads）</h2><p>MySQL给锁分了两类：</p>
<ul>
<li><code>共享锁</code>，英文名：<code>Shared  Locks</code>，简称<code>S锁</code>。在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。</li>
<li><code>独占锁</code>，也常称<code>排他锁</code>，英文名：<code>Exclusive Locks</code>，简称<code>X锁</code>。在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。</li>
</ul>
<p>假如事务<code>T1</code>首先获取了一条记录的<code>S锁</code>之后，事务<code>T2</code>接着也要访问这条记录：</p>
<ul>
<li>如果事务<code>T2</code>想要再获取一个记录的<code>S锁</code>，那么事务<code>T2</code>也会获得该锁，也就意味着事务<code>T1</code>和<code>T2</code>在该记录上同时持有<code>S锁</code>。</li>
<li>如果事务<code>T2</code>想要再获取一个记录的<code>X锁</code>，那么此操作会被阻塞，直到事务<code>T1</code>提交之后将<code>S锁</code>释放掉。</li>
</ul>
<p>如果事务<code>T1</code>首先获取了一条记录的<code>X锁</code>之后，那么不管事务<code>T2</code>接着想获取该记录的<code>S锁</code>还是<code>X锁</code>都会被阻塞，直到事务<code>T1</code>提交。</p>
<p>所以我们说<code>S锁</code>和<code>S锁</code>是兼容的，<code>S锁</code>和<code>X锁</code>是不兼容的，<code>X锁</code>和<code>X锁</code>也是不兼容的，画个表表示一下就是这样：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>S</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h3 id="锁定读的语句"><a href="#锁定读的语句" class="headerlink" title="锁定读的语句"></a>锁定读的语句</h3><ul>
<li><p>对读取的记录加<code>S锁</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对读取的记录加<code>X锁</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="操操作"><a href="#操操作" class="headerlink" title="操操作"></a>操操作</h2><p>平常所用到的<code>写操作</code>无非是<code>DELETE</code>、<code>UPDATE</code>、<code>INSERT</code>这三种：</p>
<ul>
<li><p><code>DELETE</code>：</p>
<p>对一条记录做<code>DELETE</code>操作的过程其实是先在<code>B+</code>树中定位到这条记录的位置，然后获取一下这条记录的<code>X锁</code>，然后再执行<code>delete mark</code>操作。我们也可以把这个定位待删除记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</p>
</li>
<li><p><code>UPDATE</code>：</p>
<p>在对一条记录做<code>UPDATE</code>操作时分为三种情况：</p>
<ul>
<li>如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后再获取一下记录的<code>X锁</code>，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>。</li>
<li>如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在<code>B+</code>树中定位到这条记录的位置，然后获取一下记录的<code>X锁</code>，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在<code>B+</code>树中位置的过程看成是一个获取<code>X锁</code>的<code>锁定读</code>，新插入的记录由<code>INSERT</code>操作提供的<code>隐式锁</code>进行保护。</li>
<li>如果修改了该记录的键值，则相当于在原记录上做<code>DELETE</code>操作之后再来一次<code>INSERT</code>操作，加锁操作就需要按照<code>DELETE</code>和<code>INSERT</code>的规则进行了。</li>
</ul>
</li>
<li><p><code>INSERT</code>：</p>
<p>一般情况下，新插入一条记录的操作并不加锁，在<code>InnoDB</code>中通过&#96;&#96;隐式锁&#96;来保护这条新插入的记录在本事务提交前不被别的事务访问。</p>
</li>
</ul>
<h2 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h2><p>我们前边提到的<code>锁</code>都是针对记录的，也可以被称之为<code>行级锁</code>或者<code>行锁</code>，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在<code>表</code>级别进行加锁，自然就被称之为<code>表级锁</code>或者<code>表锁</code>，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为<code>共享锁</code>（<code>S锁</code>）和<code>独占锁</code>（<code>X锁</code>）：</p>
<ul>
<li><p>给表加<code>S锁</code>：</p>
<p>如果一个事务给表加了<code>S锁</code>，那么：</p>
<ul>
<li>别的事务可以继续获得该表的<code>S锁</code></li>
<li>别的事务可以继续获得该表中的某些记录的<code>S锁</code></li>
<li>别的事务不可以继续获得该表的<code>X锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li>
</ul>
</li>
<li><p>给表加<code>X锁</code>：</p>
<p>如果一个事务给表加了<code>X锁</code>（意味着该事务要独占这个表），那么：</p>
<ul>
<li>别的事务不可以继续获得该表的<code>S锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>S锁</code></li>
<li>别的事务不可以继续获得该表的<code>X锁</code></li>
<li>别的事务不可以继续获得该表中的某些记录的<code>X锁</code></li>
</ul>
</li>
</ul>
<p>上边看着有点啰嗦，为了更好的理解这个表级别的<code>S锁</code>和<code>X锁</code>，我们举一个现实生活中的例子。不知道各位同学都上过大学没，我们以大学教学楼中的教室为例来分析一下加锁的情况：</p>
<ul>
<li><p>教室一般都是公用的，我们可以随便选教室进去上自习。当然，教室不是自家的，一间教室可以容纳很多同学同时上自习，每当一个人进去上自习，就相当于在教室门口挂了一把<code>S锁</code>，如果很多同学都进去上自习，相当于教室门口挂了很多把<code>S锁</code>（类似行级别的<code>S锁</code>）。</p>
</li>
<li><p>有的时候教室会进行检修，比方说换地板，换天花板，换灯管啥的，这些维修项目并不能同时开展。如果教室针对某个项目进行检修，就不允许别的同学来上自习，也不允许其他维修项目进行，此时相当于教室门口会挂一把<code>X锁</code>（类似行级别的<code>X锁</code>）。</p>
</li>
</ul>
<p>上边提到的这两种锁都是针对<code>教室</code>而言的，不过有时候我们会有一些特殊的需求：</p>
<ul>
<li><p>有领导要来参观教学楼的环境。</p>
<p>校领导考虑并不想影响同学们上自习，但是此时不能有教室处于维修状态，所以可以在教学楼门口放置一把<code>S锁</code>（类似表级别的<code>S锁</code>）。此时：</p>
<ul>
<li><p>来上自习的学生们看到教学楼门口有<code>S锁</code>，可以继续进入教学楼上自习。</p>
</li>
<li><p>修理工看到教学楼门口有<code>S锁</code>，则先在教学楼门口等着，啥时候领导走了，把教学楼的<code>S锁</code>撤掉再进入教学楼维修。</p>
</li>
</ul>
</li>
<li><p>学校要占用教学楼进行考试。</p>
<p>此时不允许教学楼中有正在上自习的教室，也不允许对教室进行维修。所以可以在教学楼门口放置一把<code>X锁</code>（类似表级别的<code>X锁</code>）。此时：</p>
<ul>
<li><p>来上自习的学生们看到教学楼门口有<code>X锁</code>，则需要在教学楼门口等着，啥时候考试结束，把教学楼的<code>X锁</code>撤掉再进入教学楼上自习。</p>
</li>
<li><p>修理工看到教学楼门口有<code>X锁</code>，则先在教学楼门口等着，啥时候考试结束，把教学楼的<code>X锁</code>撤掉再进入教学楼维修。</p>
</li>
</ul>
</li>
</ul>
<p>但是这里头有两个问题：</p>
<ul>
<li><p>如果我们想对教学楼整体上<code>S锁</code>，首先需要确保教学楼中的没有正在维修的教室，如果有正在维修的教室，需要等到维修结束才可以对教学楼整体上<code>S锁</code>。</p>
</li>
<li><p>如果我们想对教学楼整体上<code>X锁</code>，首先需要确保教学楼中的没有上自习的教室以及正在维修的教室，如果有上自习的教室或者正在维修的教室，需要等到全部上自习的同学都上完自习离开，以及维修工维修完教室离开后才可以对教学楼整体上<code>X锁</code>。</p>
</li>
</ul>
<p>我们在对教学楼整体上锁（<code>表锁</code>）时，怎么知道教学楼中有没有教室已经被上锁（<code>行锁</code>）了呢？依次检查每一间教室门口有没有上锁？那这效率也太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计<code>InnoDB</code>的大叔们提出了一种称之为<code>意向锁</code>（英文名：<code>Intention Locks</code>）的东东：</p>
<ul>
<li><p>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</p>
</li>
<li><p>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</p>
</li>
</ul>
<p>视角回到教学楼和教室上来：</p>
<ul>
<li><p>如果有学生到教室中上自习，那么他先在整栋教学楼门口放一把<code>IS锁</code>（表级锁），然后再到教室门口放一把<code>S锁</code>（行锁）。</p>
</li>
<li><p>如果有维修工到教室中维修，那么它先在整栋教学楼门口放一把<code>IX锁</code>（表级锁），然后再到教室门口放一把<code>X锁</code>（行锁）。</p>
</li>
</ul>
<p>之后：</p>
<ul>
<li><p>如果有领导要参观教学楼，也就是想在教学楼门口前放<code>S锁</code>（表锁）时，首先要看一下教学楼门口有没有<code>IX锁</code>，如果有，意味着有教室在维修，需要等到维修结束把<code>IX锁</code>撤掉后才可以在整栋教学楼上加<code>S锁</code>。</p>
</li>
<li><p>如果有考试要占用教学楼，也就是想在教学楼门口前放<code>X锁</code>（表锁）时，首先要看一下教学楼门口有没有<code>IS锁</code>或<code>IX锁</code>，如果有，意味着有教室在上自习或者维修，需要等到学生们上完自习以及维修结束把<code>IS锁</code>和<code>IX锁</code>撤掉后才可以在整栋教学楼上加<code>X锁</code>。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小贴士：</span><br><span class="line"></span><br><span class="line">学生在教学楼门口加IS锁时，是不关心教学楼门口是否有IX锁的，维修工在教学楼门口加IX锁时，是不关心教学楼门口是否有IS锁或者其他IX锁的。IS和IX锁只是为了判断当前时间教学楼里有没有被占用的教室用的，也就是在对教学楼加S锁或者X锁时才会用到。</span><br></pre></td></tr></table></figure>

<p>总结一下：&#x3D;&#x3D;IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的&#x3D;&#x3D;。我们画个表来看一下表级别的各种锁的兼容性：</p>
<table>
<thead>
<tr>
<th align="center">兼容性</th>
<th align="center"><code>X</code></th>
<th align="center"><code>IX</code></th>
<th align="center"><code>S</code></th>
<th align="center"><code>IS</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>X</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
</tr>
<tr>
<td align="center"><code>IX</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>S</code></td>
<td align="center">不兼容</td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center"><code>IS</code></td>
<td align="center">不兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<h2 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h2><h3 id="表级别的AUTO-INC锁"><a href="#表级别的AUTO-INC锁" class="headerlink" title="表级别的AUTO-INC锁"></a>表级别的<code>AUTO-INC锁</code></h3><p> 使用<code>MySQL</code>过程中，我们可以为表的某个列添加<code>AUTO_INCREMENT</code>属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值</p>
<p>  系统实现这种自动给<code>AUTO_INCREMENT</code>修饰的列递增赋值的原理主要是两个：</p>
<ol>
<li><p>采用<code>AUTO-INC</code>锁，也就是在执行插入语句时就在表级别加一个<code>AUTO-INC</code>锁，然后为每条待插入记录的<code>AUTO_INCREMENT</code>修饰的列分配递增的值，在该语句执行结束后，再把<code>AUTO-INC</code>锁释放掉。这样一个事务在持有<code>AUTO-INC</code>锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。</p>
<p>如果我们的插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比方说使用<code>INSERT ... SELECT</code>、<code>REPLACE ... SELECT</code>或者<code>LOAD DATA</code>这种插入语句，一般是使用<code>AUTO-INC</code>锁为<code>AUTO_INCREMENT</code>修饰的列生成对应的值。</p>
<blockquote>
<p>需要注意一下的是，这个AUTO-INC锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，跟我们之前介绍的锁在事务结束时释放是不一样的。</p>
</blockquote>
</li>
<li><p>采用一个轻量级的锁，在为插入语句生成<code>AUTO_INCREMENT</code>修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的<code>AUTO_INCREMENT</code>列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁。</p>
<p>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表<code>t</code>的例子中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对<code>AUTO_INCREMENT</code>修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。</p>
</li>
</ol>
<p>  在InnoDB存储引擎中提供了一个<code>innodb_autoinc_lock_mode</code>系统变量来控制到底使用上述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值：</p>
<ul>
<li><p>当innodb_autoinc_lock_mode值为0时，一律采用AUTO-INC锁。</p>
<p>该自增锁是表锁级别，且必须等待当前SQL执行完成后或者回滚掉才会释放，这样在高并发的情况下可想而知自增锁竞争是比较大的</p>
</li>
<li><p>当innodb_autoinc_lock_mode值为1时，两种方式混着来。</p>
<p>这时如果是单一的insert SQL，可以立即获得该锁，并立即释放，而不必等待当前SQL执行完成（除非在其他事务中已经有session获取了自增锁）。另外当SQL是一些批量insert sql时，比如insert into …select …,load data,replace ..select..时，这时还是表级锁，可以理解成退化为必须等待当前SQL执行完才释放。可以认为，该值为1时是相对比较轻量的锁，也不会对复制产生影响，唯一的缺陷是产生的自增值不一定是完全连续的</p>
</li>
<li><p>当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁。</p>
<p>由于这个模式下已经没有了auto_inc锁，所以这个模式下的性能是最好的；但是它也有一个问题，就是对于同一个语句来说它所得到的auto_incremant值可能不是连续的，当binlog_format为statement时，这时的复制没法保证安全，因为可能会产生对于同一语句在主和从生成的ID不同。</p>
</li>
</ul>
<blockquote>
<p>如果你的二进制文件格式是mixed | row 那么这三个值中的任何一个对于你来说都是复制安全的。</p>
<p>由于现在mysql已经推荐把二进制的格式设置成row，所以在binlog_format不是statement的情况下最好是innodb_autoinc_lock_mode&#x3D;2 这样可能知道更好的性能。</p>
</blockquote>
<h3 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h3><ul>
<li><p><code>Record Locks</code>：</p>
<p>就是前面提及的行的<code>S锁</code>和<code>X锁</code>，使用方式有:（在一个事务中）</p>
<ol>
<li><p>执行DELETE、UPDATE时，用索引作为条件，此时就对索引对应的行上加了<code>X锁</code></p>
</li>
<li><p>SELECT显示的使用</p>
<p><code>lock in share mode</code>为行添加<code>S锁</code></p>
<p><code>for update</code>为行添加<code>X锁</code></p>
</li>
</ol>
<blockquote>
<p>注意，第一点中，如果条件中列都没有加索引，那么就会变成了表的<code>X锁</code>了</p>
</blockquote>
</li>
<li><p><code>Gap Locks</code>：</p>
<p>我们说<code>MySQL</code>在<code>REPEATABLE READ</code>隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用<code>MVCC</code>方案解决，也可以采用<code>加锁</code>方案解决。但是在使用<code>加锁</code>方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上<code>Record Locks</code>。所以在<code>InnoDB</code>提出了一种称之为<code>Gap Locks</code>的锁，官方的类型名称为：<code>LOCK_GAP</code>，我们也可以简称为<code>gap锁</code>。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>gap锁</code>的示意图如下：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182961.png"></p>
<p>  如图中为<code>number</code>值为<code>8</code>的记录加了<code>gap锁</code>，意味着不允许别的事务在<code>number</code>值为<code>8</code>的记录前边的<code>间隙</code>插入新记录，其实就是<code>number</code>列的值<code>(3, 8)</code>这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条<code>number</code>值为<code>4</code>的新记录，它定位到该条新记录的下一条记录的<code>number</code>值为8，而这条记录上又有一个<code>gap锁</code>，所以就会阻塞插入操作，直到拥有这个<code>gap锁</code>的事务提交了之后，<code>number</code>列的值在区间<code>(3, 8)</code>中的新记录才可以被插入。</p>
<p>  这个<code>gap锁</code>的提出<span style="color:red">仅仅是为了防止插入幻影记录而提出的</span>，虽然有<code>共享gap锁</code>和<code>独占gap锁</code>这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了<code>gap锁</code>（不论是<code>共享gap锁</code>还是<code>独占gap锁</code>），并不会限制其他事务对这条记录加<code>Record Locks</code>或者继续加<code>gap锁</code>，再强调一遍，<code>gap锁</code>的作用仅仅是为了防止插入幻影记录的而已。</p>
<p>  不知道大家发现了一个问题没，给一条记录加了<code>gap锁</code>只是不允许其他事务往这条记录前边的间隙插入新记录，那对于最后一条记录之后的间隙，也就是<code>hero</code>表中<code>number</code>值为<code>20</code>的记录之后的间隙该咋办呢？也就是说给哪条记录加<code>gap锁</code>才能阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录呢？这时候应该想起我们在前边唠叨<code>数据页</code>时介绍的两条伪记录了：</p>
<ul>
<li><p><code>Infimum</code>记录，表示该页面中最小的记录。</p>
</li>
<li><p><code>Supremum</code>记录，表示该页面中最大的记录。</p>
</li>
</ul>
<p>  为了实现阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录，我们可以给索引中的最后一条记录，也就是<code>number</code>值为<code>20</code>的那条记录所在页面的<code>Supremum</code>记录加上一个<code>gap锁</code>，画个图就是这样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182962.png"></p>
<p>  这样就可以阻止其他事务插入<code>number</code>值在<code>(20, +∞)</code>这个区间的新记录。为</p>
<ul>
<li><p><code>Next-Key Locks</code>：</p>
<p>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的<code>间隙</code>插入新记录，所以设计<code>InnoDB</code>的大叔们就提出了一种称之为<code>Next-Key Locks</code>的锁，官方的类型名称为：<code>LOCK_ORDINARY</code>，我们也可以简称为<code>next-key锁</code>。比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>next-key锁</code>的示意图如下：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182963.png"></p>
<p>  <code>next-key锁</code>的本质就是一个<code>Record Locks</code>和一个<code>gap锁</code>的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的<code>间隙</code>。</p>
<ul>
<li><p><code>Insert Intention Locks</code>：</p>
<p>我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的<code>gap锁</code>（<code>next-key锁</code>也包含<code>gap锁</code>，后边就不强调了），如果有的话，插入操作需要等待，直到拥有<code>gap锁</code>的那个事务提交。但是设计<code>InnoDB</code>的大叔规定事务在等待的时候也需要在内存中生成一个<code>锁结构</code>，表明有事务想在某个<code>间隙</code>中插入新记录，但是现在在等待。设计<code>InnoDB</code>的大叔就把这种类型的锁命名为<code>Insert Intention Locks</code>，官方的类型名称为：<code>LOCK_INSERT_INTENTION</code>，我们也可以称为<code>插入意向锁</code>。</p>
<p>比方说我们把<code>number</code>值为<code>8</code>的那条记录加一个<code>插入意向锁</code>的示意图如下：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182964.png"></p>
<p>  为了让大家彻底理解这个<code>插入意向锁</code>的功能，我们还是举个例子然后画个图表示一下。比方说现在<code>T1</code>为<code>number</code>值为<code>8</code>的记录加了一个<code>gap锁</code>，然后<code>T2</code>和<code>T3</code>分别想向<code>hero</code>表中插入<code>number</code>值分别为<code>4</code>、<code>5</code>的两条记录，所以现在为<code>number</code>值为<code>8</code>的记录加的锁的示意图就如下所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/7115931541478182965.png"></p>
<p>  从图中可以看到，由于<code>T1</code>持有<code>gap锁</code>，所以<code>T2</code>和<code>T3</code>需要生成一个<code>插入意向锁</code>的<code>锁结构</code>并且处于等待状态。当<code>T1</code>提交后会把它获取到的锁都释放掉，这样<code>T2</code>和<code>T3</code>就能获取到对应的<code>插入意向锁</code>了（本质上就是把插入意向锁对应锁结构的<code>is_waiting</code>属性改为<code>false</code>），<code>T2</code>和<code>T3</code>之间也并不会相互阻塞，它们可以同时获取到<code>number</code>值为8的<code>插入意向锁</code>，然后执行插入操作。事实上<span style="color:red">插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁</span>（<code>插入意向锁</code>就是这么鸡肋）。</p>
<ul>
<li><p>隐式锁——<code>事务id</code></p>
<p>我们把聚簇索引和二级索引中的记录分开看一下：</p>
<ul>
<li><p>情景一：对于聚簇索引记录来说，有一个<code>trx_id</code>隐藏列，该隐藏列记录着最后改动该记录的<code>事务id</code>。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的<code>trx_id</code>隐藏列代表的的就是当前事务的<code>事务id</code>，如果其他事务此时想对该记录添加<code>S锁</code>或者<code>X锁</code>时，首先会看一下该记录的<code>trx_id</code>隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个<code>X锁</code>（也就是为当前事务创建一个锁结构，<code>is_waiting</code>属性是<code>false</code>），然后自己进入等待状态（也就是为自己也创建一个锁结构，<code>is_waiting</code>属性是<code>true</code>）。</p>
</li>
<li><p>情景二：对于二级索引记录来说，本身并没有<code>trx_id</code>隐藏列，但是在二级索引页面的<code>Page Header</code>部分有一个<code>PAGE_MAX_TRX_ID</code>属性，该属性代表对该页面做改动的最大的<code>事务id</code>，如果<code>PAGE_MAX_TRX_ID</code>属性值小于当前最小的活跃<code>事务id</code>，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复<code>情景一</code>的做法。</p>
</li>
</ul>
<p>通过上边的叙述我们知道，一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于<code>事务id</code>这个牛逼的东东的存在，相当于加了一个<code>隐式锁</code>。别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nbobj.github.io/blog/mysql/19-%E9%94%81/">https://nbobj.github.io/blog/mysql/19-锁/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nbobj.github.io" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/mysql/undo%20%E6%97%A5%E5%BF%97%20(%E4%B8%8B)/">undo 日志 (下)</a><a class="next" href="/blog/mysql/18-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/">18-事务隔离级别和MVCC</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E9%94%81%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">对锁的简单的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99-%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">1.1.</span> <span class="toc-text">写-写情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB-%E5%86%99%E6%88%96%E5%86%99-%E8%AF%BB%E6%83%85%E5%86%B5"><span class="toc-number">1.2.</span> <span class="toc-text">读-写或写-读情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB%EF%BC%88Consistent-Reads%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">一致性读（Consistent Reads）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB%EF%BC%88Locking-Reads%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">锁定读（Locking Reads）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%AE%9A%E8%AF%BB%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">锁定读的语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">4.</span> <span class="toc-text">操操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%B2%92%E5%BA%A6%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">多粒度锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">InnoDB存储引擎中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84AUTO-INC%E9%94%81"><span class="toc-number">6.1.</span> <span class="toc-text">表级别的AUTO-INC锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">InnoDB中的行级锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/broker%E5%90%AF%E5%8A%A8/" title="broker启动">broker启动</a><time datetime="2022-01-14T00:00:16.000Z" title="发表于 2022-01-14 08:00:16">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/13%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4/" title="13消息过滤">13消息过滤</a><time datetime="2022-01-14T00:00:15.000Z" title="发表于 2022-01-14 08:00:15">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/12broker%E5%A4%84%E7%90%86Consumer%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82/" title="12broker处理Consumer拉取消息请求">12broker处理Consumer拉取消息请求</a><time datetime="2022-01-14T00:00:14.000Z" title="发表于 2022-01-14 08:00:14">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/11%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="11消费者的负载均衡">11消费者的负载均衡</a><time datetime="2022-01-14T00:00:13.000Z" title="发表于 2022-01-14 08:00:13">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/10DefaultMQPushConsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="10DefaultMQPushConsumer源码分析">10DefaultMQPushConsumer源码分析</a><time datetime="2022-01-14T00:00:12.000Z" title="发表于 2022-01-14 08:00:12">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(#0062be)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>