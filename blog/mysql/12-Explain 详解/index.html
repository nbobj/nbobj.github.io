<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>12-Explain 详解 | XYZhi's学习笔记</title><meta name="keywords" content="mysql"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="EXPLAIN语句输出的各个列的作用大致罗列一下：    列名 描述    id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id   select_type SELECT关键字对应的那个查询的类型   table 表名   partitions 匹配的分区信息   type 针对单表的访问方法   possible_keys 可能用到的索引   key 实际上使用的索引   key">
<meta property="og:type" content="article">
<meta property="og:title" content="12-Explain 详解">
<meta property="og:url" content="https://nbobj.github.io/blog/mysql/12-Explain%20%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="EXPLAIN语句输出的各个列的作用大致罗列一下：    列名 描述    id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id   select_type SELECT关键字对应的那个查询的类型   table 表名   partitions 匹配的分区信息   type 针对单表的访问方法   possible_keys 可能用到的索引   key 实际上使用的索引   key">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nbobj.github.io/linear-gradient(#0062be)">
<meta property="article:published_time" content="2021-11-14T00:00:12.000Z">
<meta property="article:modified_time" content="2022-03-23T12:18:13.302Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nbobj.github.io/linear-gradient(#0062be)"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nbobj.github.io/blog/mysql/12-Explain%20%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '12-Explain 详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 20:18:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(#0062be)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">12-Explain 详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-14T00:00:12.000Z" title="发表于 2021-11-14 08:00:12">2021-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T12:18:13.302Z" title="更新于 2022-03-23 20:18:13">2022-03-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="12-Explain 详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>EXPLAIN</code>语句输出的各个列的作用大致罗列一下：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>id</code></td>
<td align="left">在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的<code>id</code></td>
</tr>
<tr>
<td align="center"><code>select_type</code></td>
<td align="left"><code>SELECT</code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td align="center"><code>table</code></td>
<td align="left">表名</td>
</tr>
<tr>
<td align="center"><code>partitions</code></td>
<td align="left">匹配的分区信息</td>
</tr>
<tr>
<td align="center"><code>type</code></td>
<td align="left">针对单表的访问方法</td>
</tr>
<tr>
<td align="center"><code>possible_keys</code></td>
<td align="left">可能用到的索引</td>
</tr>
<tr>
<td align="center"><code>key</code></td>
<td align="left">实际上使用的索引</td>
</tr>
<tr>
<td align="center"><code>key_len</code></td>
<td align="left">实际使用到的索引长度</td>
</tr>
<tr>
<td align="center"><code>ref</code></td>
<td align="left">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td align="center"><code>rows</code></td>
<td align="left">预估的需要读取的记录条数</td>
</tr>
<tr>
<td align="center"><code>filtered</code></td>
<td align="left">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td align="center"><code>Extra</code></td>
<td align="left">一些额外的信息</td>
</tr>
</tbody></table>
<h2 id="执行计划输出中各列详解"><a href="#执行计划输出中各列详解" class="headerlink" title="执行计划输出中各列详解"></a>执行计划输出中各列详解</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，所以<code>MySQL</code>规定&#x3D;&#x3D;EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名&#x3D;&#x3D;</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><ol>
<li><p>在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表</p>
</li>
<li><p>包含子查询的查询语句来说，就可能涉及多个<code>SELECT</code>关键字，所以在包含子查询的查询语句的执行计划中，每个<code>SELECT</code>关键字都会对应一个唯一的<code>id</code>值。值越大的先执行。但是这里大家需要特别注意，<span style="color:red">查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</span>。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了。</p>
</li>
<li><p>对于包含<code>UNION</code>子句的查询语句来说，每个<code>SELECT</code>关键字对应一个<code>id</code>值，对于<code>UNION</code>，会多出一张临时表，来去重。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/4702002116123291683.png" alt="image-20210908011610705"></p>
<p>对于<code>UNION ALL</code> 就不需要这张临时表</p>
</li>
</ol>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>通过上边的内容我们知道，一条大的查询语句里边可以包含若干个<code>SELECT</code>关键字，每个<code>SELECT</code>关键字代表着一个小的查询语句，而每个<code>SELECT</code>关键字的<code>FROM</code>子句中都可以包含若干张表（这些表用来做连接查询），每一张表都对应着执行计划输出中的一条记录，对于在同一个<code>SELECT</code>关键字中的表来说，它们的<code>id</code>值是相同的。</p>
<p>设计<code>MySQL</code>的大叔为每一个<code>SELECT</code>关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中扮演了一个什么角色。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>SIMPLE</code></td>
<td align="left">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td align="center"><code>PRIMARY</code></td>
<td align="left">Outermost SELECT</td>
</tr>
<tr>
<td align="center"><code>UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td align="center"><code>UNION RESULT</code></td>
<td align="left">Result of a UNION</td>
</tr>
<tr>
<td align="center"><code>SUBQUERY</code></td>
<td align="left">First SELECT in subquery</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT SUBQUERY</code></td>
<td align="left">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DEPENDENT UNION</code></td>
<td align="left">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td align="center"><code>DERIVED</code></td>
<td align="left">Derived table</td>
</tr>
<tr>
<td align="center"><code>MATERIALIZED</code></td>
<td align="left">Materialized subquery</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE SUBQUERY</code></td>
<td align="left">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center"><code>UNCACHEABLE UNION</code></td>
<td align="left">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<ul>
<li><p><code>SIMPLE</code>：查询语句中不包含<code>UNION</code>或者子查询的查询都算作是<code>SIMPLE</code>类型</p>
</li>
<li><p><code>PRIMARY</code>：对于包含<code>UNION</code>、<code>UNION ALL</code>或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select * from pic_origin_data_1 where id = 103508989</span><br><span class="line">union </span><br><span class="line">select * from pic_origin_data_1 where id = 103508990</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/4702002116123291684.png" alt="image-20210908012131035"></p>
</li>
<li><p><code>UNION</code>：对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code></p>
</li>
<li><p><code>UNION RESULT</code>：<code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code></p>
</li>
<li><p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;由于select_type为SUBQUERY的子查询由于会被物化，所以只需要执行一遍&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p><code>DEPENDENT SUBQUERY</code>：如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&#x3D;&#x3D;需要大家注意的是，select_type为DEPENDENT SUBQUERY的查询可能会被执行多次&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p><code>DEPENDENT UNION</code>：在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);</span><br></pre></td></tr></table></figure>

<p>这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由<code>UNION</code>连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM s2 WHERE key1 = &#39;a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是<code>DEPENDENT SUBQUERY</code>，而<code>SELECT key1 FROM s1 WHERE key1 = &#39;b&#39;</code>这个查询的<code>select_type</code>就是<code>DEPENDENT UNION</code>。</p>
</li>
<li><p><code>DERIVED</code>：对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">select * from (select seller_id, count(*) from pic_origin_data_1 where id &gt; 103508990 group by seller_id) as tes</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/mysql/4702002116123291685.png" alt="image-20210908013813660"></p>
</li>
<li><p><code>MATERIALIZED</code>：当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>InnoDB</code>存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：</p>
<p><code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code></p>
<ul>
<li><p><code>system</code></p>
<p>当表中只有一条记录并且<span style="color:red">该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory</span>，那么对该表的访问方法就是<code>system</code></p>
</li>
<li><p><code>const</code></p>
<p>当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code></p>
</li>
<li><p><code>eq_ref</code></p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ref</code></p>
<p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是&#96;ref</p>
</li>
<li><p><code>fulltext</code></p>
<p>全文索引</p>
</li>
<li><p><code>ref_or_null</code></p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>index_merge</code></p>
<p>索引合并</p>
</li>
<li><p><code>range</code></p>
<p>使用索引获取某些<code>范围区间</code>的记录</p>
</li>
<li><p><code>index</code></p>
<p>使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是<code>index</code></p>
</li>
</ul>
<blockquote>
<p>&#x3D;&#x3D;possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。&#x3D;&#x3D;</p>
</blockquote>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li>
<li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的东东是个啥，比如只是一个常数或者是某个列。</p>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。</p>
<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><blockquote>
<p>对驱动表进行查询后得到的记录条数称之为驱动表的<code>扇出</code>（英文名：<code>fanout</code>）</p>
</blockquote>
<p>执行计划的<code>filtered</code>列就代表查询优化器预测在这<code>rows</code>条记录中，有多少条记录满足其余的搜索条件，也就是符合条件的记录占总数的百分比。</p>
<p>在连接查询中</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Extra</code>列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解<code>MySQL</code>到底将如何执行给定的查询语句。</p>
<ul>
<li><p><code>No tables used</code></p>
<p>当查询语句的没有<code>FROM</code>子句时将会提示该额外信息</p>
</li>
<li><p><code>Impossible WHERE</code></p>
<p>查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p>
</li>
<li><p><code>No matching min/max row</code></p>
<p>当查询列表处有<code>MIN</code>或者<code>MAX</code>聚集函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息</p>
</li>
<li><p><code>Using index condition</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>

<p>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a&#39;</code>却无法使用到索引，在以前版本的<code>MySQL</code>中，是按照下边步骤来执行这个查询的：</p>
<ul>
<li><p>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</p>
</li>
<li><p>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</p>
</li>
</ul>
<p>但是虽然<code>key1 LIKE &#39;%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以设计<code>MySQL</code>的大叔把上边的步骤改进了一下：</p>
<ul>
<li><p>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</p>
</li>
<li><p>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE &#39;%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</p>
</li>
<li><p>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</p>
</li>
</ul>
<p>我们说回表操作其实是一个随机<code>IO</code>，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。设计<code>MySQL</code>的大叔们把他们的这个改进称之为<code>索引条件下推</code>（英文名：<code>Index Condition Pushdown</code>）。</p>
<p>如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在<code>Extra</code>列中将会显示<code>Using index condition</code></p>
</li>
<li><p><code>Using where</code></p>
<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时</p>
</li>
<li><p><code>Using join buffer (Block Nested Loop)</code></p>
<p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code></p>
</li>
<li><p><code>Using intersect(...)</code>、<code>Using union(...)</code>和<code>Using sort_union(...)</code></p>
<p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称</p>
</li>
<li><p><code>Zero limit</code></p>
<p>当我们的<code>LIMIT</code>子句的参数为<code>0</code>时，表示压根儿不打算从表中读出任何记录</p>
</li>
<li><p><code>Using filesort</code></p>
<p>排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计<code>MySQL</code>的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：<code>filesort</code>）。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的<code>Extra</code>列中显示<code>Using filesort</code>提示</p>
</li>
<li><p><code>Using temporary</code></p>
<p>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示</p>
</li>
</ul>
<h2 id="Json格式的执行计划"><a href="#Json格式的执行计划" class="headerlink" title="Json格式的执行计划"></a>Json格式的执行计划</h2><p>在<code>EXPLAIN</code>单词和真正的查询语句中间加上<code>FORMAT=JSON</code>，会得到一个<code>json</code>格式的执行计划，里边儿包含该计划花费的成本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN FORMAT=JSON SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key2 WHERE s1.common_field = &#x27;a&#x27;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">EXPLAIN: &#123;</span><br><span class="line">  &quot;query_block&quot;: &#123;</span><br><span class="line">    &quot;select_id&quot;: 1,     # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1</span><br><span class="line">    &quot;cost_info&quot;: &#123;</span><br><span class="line">      &quot;query_cost&quot;: &quot;3197.16&quot;   # 整个查询的执行成本预计为3197.16</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nested_loop&quot;: [    # 几个表之间采用嵌套循环连接算法执行</span><br><span class="line">    </span><br><span class="line">    # 以下是参与嵌套循环连接算法的各个表的信息</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s1&quot;,   # s1表是驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ALL&quot;,     # 访问方法为ALL，意味着使用全表扫描访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 9688,   # 查询一次s1表大致需要扫描9688条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 驱动表s1的扇出是968</span><br><span class="line">          &quot;filtered&quot;: &quot;10.00&quot;,  # condition filtering代表的百分比</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;1840.84&quot;,     # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;2034.60&quot;,   # 单次查询s1表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ],</span><br><span class="line">          </span><br><span class="line">          # 对s1表访问时针对单表查询的条件</span><br><span class="line">          &quot;attached_condition&quot;: &quot;((`xiaohaizi`.`s1`.`common_field` = &#x27;a&#x27;) and (`xiaohaizi`.`s1`.`key1` is not null))&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;table&quot;: &#123;</span><br><span class="line">          &quot;table_name&quot;: &quot;s2&quot;,   # s2表是被驱动表</span><br><span class="line">          &quot;access_type&quot;: &quot;ref&quot;,     # 访问方法为ref，意味着使用索引等值匹配的方式访问</span><br><span class="line">          &quot;possible_keys&quot;: [    # 可能使用的索引</span><br><span class="line">            &quot;idx_key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key&quot;: &quot;idx_key2&quot;,    # 实际使用的索引</span><br><span class="line">          &quot;used_key_parts&quot;: [   # 使用到的索引列</span><br><span class="line">            &quot;key2&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;key_length&quot;: &quot;5&quot;,    # key_len</span><br><span class="line">          &quot;ref&quot;: [      # 与key2列进行等值匹配的对象</span><br><span class="line">            &quot;xiaohaizi.s1.key1&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;rows_examined_per_scan&quot;: 1,  # 查询一次s2表大致需要扫描1条记录</span><br><span class="line">          &quot;rows_produced_per_join&quot;: 968,    # 被驱动表s2的扇出是968（由于后边没有多余的表进行连接，所以这个值也没啥用）</span><br><span class="line">          &quot;filtered&quot;: &quot;100.00&quot;,     # condition filtering代表的百分比</span><br><span class="line">          </span><br><span class="line">          # s2表使用索引进行查询的搜索条件</span><br><span class="line">          &quot;index_condition&quot;: &quot;(`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key2`)&quot;,</span><br><span class="line">          &quot;cost_info&quot;: &#123;</span><br><span class="line">            &quot;read_cost&quot;: &quot;968.80&quot;,      # 稍后解释</span><br><span class="line">            &quot;eval_cost&quot;: &quot;193.76&quot;,      # 稍后解释</span><br><span class="line">            &quot;prefix_cost&quot;: &quot;3197.16&quot;,   # 单次查询s1、多次查询s2表总共的成本</span><br><span class="line">            &quot;data_read_per_join&quot;: &quot;1M&quot;  # 读取的数据量</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;used_columns&quot;: [     # 执行查询中涉及到的列</span><br><span class="line">            &quot;id&quot;,</span><br><span class="line">            &quot;key1&quot;,</span><br><span class="line">            &quot;key2&quot;,</span><br><span class="line">            &quot;key3&quot;,</span><br><span class="line">            &quot;key_part1&quot;,</span><br><span class="line">            &quot;key_part2&quot;,</span><br><span class="line">            &quot;key_part3&quot;,</span><br><span class="line">            &quot;common_field&quot;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>看下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;cost_info&quot;: &#123;</span><br><span class="line">    &quot;read_cost&quot;: &quot;1840.84&quot;,</span><br><span class="line">    &quot;eval_cost&quot;: &quot;193.76&quot;,</span><br><span class="line">    &quot;prefix_cost&quot;: &quot;2034.60&quot;,</span><br><span class="line">    &quot;data_read_per_join&quot;: &quot;1M&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>read_cost</code>是由下边这两部分组成的：</p>
<ul>
<li><code>IO</code>成本</li>
<li>检测<code>rows × (1 - filter)</code>条记录的<code>CPU</code>成本</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>rows和filter都是我们前边介绍执行计划的输出列，在JSON格式的执行计划中，rows相当于rows_examined_per_scan，filtered名称不变。</p>
</blockquote>
</li>
<li><p><code>eval_cost</code></p>
<p>检测 <code>rows × filter</code>条记录的成本</p>
</li>
<li><p><code>prefix_cost</code>就是单独查询<code>s1</code>表的成本，也就是：</p>
<p><code>read_cost + eval_cost</code> </p>
</li>
<li><p><code>data_read_per_join</code>表示在此次查询中需要读取的数据量，我们就不多唠叨这个了。</p>
</li>
</ul>
<blockquote>
<p>关注prefix_cost是查询s1表的成本就好了。</p>
</blockquote>
<h3 id="Extented-EXPLAIN"><a href="#Extented-EXPLAIN" class="headerlink" title="Extented EXPLAIN"></a>Extented EXPLAIN</h3><p>在我们使用<code>EXPLAIN</code>语句查看了某个查询的执行计划后，紧接着还可以使用<code>SHOW WARNINGS</code>语句查看与这个查询的执行计划有关的一些扩展信息，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT s1.key1, s2.key1 FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.common_field IS NOT NULL;</span><br><span class="line">.....</span><br><span class="line">.....</span><br><span class="line">ysql&gt; SHOW WARNINGS\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Level: Note</span><br><span class="line">   Code: 1003</span><br><span class="line">Message: /* select#1 */ select `xiaohaizi`.`s1`.`key1` AS `key1`,`xiaohaizi`.`s2`.`key1` AS `key1` from `xiaohaizi`.`s1` join `xiaohaizi`.`s2` where ((`xiaohaizi`.`s1`.`key1` = `xiaohaizi`.`s2`.`key1`) and (`xiaohaizi`.`s2`.`common_field` is not null))</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>SHOW WARNINGS</code>展示出来的信息有三个字段，分别是<code>Level</code>、<code>Code</code>、<code>Message</code>。我们最常见的就是<code>Code</code>为<code>1003</code>的信息，当<code>Code</code>值为<code>1003</code>时，<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句。</p>
<p>但是一定要注意，我们说<code>Message</code>字段展示的信息<span style="color:red">类似于</span>查询优化器将我们的查询语句重写后的语句，并不是等价于，也就是说<code>Message</code>字段展示的信息并不是标准的查询语句，在很多情况下并不能直接拿到黑框框中运行，它只能作为帮助我们理解查<code>MySQL</code>将如何执行查询语句的一个参考依据而已。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nbobj.github.io/blog/mysql/12-Explain%20%E8%AF%A6%E8%A7%A3/">https://nbobj.github.io/blog/mysql/12-Explain 详解/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nbobj.github.io" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/mysql/13-%E6%9F%A5%E7%9C%8B%E7%94%9F%E6%88%90%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%BF%87%E7%A8%8B---optimizer%20trace/">13-查看生成执行计划过程---optimizer trace</a><a class="next" href="/blog/mysql/11-%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96/">11-基于规则的优化</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">410</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%BE%93%E5%87%BA%E4%B8%AD%E5%90%84%E5%88%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">执行计划输出中各列详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#table"><span class="toc-number">1.1.</span> <span class="toc-text">table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#id"><span class="toc-number">1.2.</span> <span class="toc-text">id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select-type"><span class="toc-number">1.3.</span> <span class="toc-text">select_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type"><span class="toc-number">1.4.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len"><span class="toc-number">1.5.</span> <span class="toc-text">key_len</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">1.6.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rows"><span class="toc-number">1.7.</span> <span class="toc-text">rows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filtered"><span class="toc-number">1.8.</span> <span class="toc-text">filtered</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Extra"><span class="toc-number">1.9.</span> <span class="toc-text">Extra</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">2.</span> <span class="toc-text">Json格式的执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extented-EXPLAIN"><span class="toc-number">2.1.</span> <span class="toc-text">Extented EXPLAIN</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/broker%E5%90%AF%E5%8A%A8/" title="broker启动">broker启动</a><time datetime="2022-01-14T00:00:16.000Z" title="发表于 2022-01-14 08:00:16">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/13%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4/" title="13消息过滤">13消息过滤</a><time datetime="2022-01-14T00:00:15.000Z" title="发表于 2022-01-14 08:00:15">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/12broker%E5%A4%84%E7%90%86Consumer%E6%8B%89%E5%8F%96%E6%B6%88%E6%81%AF%E8%AF%B7%E6%B1%82/" title="12broker处理Consumer拉取消息请求">12broker处理Consumer拉取消息请求</a><time datetime="2022-01-14T00:00:14.000Z" title="发表于 2022-01-14 08:00:14">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/11%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="11消费者的负载均衡">11消费者的负载均衡</a><time datetime="2022-01-14T00:00:13.000Z" title="发表于 2022-01-14 08:00:13">2022-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/rocketmq/10DefaultMQPushConsumer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="10DefaultMQPushConsumer源码分析">10DefaultMQPushConsumer源码分析</a><time datetime="2022-01-14T00:00:12.000Z" title="发表于 2022-01-14 08:00:12">2022-01-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(#0062be)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>