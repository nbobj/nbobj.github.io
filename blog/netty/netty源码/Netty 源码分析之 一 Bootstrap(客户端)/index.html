<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Netty 源码分析之 一 Bootstrap(客户端) | XYZhi's学习笔记</title><meta name="keywords" content="netty"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于4.1.59 注意：netty的源码阅读都是根据java 的 Nio讲解的，如果是别的比如epoll，在对应的Channel和Group类上会有差别，不过整体的流程是一样的  123456789101112131415161718EventLoopGroup group &#x3D; new NioEventLoopGroup();try &amp;#123;  Bootstrap b &#x3D; new Boots">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 源码分析之 一 Bootstrap(客户端)">
<meta property="og:url" content="http://sv.pointcut.cc/blog/netty/netty%E6%BA%90%E7%A0%81/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%80%20Bootstrap(%E5%AE%A2%E6%88%B7%E7%AB%AF)/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="基于4.1.59 注意：netty的源码阅读都是根据java 的 Nio讲解的，如果是别的比如epoll，在对应的Channel和Group类上会有差别，不过整体的流程是一样的  123456789101112131415161718EventLoopGroup group &#x3D; new NioEventLoopGroup();try &amp;#123;  Bootstrap b &#x3D; new Boots">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://sv.pointcut.cc/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)">
<meta property="article:published_time" content="2021-11-23T12:00:17.000Z">
<meta property="article:modified_time" content="2022-03-23T09:03:58.208Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://sv.pointcut.cc/linear-gradient(20deg,%20#0062be,%20#925696,%20#cc426e,%20#fb0347)"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://sv.pointcut.cc/blog/netty/netty%E6%BA%90%E7%A0%81/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%80%20Bootstrap(%E5%AE%A2%E6%88%B7%E7%AB%AF)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"KRWXKP6RR8","apiKey":"c59315b71275333a604a497c8e21f06c","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Netty 源码分析之 一 Bootstrap(客户端)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 17:03:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">301</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty 源码分析之 一 Bootstrap(客户端)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-23T12:00:17.000Z" title="发表于 2021-11-23 20:00:17">2021-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T09:03:58.208Z" title="更新于 2022-03-23 17:03:58">2022-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty 源码分析之 一 Bootstrap(客户端)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>基于4.1.59</p>
<p>注意：netty的源码阅读都是根据java 的 Nio讲解的，如果是别的比如epoll，在对应的Channel和Group类上会有差别，不过整体的流程是一样的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">Bootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">  b.group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .remoteAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;127.0.1.1&quot;</span>, port))</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ch.pipeline().addFirst(<span class="keyword">new</span> <span class="title class_">EchoClientHandler</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  b.connect().addListener((ChannelFutureListener)(future) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;已经执行完了&quot;</span>);</span><br><span class="line">  &#125;).channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  group.shutdownGracefully().sync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的客户端代码虽然简单, 但是却展示了 Netty 客户端初始化时所需的所有内容:</p>
<ol>
<li>EventLoopGroup: 不论是服务器端还是客户端, 都必须指定 EventLoopGroup. 在这个例子中, 指定了 NioEventLoopGroup, 表示一个 NIO 的EventLoopGroup.</li>
<li>ChannelType: 指定 Channel 的类型. 因为是客户端, 因此使用了 NioSocketChannel.</li>
<li>Handler: 设置数据的处理器.</li>
<li>Bootstrap: 用来连接服务。封装并隐藏网络io的细节</li>
</ol>
<h2 id="NioSocketChannel-的初始化过程"><a href="#NioSocketChannel-的初始化过程" class="headerlink" title="NioSocketChannel 的初始化过程"></a>NioSocketChannel 的初始化过程</h2><p>在 Netty 中, Channel 是一个 Socket 的抽象, 它为用户提供了关于 Socket 状态(是否是连接还是断开) 以及对 Socket 的读写等操作. 每当 Netty 建立了一个连接后, 都会有一个对应的 Channel 实例.</p>
<p>NioSocketChannel 的类层次结构如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427469.png" alt="image-20210227230400860"></p>
<h3 id="ChannelFactory-和-Channel-类型的确定"><a href="#ChannelFactory-和-Channel-类型的确定" class="headerlink" title="ChannelFactory 和 Channel 类型的确定"></a>ChannelFactory 和 Channel 类型的确定</h3><p>除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 OIO(Old-IO, 即传统的阻塞 IO) 版本的区别. 不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应下面是一些常用的 Channel 类型:</p>
<ul>
<li>NioSocketChannel, 代表异步的客户端 TCP Socket 连接.</li>
<li>NioServerSocketChannel, 异步的服务器端 TCP Socket 连接.</li>
<li>NioDatagramChannel, 异步的 UDP 连接</li>
<li>NioSctpChannel, 异步的客户端 Sctp 连接.</li>
<li>NioSctpServerChannel, 异步的 Sctp 服务器端连接.</li>
<li>OioSocketChannel, 同步的客户端 TCP Socket 连接.</li>
<li>OioServerSocketChannel, 同步的服务器端 TCP Socket 连接.</li>
<li>OioDatagramChannel, 同步的 UDP 连接</li>
<li>OioSctpChannel, 同步的 Sctp 服务器端连接.</li>
<li>OioSctpServerChannel, 同步的客户端 TCP Socket 连接.</li>
</ul>
<p>那么我们是如何设置所需要的 Channel 的类型的呢? 答案是 channel() 方法的调用.回想一下我们在客户端连接代码的初始化 Bootstrap 中, 会调用 channel() 方法, 传入 <code>NioSocketChannel.class</code>, 这个方法其实就是初始化了一个 <code>ReflectiveChannelFactory</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置Channel的类型，在netty中，Channel是一个Socket抽象，它为用户提供了关于Socket的状态和读写的操作，每当Netty建立一个</span></span><br><span class="line"><span class="comment"> * 连接后，都会有一个对应的Channel实例，而这个Channel的实例类型就是通过这个方法确定了。</span></span><br><span class="line"><span class="comment"> * 通过对方法的跟踪</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> Class&#125; which is used to create &#123;<span class="doctag">@link</span> Channel&#125; instances from.</span></span><br><span class="line"><span class="comment"> * You either use this or &#123;<span class="doctag">@link</span> #channelFactory(io.netty.channel.ChannelFactory)&#125; if your</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Channel&#125; implementation has no no-args constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">     <span class="comment">//最后将ReflectiveChannelFactory赋值给内部的属性，channelFactory</span></span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>ReflectiveChannelFactory</code> 实现了 <code>ChannelFactory</code> 接口, 它提供了唯一的方法, 即 <strong>newChannel</strong>. ChannelFactory, 顾名思义, 就是产生 Channel 的工厂类.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类的无参构造方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) +</span><br><span class="line">                    <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">newChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtil.simpleClassName(ReflectiveChannelFactory.class) +</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span> + StringUtil.simpleClassName(constructor.getDeclaringClass()) + <span class="string">&quot;.class)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码, 我们就可以确定:</p>
<ul>
<li><p>Bootstrap 中的 ChannelFactory 的实现是 ReflectiveChannelFactory</p>
</li>
<li><p>生成的 Channel 的具体类型是 NioSocketChannel.</p>
<p>Channel 的实例化过程, 其实就是调用的 ChannelFactory#newChannel 方法, 而实例化的 Channel 的具体的类型又是和在初始化 Bootstrap 时传入的 channel() 方法的参数相关. 因此对于我们这个例子中的客户端的 Bootstrap 而言, 生成的的 Channel 实例就是 NioSocketChannel.</p>
</li>
</ul>
<h3 id="Channel-实例化"><a href="#Channel-实例化" class="headerlink" title="Channel 实例化"></a>Channel 实例化</h3><p>前面我们已经知道了如何确定一个 Channel 的类型, 并且了解到 Channel 是通过工厂方法 ChannelFactory.newChannel() 来实例化的, 那么 ChannelFactory.newChannel() 方法在哪里调用呢?</p>
<p>继续跟踪, 我们发现其调用链是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap.connect -&gt; Bootstrap.doResolveAndConnect -&gt; AbstractBootstrap.initAndRegister</span><br></pre></td></tr></table></figure>

<p>在 AbstractBootstrap.initAndRegister 中就调用了 <strong>channelFactory().newChannel()</strong> 来获取一个新的 NioSocketChannel 实例, 其源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong>newChannel</strong> 中, 通过类对象的 newInstance 来获取一个新 Channel 实例, 因而会调用NioSocketChannel 的无参构造器.<br>NioSocketChannel 默认构造器代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SelectorProvider</span> <span class="variable">DEFAULT_SELECTOR_PROVIDER</span> <span class="operator">=</span> SelectorProvider.provider</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(DEFAULT_SELECTOR_PROVIDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(newSocket(provider));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(SocketChannel socket)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(<span class="literal">null</span>, socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(parent, socket);</span><br><span class="line">  config = <span class="keyword">new</span> <span class="title class_">NioSocketChannelConfig</span>(<span class="built_in">this</span>, socket.socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>这里的代码比较关键</code>, 我们看到, 在这个构造器中, 会调用 <strong>newSocket</strong> 来打开一个新的 Java NIO SocketChannel:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SocketChannel <span class="title function_">newSocket</span><span class="params">(SelectorProvider provider)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> provider.openSocketChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会调用父类, 即 AbstractNioByteChannel 的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SelectableChannel是java NIO SocketChannel和ServerSocketChannel的共同父类</span></span><br><span class="line"><span class="comment">//在这里，ch是SocketChannel</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着会继续调用父类 AbstractNioChannel 的构造器, 并传入了参数 <strong>readInterestOp &#x3D; SelectionKey.OP_READ</strong>,表示这Channel关注读事件（这里只是一个简单的赋值，还没有把OP_READ注册到selector中）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent            the parent &#123;<span class="doctag">@link</span> Channel&#125; by which this instance was created. May be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ch                the underlying &#123;<span class="doctag">@link</span> SelectableChannel&#125; on which it operates</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readInterestOp    the ops to set to receive data from the &#123;<span class="doctag">@link</span> SelectableChannel&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="type">int</span> readInterestOp)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="built_in">this</span>.ch = ch;</span><br><span class="line">    <span class="built_in">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                        <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChannelException</span>(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> *        the parent of this channel. &#123;<span class="doctag">@code</span> null&#125; if there&#x27;s no parent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractChannel</span><span class="params">(Channel parent)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有4点要关注：</p>
<ol>
<li><p>每个Channel都有一个id，类型是ChannelId，从名字就可以知道，这是代表了Chanel的id</p>
</li>
<li><p>创建了一个unsafe对象，这个unsafe对象是<code>NioSocketChannelUnsafe</code>（在NioSocketChannel中实现了newUnsafe方法）</p>
<blockquote>
<p>这个ChannelUnsafe是对处理IO事件的抽象</p>
</blockquote>
</li>
<li><p>每个Channel都有一个pipeline，这个对象类型是<code>DefaultChannelPipeline</code>。这里说明每一个Channel都有一个自己的pipeline，并且在Channel创建时自动创建。</p>
</li>
<li><p>传入了关注的事件，这里是读事件，并把该事件的值赋值给了<code>readInterestOp</code>属性，表示这个创建的Channel关注的是网络IO操作（注意，这里只是赋值操作）</p>
<blockquote>
<p>之所以还没关注<code>OP_CONNECT</code>，是因为启动流程还没结束，这里只是一个简单的赋值，还没有注册到一个selector中，而且还需要为Channel分配一个EventLoop。</p>
</blockquote>
</li>
</ol>
<p>到这里, 一个完整的 NioSocketChannel 就初始化完成了, 我们可以稍微总结一下构造一个 NioSocketChannel 所需要做的工作:</p>
<ul>
<li><p>调用 NioSocketChannel.newSocket(SelectorProvider) 创建一个新的 Java NIO SocketChannel</p>
</li>
<li><p>AbstractChannel(Channel parent) 中初始化 AbstractChannel 的属性:</p>
<ul>
<li>parent 属性置为 null</li>
<li>unsafe 通过newUnsafe() 实例化一个 unsafe 对象, 它的类型是 NioSocketChannel内部中定义的类型为<code>NioSocketChannelUnsafe</code> 的内部类</li>
<li>ChannelId id &#x3D; new DefaultChannelId();</li>
<li>pipeline &#x3D; new DefaultChannelPipeline(this) 。</li>
</ul>
</li>
<li><p>AbstractNioChannel 中的属性:</p>
<ul>
<li><p>SelectableChannel ch 被设置为 Java SocketChannel, 即NioSocketChannel#newSocket 返回的 Java NIO SocketChannel.</p>
</li>
<li><p>readInterestOp 被设置为 SelectionKey.OP_READ。</p>
</li>
<li><p>SelectableChannel ch 被配置为非阻塞的 **ch.configureBlocking(false)**NioSocketChannel 中的属性:</p>
</li>
</ul>
</li>
<li><p>NioSocketChannel 中的属性:</p>
<ul>
<li>SocketChannelConfig config &#x3D; new NioSocketChannelConfig(this, socket.socket())  ，这个对应是用来保存Bootstrap#handler、Bootstrap#attr和Bootstrap#option这三个方法设置的属性</li>
</ul>
</li>
</ul>
<h3 id="关于-unsafe-字段的初始化"><a href="#关于-unsafe-字段的初始化" class="headerlink" title="关于 unsafe 字段的初始化"></a>关于 unsafe 字段的初始化</h3><p>unsafe 特别关键, 它封装了对 Java 底层 Socket 的操作, 因此实际上是沟通 Netty 上层和 Java 底层的重要的桥梁。(在juc中，会把一些需要使用native的方法的操作（jvm和系统层）放到一个类中，这些累创建对象的属性名都喜欢加个unsafe)</p>
<p>那么我们就来看一下 Unsafe 接口所提供的方法吧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the assigned &#123;<span class="doctag">@link</span> RecvByteBufAllocator.Handle&#125; which will be used to allocate &#123;<span class="doctag">@link</span> ByteBuf&#125;&#x27;s when</span></span><br><span class="line"><span class="comment">     * receiving data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RecvByteBufAllocator.Handle <span class="title function_">recvBufAllocHandle</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which is bound local or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; if none.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SocketAddress <span class="title function_">localAddress</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the &#123;<span class="doctag">@link</span> SocketAddress&#125; to which is bound remote or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; if none is bound yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SocketAddress <span class="title function_">remoteAddress</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> ChannelFuture&#125; once the registration was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bind the &#123;<span class="doctag">@link</span> SocketAddress&#125; to the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify</span></span><br><span class="line"><span class="comment">     * it once its done.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect the &#123;<span class="doctag">@link</span> Channel&#125; of the given &#123;<span class="doctag">@link</span> ChannelFuture&#125; with the given remote &#123;<span class="doctag">@link</span> SocketAddress&#125;.</span></span><br><span class="line"><span class="comment">     * If a specific local &#123;<span class="doctag">@link</span> SocketAddress&#125; should be used it need to be given as argument. Otherwise just</span></span><br><span class="line"><span class="comment">     * pass &#123;<span class="doctag">@code</span> null&#125; to it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> ChannelPromise&#125; will get notified once the connect operation was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Disconnect the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelFuture&#125; and notify the &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the</span></span><br><span class="line"><span class="comment">     * operation was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Close the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; and notify the &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the</span></span><br><span class="line"><span class="comment">     * operation was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes the &#123;<span class="doctag">@link</span> Channel&#125; immediately without firing any events.  Probably only useful</span></span><br><span class="line"><span class="comment">     * when registration attempt failed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">closeForcibly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deregister the &#123;<span class="doctag">@link</span> Channel&#125; of the &#123;<span class="doctag">@link</span> ChannelPromise&#125; from &#123;<span class="doctag">@link</span> EventLoop&#125; and notify the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ChannelPromise&#125; once the operation was complete.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deregister</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules a read operation that fills the inbound buffer of the first &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.  If there&#x27;s already a pending read operation, this method does nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beginRead</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Schedules a write operation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, ChannelPromise promise)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flush out all write operations scheduled via &#123;<span class="doctag">@link</span> #write(Object, ChannelPromise)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a special ChannelPromise which can be reused and passed to the operations in &#123;<span class="doctag">@link</span> Unsafe&#125;.</span></span><br><span class="line"><span class="comment">     * It will never be notified of a success or error and so is only a placeholder for operations</span></span><br><span class="line"><span class="comment">     * that take a &#123;<span class="doctag">@link</span> ChannelPromise&#125; as argument but for which you not want to get notified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ChannelPromise <span class="title function_">voidPromise</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the &#123;<span class="doctag">@link</span> ChannelOutboundBuffer&#125; of the &#123;<span class="doctag">@link</span> Channel&#125; where the pending write requests are stored.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ChannelOutboundBuffer <span class="title function_">outboundBuffer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    SocketAddress <span class="title function_">localAddress</span><span class="params">()</span>;</span><br><span class="line">    SocketAddress <span class="title function_">remoteAddress</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">disconnect</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">closeForcibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deregister</span><span class="params">(ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beginRead</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, ChannelPromise promise)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">    ChannelPromise <span class="title function_">voidPromise</span><span class="params">()</span>;</span><br><span class="line">    ChannelOutboundBuffer <span class="title function_">outboundBuffer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一看便知, 这些方法其实都会对应到相关的 Java 底层的 Socket 的操作.</p>
<h3 id="关于-pipeline-的初始化"><a href="#关于-pipeline-的初始化" class="headerlink" title="关于 pipeline 的初始化"></a>关于 pipeline 的初始化</h3><p>在实例化一个 Channel 时, 必然伴随着实例化一个 ChannelPipeline. 而我们确实在 AbstractChannel 的构造器看到了 pipeline 字段被初始化为 DefaultChannelPipeline 的实例. 那么我们就来看一下, DefaultChannelPipeline 构造器做了哪些工作吧:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> <span class="title class_">SucceededChannelFuture</span>(channel, <span class="literal">null</span>);</span><br><span class="line">    voidPromise =  <span class="keyword">new</span> <span class="title class_">VoidChannelPromise</span>(channel, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> <span class="title class_">TailContext</span>(<span class="built_in">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> <span class="title class_">HeadContext</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们调用 DefaultChannelPipeline 的构造器, 传入了一个 channel, 而这个 channel 其实就是我们实例化的 NioSocketChannel, DefaultChannelPipeline 会将这个 NioSocketChannel 对象保存在channel 字段中. DefaultChannelPipeline 中, 还有两个特殊的字段, 即 head 和 tail, 而这两个字段是一个双向链表的头和尾. 其实在 DefaultChannelPipeline 中, 维护了一个以 AbstractChannelHandlerContext 为节点的双向链表, 这个链表是 Netty 实现 Pipeline 机制的关键。</p>
<blockquote>
<p>我们都知道，ChannelPipeline提供了ChannelHandler链的容器，并定义了用于在该链上传播入站和出站事件流的API。而再看看TailContext和HeadContext</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427470.png" alt="image-20210227235609441"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427471.png" alt="image-20210227235642945"></p>
<p>我们可以看到, 链表中 head 是一个 <strong>ChannelOutboundHandler</strong>、<strong>ChannelInboundHandler</strong>, 而 tail 则是一个 <strong>ChannelInboundHandler</strong>.这说明了pipeline的入站、出站总是会流经head。入站总是会流经tail</p>
<p>注意，虽然HandlerContext也实现了<strong>ChannelOutboundHandler</strong>、<strong>ChannelInboundHandler</strong>接口，但是HandlerContext是作为Handler和pipeline绑定的桥梁，只是表示事件都能流经handlerContext，是否处理还需要看Handler实现的接口。</p>
</blockquote>
<h4 id="接着看一下-HeadContext-的构造器"><a href="#接着看一下-HeadContext-的构造器" class="headerlink" title="接着看一下 HeadContext 的构造器"></a>接着看一下 HeadContext 的构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">  <span class="built_in">super</span>(pipeline, <span class="literal">null</span>, HEAD_NAME, HeadContext.class);</span><br><span class="line">  unsafe = pipeline.channel().unsafe();</span><br><span class="line">  setAddComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了父类 AbstractChannelHandlerContext 的构造器.</p>
<p>把在创建Channel时创建的NioSocketChannelUnsafe赋值给了HeadContext，前面已经说了unsafe封装了对 Java 底层 Socket 的操作，而把它赋值给HeadContext，而且HeadContext实现了<strong>ChannelOutboundHandler</strong>和<strong>ChannelInboundHandler</strong>，想到了什么？没错，就是HeadContext作为pipeline的头结点（<strong>ChannelInboundHandler</strong>链的头结点、<strong>ChannelOutboundHandler</strong>链的最后一个结点）负责从SocketChannel中读数据，使数据能流经之后的<strong>ChannelInboundHandler</strong>；把前面的<strong>ChannelOutboundHandler</strong>处理过的数据发送给目标机器(SocketChannel.write)。<font color="red">注意：虽然从这些值推出了它的作用，但实际的读数据和写数据不是在HeadContext中操作的，真实的操作流程在之后会讲</font></p>
<p>&#x3D;&#x3D;执行了setAddComplete()&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">setAddComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldState</span> <span class="operator">=</span> handlerState;</span><br><span class="line">        <span class="keyword">if</span> (oldState == REMOVE_COMPLETE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Ensure we never update when the handlerState is REMOVE_COMPLETE already.</span></span><br><span class="line">        <span class="comment">// oldState is usually ADD_PENDING but can also be REMOVE_COMPLETE when an EventExecutor is used that is not</span></span><br><span class="line">        <span class="comment">// exposing ordering guarantees.</span></span><br><span class="line">        <span class="keyword">if</span> (HANDLER_STATE_UPDATER.compareAndSet(<span class="built_in">this</span>, oldState, ADD_COMPLETE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挺简单的，就是用cas+循环（避免使用锁）把这个Handler的属性handlerState设为ADD_COMPLETE，表示添加HeadContext完成</p>
<p>&#x3D;&#x3D;现在回头看下父类 AbstractChannelHandlerContext 的构造器。&#x3D;&#x3D;</p>
<p>这个方法挺有趣的，从这个方法就可以知道为什么事件pipeling流经时，能知道下一个Handler能不能处理。下面看下AbstractChannelHandlerContext 的构造器源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor,</span><br><span class="line">                              String name, Class&lt;? <span class="keyword">extends</span> <span class="title class_">ChannelHandler</span>&gt; handlerClass) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    <span class="built_in">this</span>.executionMask = mask(handlerClass);</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="literal">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pipeline的executionMask属性"><a href="#pipeline的executionMask属性" class="headerlink" title="pipeline的executionMask属性"></a>pipeline的executionMask属性</h4><p>重点：mask(handlerClass)，在HeadContext中调用也就是handlerClass是HeadContext的类对象(HeadContext.class)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mask</span><span class="params">(Class&lt;? extends ChannelHandler&gt; clazz)</span> &#123;</span><br><span class="line">    <span class="comment">// Try to obtain the mask from the cache first. If this fails calculate it and put it in the cache for fast</span></span><br><span class="line">    <span class="comment">// lookup in the future.</span></span><br><span class="line">    Map&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">ChannelHandler</span>&gt;, Integer&gt; cache = MASKS.get();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">mask</span> <span class="operator">=</span> cache.get(clazz);</span><br><span class="line">    <span class="keyword">if</span> (mask == <span class="literal">null</span>) &#123;</span><br><span class="line">        mask = mask0(clazz);</span><br><span class="line">        cache.put(clazz, mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mask0</span><span class="params">(Class&lt;? extends ChannelHandler&gt; handlerType)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> MASK_EXCEPTION_CAUGHT;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ChannelInboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_INBOUND;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelRegistered&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">              <span class="comment">// 这段代码的作用就是把对应的位置设置为0</span></span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_REGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelUnregistered&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_UNREGISTERED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelActive&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelInactive&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_INACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelRead&quot;</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelReadComplete&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_READ_COMPLETE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;channelWritabilityChanged&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;userEventTriggered&quot;</span>, ChannelHandlerContext.class, Object.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_USER_EVENT_TRIGGERED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ChannelOutboundHandler.class.isAssignableFrom(handlerType)) &#123;</span><br><span class="line">            mask |= MASK_ALL_OUTBOUND;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;bind&quot;</span>, ChannelHandlerContext.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_BIND;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;connect&quot;</span>, ChannelHandlerContext.class, SocketAddress.class,</span><br><span class="line">                    SocketAddress.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;disconnect&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DISCONNECT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;close&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_CLOSE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;deregister&quot;</span>, ChannelHandlerContext.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_DEREGISTER;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;read&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;write&quot;</span>, ChannelHandlerContext.class,</span><br><span class="line">                    Object.class, ChannelPromise.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_WRITE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;flush&quot;</span>, ChannelHandlerContext.class)) &#123;</span><br><span class="line">                mask &amp;= ~MASK_FLUSH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSkippable(handlerType, <span class="string">&quot;exceptionCaught&quot;</span>, ChannelHandlerContext.class, Throwable.class)) &#123;</span><br><span class="line">            mask &amp;= ~MASK_EXCEPTION_CAUGHT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Should never reach here.</span></span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSkippable</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> Class&lt;?&gt; handlerType, <span class="keyword">final</span> String methodName, <span class="keyword">final</span> Class&lt;?&gt;... paramTypes)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            Method m;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                m = handlerType.getMethod(methodName, paramTypes);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(</span><br><span class="line">                        <span class="string">&quot;Class &#123;&#125; missing method &#123;&#125;, assume we can not skip execution&quot;</span>, handlerType, methodName, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 判断方法是否有Skip这个注解</span></span><br><span class="line">            <span class="keyword">return</span> m.isAnnotationPresent(Skip.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using to mask which methods must be called for a ChannelHandler.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_EXCEPTION_CAUGHT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_REGISTERED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_UNREGISTERED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_ACTIVE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_INACTIVE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_READ_COMPLETE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_USER_EVENT_TRIGGERED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CHANNEL_WRITABILITY_CHANGED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_BIND</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">9</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_DISCONNECT</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_CLOSE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_DEREGISTER</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_READ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">14</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_WRITE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">15</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_FLUSH</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_ONLY_INBOUND</span> <span class="operator">=</span>  MASK_CHANNEL_REGISTERED |</span><br><span class="line">        MASK_CHANNEL_UNREGISTERED | MASK_CHANNEL_ACTIVE | MASK_CHANNEL_INACTIVE | MASK_CHANNEL_READ |</span><br><span class="line">        MASK_CHANNEL_READ_COMPLETE | MASK_USER_EVENT_TRIGGERED | MASK_CHANNEL_WRITABILITY_CHANGED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_ALL_INBOUND</span> <span class="operator">=</span> MASK_EXCEPTION_CAUGHT | MASK_ONLY_INBOUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_ONLY_OUTBOUND</span> <span class="operator">=</span>  MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |</span><br><span class="line">        MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK_ALL_OUTBOUND</span> <span class="operator">=</span> MASK_EXCEPTION_CAUGHT | MASK_ONLY_OUTBOUND;</span><br></pre></td></tr></table></figure>

<p>注意：类对象的getMethod只能获取</p>
<p>上面代码的意思就是使用17个bit(mask)来表示对应的操作，比如mask数值如下：</p>
<table>
<thead>
<tr>
<th align="center">16</th>
<th align="center">15</th>
<th align="center">14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>并把这个mask值赋值给了Handler的executionMask属性。就代表了这个handler可以执行channelRegistered、channelUnregistered、channelActive、channelInactive和channelRead这些方法。</p>
<p>而且，默认情况下都是为1的，表示都会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mask |= MASK_ALL_INBOUND;</span><br><span class="line">mask |= MASK_ALL_OUTBOUND;</span><br></pre></td></tr></table></figure>

<p>只有在方法上添加了@ChannelHandlerMask.Skip 注解后，才会把对应的位设置为0</p>
<h4 id="接着看一下-TailContext-的构造器"><a href="#接着看一下-TailContext-的构造器" class="headerlink" title="接着看一下 TailContext 的构造器"></a>接着看一下 TailContext 的构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TailContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">  <span class="built_in">super</span>(pipeline, <span class="literal">null</span>, TAIL_NAME, TailContext.class);</span><br><span class="line">  setAddComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面已经说过了，不过这里有一个非常不同的地方，就是TailContext不持有unsafe对象，也就是说TailContext对象不会处理真实的socket操作。</p>
<h2 id="关于-EventLoopGroup-初始化"><a href="#关于-EventLoopGroup-初始化" class="headerlink" title="关于 EventLoopGroup 初始化"></a>关于 EventLoopGroup 初始化</h2><p>回到最开始的 EchoClient.java 代码中, 我们在一开始就实例化了一个 NioEventLoopGroup 对象, 因此我们就从它的构造器中追踪一下 EventLoop 的初始化过程.<br>首先来看一下 NioEventLoopGroup 的类继承层次:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427472.png" alt="image-20210228010958453"></p>
<p>跟踪代码，最终到父类MultithreadEventLoopGroup构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor, Object... args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一点有意思的地方是, 如果我们传入的线程数 nThreads 是0, 那么 Netty 会为我们设置默认的线程数 DEFAULT_EVENT_LOOP_THREADS, 而这个默认的线程数是怎么确定的呢?<br>其实很简单, 在静态代码块中, 会首先确定 DEFAULT_EVENT_LOOP_THREADS 的值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">            <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">availableProcessors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.availableProcessors == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">availableProcessors</span> <span class="operator">=</span></span><br><span class="line">                SystemPropertyUtil.getInt(</span><br><span class="line">                        <span class="string">&quot;io.netty.availableProcessors&quot;</span>,</span><br><span class="line">                        Runtime.getRuntime().availableProcessors());</span><br><span class="line">        setAvailableProcessors(availableProcessors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.availableProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两块代码的意思就是取环境变量<code>io.netty.eventLoopThreads</code>的值，如果没有就取核心数x2</p>
<p>回到MultithreadEventLoopGroup构造器中, 这个构造器会继续调用父类 MultithreadEventExecutorGroup 的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads          the number of threads that will be used by this instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor          the Executor to use, or &#123;<span class="doctag">@code</span> null&#125; if the default should be used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> chooserFactory    the &#123;<span class="doctag">@link</span> EventExecutorChooserFactory&#125; to use.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args              arguments which will passed to each &#123;<span class="doctag">@link</span> #newChild(Executor, Object...)&#125; call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">MultithreadEventExecutorGroup</span><span class="params">(<span class="type">int</span> nThreads, Executor executor,</span></span><br><span class="line"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="literal">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">EventExecutor</span>[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ....</span><br><span class="line">              如果失败，做一些释放资源的逻辑</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> <span class="title class_">FutureListener</span>&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (executor == null) &#123;</span><br><span class="line">    executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的的<code>ThreadPerTaskExecutor</code>很简单，它只有一个方法，就是execute方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是用来创建并启动线程的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newChild(executor, args):</span><br></pre></td></tr></table></figure>

<p>该方法在NioEventLoopGroup中重写了，核心就是new 一个 <code>NioEventLoop</code>对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chooserFactory.newChooser(children);</span><br></pre></td></tr></table></figure>

<p>chooserFactory默认情况下是<code>DefaultEventExecutorChooserFactory</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">DefaultEventExecutorChooserFactory</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EventExecutorChooser <span class="title function_">newChooser</span><span class="params">(EventExecutor[] executors)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PowerOfTwoEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GenericEventExecutorChooser</span>(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意isPowerOfTwo是判断val是否2的幂，至于原理看[java 数字二进制表示](..&#x2F;..&#x2F;..&#x2F;java&#x2F;java 数字二进制表示)</p>
<p>根据代码, 我们就很清楚 MultithreadEventExecutorGroup 中的处理逻辑了:</p>
<ul>
<li><p>创建一个大小为 nThreads 的 EventExecutor 数组</p>
</li>
<li><p>调用 newChhild 方法初始化 children 数组.</p>
</li>
<li><p>根据 nThreads 的大小, 创建不同的 Chooser, 即如果 nThreads 是 2 的幂, 则使用 PowerOfTwoEventExecutorChooser, 反之使用 GenericEventExecutorChooser. 不论使用哪个 Chooser, 它们的功能都是一样的, 即从 children 数组中选出一个合适的 EventExecutor 实例.</p>
<blockquote>
<p>会出现选择EventExecutorChooser，是因为取模的方式不同，对于是2的幂的数，可以使用这样取模</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;idx.getAndIncrement() &amp; executors.length - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这种对位的操作，性能更高</p>
</blockquote>
</li>
</ul>
<p>根据上面的代码, 我们知道, MultithreadEventExecutorGroup 内部维护了一个 EventExecutor 数组，指向的实际类型是EventLoop。Netty 的 EventLoopGroup 的实现机制其实就建立在 MultithreadEventExecutorGroup 之上. 每当 Netty 需要一个 EventLoop 时, 会调用 next() 方法获取一个可用的 EventLoop.</p>
<p>上面代码的中的newChild 方法, 这个是一个抽象方法, 它的任务是实例化 EventLoop 对象. 我们跟踪一下它的代码, 可以发现, 这个方法在 NioEventLoopGroup 类中实现了, 其内容很简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> EventLoop <span class="title function_">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">EventLoopTaskQueueFactory</span> <span class="variable">queueFactory</span> <span class="operator">=</span> args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoop</span>(<span class="built_in">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">             EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent, executor, <span class="literal">false</span>, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),</span><br><span class="line">            rejectedExecutionHandler);</span><br><span class="line">    <span class="built_in">this</span>.provider = ObjectUtil.checkNotNull(selectorProvider, <span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.selectStrategy = ObjectUtil.checkNotNull(strategy, <span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectorTuple</span> <span class="variable">selectorTuple</span> <span class="operator">=</span> openSelector();</span><br><span class="line">    <span class="built_in">this</span>.selector = selectorTuple.selector;</span><br><span class="line">    <span class="built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是实例化一个 NioEventLoop 对象, 然后返回它。看下NioEventLoop的类图</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427473.png" alt="image-20210228023230556"></p>
<p>他继承了SingleThreadEventLoop</p>
<p>最后总结一下整个 NioEventLoopGroup 的初始化过程:</p>
<ul>
<li>NioEventLoopGroup(其实是MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children 数组, 其大小是 nThreads, 这样就构成了一个线程池</li>
<li>如果我们在实例化 NioEventLoopGroup 时, 如果指定线程池大小, 则 nThreads 就是指定的值, 反之是<code>io.netty.availableProcessors</code>参数设置的值或者是处理器核心数 * 2</li>
<li>MultithreadEventExecutorGroup 中会调用 newChild 抽象方法来初始化 children 数组</li>
<li>抽象方法 newChild 是在 NioEventLoopGroup 中实现的, 它返回一个 NioEventLoop 实例.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427474.png"></p>
<h2 id="channel-的注册过程"><a href="#channel-的注册过程" class="headerlink" title="channel 的注册过程"></a>channel 的注册过程</h2><p>在前面的分析中, 我们提到, channel 会在 Bootstrap.initAndRegister 中进行初始化, 但是这个方法还会将初始化好的 Channel 注册到 EventGroup 中. 接下来我们就来分析一下 Channel 注册的过程.</p>
<p>回顾一下 AbstractBootstrap.initAndRegister 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 去掉非关键代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFactory().newChannel();</span><br><span class="line">    init(channel);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Channel 初始化后, 会紧接着调用 group().register() 方法来注册 Channel, 我们继续跟踪的话, 会发现其调用链如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">AbstractBootstrap.initAndRegister -&gt; </span><br><span class="line">MultithreadEventLoopGroup.register:</span><br><span class="line">    public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">       //这里的next方法就是从children数组中获取一个EventExecutor，实际上就是EventLoop</span><br><span class="line">        return next().register(channel);</span><br><span class="line">    &#125;</span><br><span class="line">--&gt;</span><br><span class="line">SingleThreadEventLoop.register：</span><br><span class="line">    public ChannelFuture register(Channel channel) &#123;</span><br><span class="line">        return register(new DefaultChannelPromise(channel, this));</span><br><span class="line">    &#125;</span><br><span class="line">    public ChannelFuture register(final ChannelPromise promise) &#123;</span><br><span class="line">        promise.channel().unsafe().register(this, promise);</span><br><span class="line">        return promise;</span><br><span class="line">    &#125;</span><br><span class="line">--&gt;</span><br><span class="line">AbstractUnsafe.register</span><br><span class="line">AbstractUnsafe是AbstractChannel的内部类</span><br></pre></td></tr></table></figure>

<p>通过跟踪调用链, 最终我们发现是调用到了 unsafe 的 register 方法, 那么接下来我们就仔细看一下 AbstractUnsafe.register 方法中到底做了什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MultithreadEventLoopGroup.register</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SingleThreadEventLoop.register</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="built_in">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractUnsafe.register </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略参数检测和错误处理</span></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">//这里会判断当前线程是不是分配给evetnLoop的线程，如果是就直接执行，如果不是，就放到eventLoop的队列中，异步执行</span></span><br><span class="line">   <span class="comment">//这种模式的代码在源码中经常出现，详情在EventLoop中讲</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先, 将 eventLoop 赋值给 Channel 的 eventLoop 属性, 而我们知道这个 eventLoop 对象其实是 MultithreadEventLoopGroup.next() 方法获取的, 根据我们前面 <strong>关于 EventLoop 初始化</strong> 小节中, 我们可以确定 next() 方法返回的 eventLoop 对象是 NioEventLoop 实例。这里也解析了一个Channel被创建的时候就分配一个EventLoop。</p>
<p>register 方法接着调用了 register0 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register0 又调用了 AbstractNioChannel.doRegister:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 省略不关键的代码</span></span><br><span class="line">    selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>javaChannel() 这个方法返回的是一个 Java NIO SocketChannel对象。所以，这断代码就是java NIO 的api。</p>
<p>这里，我们将这个 SocketChannel 注册到与 eventLoop 关联的 selector 上了。并且把这个最后返回一个SelectionKey对象，并把该对象赋值给了NioSocketChannel中的selectionKey属性。并且这个SelectionKey对象里面的的附加对象引用了NioSocketChannel对象。</p>
<p>这时为NioSocketChannel分配一个EventLoop已经完成了，但整个启动流程还没结束。因为现在这个SocketChannel没有任何关注的事件，所以这个SocketChanel现在还没有实际的作用。而Netty是一个事件驱动的框架。所以在NioSocketChannel注册到一个EventLoop中时，会触发一个<code>Registered</code>事件。这里会在后面再分析。</p>
<p>我们总结一下 Channel 的注册过程:</p>
<ul>
<li>首先在 AbstractBootstrap.initAndRegister中, 通过 group.register(channel), 调用 MultithreadEventLoopGroup.register 方法</li>
<li>在MultithreadEventLoopGroup.register 中, 通过 next() 获取一个 <code>SingleThreadEventLoop</code>, 然后调用它的 register方法。</li>
<li>在 SingleThreadEventLoop.register 中, 通过 channel.unsafe().register(this, promise) 来获取 channel 的 unsafe() 底层操作对象, 然后调用它的 register. </li>
<li>在 AbstractUnsafe.register 方法中, 调用 register0 方法注册 Channel</li>
<li>在 AbstractUnsafe.register0 中, 调用 AbstractNioChannel.doRegister 方法</li>
<li>AbstractNioChannel.doRegister 方法通过 javaChannel().register(eventLoop().selector, 0, this) 将 Channel 对应的 Java NIO SockerChannel 注册到一个 eventLoop 的 Selector 中, 并且将当前 Channel 作为 attachment（SelectionKey的附加对象，可以通过SelectionKey#attachment()方法获取这个附加对象）.</li>
</ul>
<p>总的来说, Channel 注册过程所做的工作就是将 Channel 与对应的 EventLoop 关联, 因此这也体现了, 在 Netty 中, 每个 Channel 都会关联一个特定的 EventLoop, 并且这个 Channel 中的所有 IO 操作都是在这个 EventLoop 中执行的; 当关联好 Channel 和 EventLoop 后, 会继续调用底层的 Java NIO SocketChannel 的 register 方法, 将底层的 Java NIO SocketChannel 注册到指定的 selector 中. 通过这两步, 就完成了 Netty Channel 的注册过程。但是现在EventLoop还不能处理任何网络IO，因为SocketChannel注册到selector中时，指定的关注事件为0。</p>
<h2 id="handler-的添加过程"><a href="#handler-的添加过程" class="headerlink" title="handler 的添加过程"></a>handler 的添加过程</h2><p>Netty 的一个强大和灵活之处就是基于 Pipeline 的自定义 handler 机制. 基于此, 我们可以像添加插件一样自由组合各种各样的 handler 来完成业务逻辑. 例如我们需要处理 HTTP 数据, 那么就可以在 pipeline 前添加一个 Http 的编解码的 Handler, 然后接着添加我们自己的业务逻辑的 handler, 这样网络上的数据流就向通过一个管道一样, 从不同的 handler 中流过并进行编解码, 最终在到达我们自定义的 handler 中.</p>
<p>这里不打算详细展开 Netty 的 ChannelPipeline 的实现机制(具体的细节会在后续的章节中展示), 我在这一小节中, 从简单的入手, 展示一下我们自定义的 handler 是如何以及何时添加到 ChannelPipeline 中的.</p>
<p>首先让我们看一下如下的代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">         <span class="keyword">if</span> (sslCtx != <span class="literal">null</span>) &#123;</span><br><span class="line">             p.addLast(sslCtx.newHandler(ch.alloc(), HOST, PORT));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">         p.addLast(<span class="keyword">new</span> <span class="title class_">EchoClientHandler</span>());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>这个代码片段就是实现了 handler 的添加功能. 我们看到, Bootstrap.handler 方法接收一个 ChannelHandler, 而我们传递的是一个 派生于 ChannelInitializer 的匿名类, 它正好也实现了 ChannelHandler 接口. 我们来看一下, ChannelInitializer 类内到底有什么玄机:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去掉了非重点代码</span></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChannelInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">InternalLogger</span> <span class="variable">logger</span> <span class="operator">=</span> InternalLoggerFactory.getInstance(ChannelInitializer.class);</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ChannelHandlerContext&gt; initMap = Collections.newSetFromMap(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;ChannelHandlerContext, Boolean&gt;());</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            ctx.pipeline().fireChannelRegistered();</span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                initChannel((C) ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">                <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">                exceptionCaught(ctx, cause);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();</span><br><span class="line">                <span class="keyword">if</span> (pipeline.context(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    pipeline.remove(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelInitializer 是一个抽象类, 它有一个抽象的方法 initChannel, 我们正是实现了这个方法, 并在这个方法中添加的自定义的 handler 的。至此，有两个问题——ChannelInitializer对象什么时候进入Pipeline和Pipeline什么时候通过ChannelInitializer初始化Handler</p>
<h3 id="ChannelInitializer对象进入Pipeline"><a href="#ChannelInitializer对象进入Pipeline" class="headerlink" title="ChannelInitializer对象进入Pipeline"></a>ChannelInitializer对象进入Pipeline</h3><p>前面讲了NioSocketChanel创建时会new一个<code>DefaultChannelPipeline</code>对象</p>
<p>那到底是什么时候把ChannelInitializer对象放入这个pipeline对象中的？</p>
<p>还记得我们调用Bootstrap#connect后到了Channel的初始化吗:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 去掉非关键代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFactory().newChannel();</span><br><span class="line">    init(channel);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点就在init(channel);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> &#123;</span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line">    <span class="comment">//将通过Bootstrap#handler方法设置的ChannelHandler添加到pipelient中。</span></span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将通过Bootstrap#option方法设置的值，传递到NioSocketChannel对象中的Config对象中。</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    <span class="comment">//将通过Bootstrap#attr方法设置的值，传递到NioSocketChannel对象中的Config对象中。</span></span><br><span class="line">    setAttributes(channel, newAttributesArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中config.handler()就返回我们在上面创建的ChannelInitializer对象，并把它放入了Pipeline中，执行完后Pipeline变成了这样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427500.png" alt="image-20210228031805006"></p>
<h3 id="Pipeline通过ChannelInitializer初始化Handler"><a href="#Pipeline通过ChannelInitializer初始化Handler" class="headerlink" title="Pipeline通过ChannelInitializer初始化Handler"></a>Pipeline通过ChannelInitializer初始化Handler</h3><p>那ChannelInitializer#initChannel这个方法又是有什么时候执行的呢？</p>
<p>在channel注册流程的最后，也就是AbstractUnsafe.register0方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把Channel中的SocketChannel注册到EventLoop中的Selector中后，会产生一个Registered事件，而Netty的事件都会流经pipeline的。在netty中通过执行了<code>pipeline.fireChannel*</code>把事件交给pipeline中的handler的对应方法处理。而Registered对应的就是<code>fireChannelRegistered</code>。在上边的代码中正好有这代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPipelien</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRegistered(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于上面代码的 head.fireXXX 的调用形式, 是 Netty 中 Pipeline 传递事件的常用方式, 我们以后会经常看到.</p>
</blockquote>
<p>AbstractChannelHandlerContext.invokeChannelRegistered(head)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法的作用就是在next节点执行ChannelHandler的channelRegistered方法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRegistered();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRegistered();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRegistered(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            invokeExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeadContext.handler():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandler <span class="title function_">handler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HeadContext.channelRegistered():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把事件传递给下一个可达的节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    invokeHandlerAddedIfNeeded();</span><br><span class="line">    ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractChannelHandlerContext.fireChannelRegistered：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelRegistered</span><span class="params">()</span> &#123;</span><br><span class="line">    invokeChannelRegistered(findContextInbound(MASK_CHANNEL_REGISTERED));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findContextInbound的作用就是找到当前结点的下一个可达结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到下一个可达节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title function_">findContextInbound</span><span class="params">(<span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    <span class="type">AbstractChannelHandlerContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">currentExecutor</span> <span class="operator">=</span> executor();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ctx = ctx.next;</span><br><span class="line">      <span class="comment">//这个就是使用在初始化HandlerContext时，初始化的executionMask，来判断对应的位上是否位1</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_INBOUND));</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又重复上边的过程。</p>
<p>一开始执行了<code>pipeline.fireChannelRegistered()</code>事件从pipeline的head节点开始，调用了head节点的channelRegistered方法。然后在head节点的channelRegistered方法最后调用了<code>head.fireChannelRegistered</code>方法，把事件传递给了下一个可达节点。在这个启动阶段，这个结点就是我们创建的<code>ChannelInitializer</code>对象，接着ChannelInitializer又调用了自己的channelRegistered</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">      <span class="comment">//完成pipeline的handler组装后，Registered事件重新从pipeline的头节点开始。</span></span><br><span class="line">        ctx.pipeline().fireChannelRegistered();</span><br><span class="line">        removeState(ctx);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctx.fireChannelRegistered();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</span></span><br><span class="line">            <span class="comment">// We do so to prevent multiple calls to initChannel(...).</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，调用了initChannel方法了，根据程序定义，完成了对pipeline的初始化后，接着调用pipeline的remove方法，把ChannelInitializer从当前的pipeline中移除。最后把这个<code>Registered</code>事件从头开始执行一次，直到到达TailContext为止。</p>
<p>因此当调用了这个方法后, 我们自定义的 ChannelHandler 就插入到 Pipeline 了, 此时的 Pipeline 如下图所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427501.png" alt="image-20210228221951594"></p>
<p>当添加了自定义的 ChannelHandler 后, 会删除 ChannelInitializer 这个 ChannelHandler, 即 “ctx.pipeline().remove(this)”, 因此最后的 Pipeline 如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427502.png" alt="image-20210228222006170"></p>
<h2 id="客户端连接分析"><a href="#客户端连接分析" class="headerlink" title="客户端连接分析"></a>客户端连接分析</h2><p>经过上面的各种分析后, 我们大致了解了 Netty 初始化时, 所做的工作。 那么接下来我们就直奔主题, 分析一下客户端是如何发起 TCP 连接的.</p>
<p>首先, 客户端通过调用 <strong>Bootstrap</strong> 的 <strong>connect</strong> 方法进行连接.</p>
<p>在 connect 中, 完成了Channle的创建、Channel的注册和pipelinet的初始化后（这些都是在<code>AbstarctBootstrap#initAndRegister</code>方法中完成的）, 最终调用的是 <strong>doConnect0</strong> 方法, 其实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doConnect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span></span><br><span class="line">    <span class="comment">// the pipeline in its channelRegistered() implementation.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connectPromise.channel();</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (localAddress == <span class="literal">null</span>) &#123;</span><br><span class="line">                channel.connect(remoteAddress, connectPromise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">            &#125;</span><br><span class="line">            connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 doConnect0 中, 会在 eventloop的线程中调用 Channel 的 connect 方法, 而这个 Channel 的具体类型是什么呢? 我们在 Channel 初始化这一小节中已经分析过了, 这里 channel 的类型就是 <strong>NioSocketChannel</strong>.</p>
<p>进行跟踪到 channel.connect 中, 我们发现它调用的是 DefaultChannelPipeline#connect, 而, pipeline 的 connect 代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tail.connect(remoteAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 tail 字段, 我们已经分析过了, 是一个 TailContext 的实例, 而 TailContext 又是AbstractChannelHandlerContext 的子类, 并且没有重写 connect 方法, 因此这里调用的其实是 AbstractChannelHandlerContext.connect, 我们看一下这个方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(SocketAddress remoteAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> connect(remoteAddress, <span class="literal">null</span>, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelFuture <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> findContextOutbound(MASK_CONNECT);</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中有一个关键的地方, 即 <strong>final AbstractChannelHandlerContext next &#x3D; findContextOutbound(MASK_CONNECT)</strong>, 这个方法就是以当前的HandlerContext开始，找到前一个可达的HandlerContext。这里调用 <strong>findContextOutbound</strong> 方法, 从 DefaultChannelPipeline 内的双向链表的 tail 开始, 不断向前寻找第一个可以执行connect方法的AbstractChannelHandlerContext然后调用它的 invokeConnect 方法, 其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).connect(<span class="built_in">this</span>, remoteAddress, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connect(remoteAddress, localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后找到了输出链表的尾端也就是head(HeadContext)而又因为 HeadContext 重写了 connect 方法, 因此实际上调用的是 HeadContext.connect. 我们接着跟踪到 HeadContext.connect, 其代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        ChannelHandlerContext ctx,</span></span><br><span class="line"><span class="params">        SocketAddress remoteAddress, SocketAddress localAddress,</span></span><br><span class="line"><span class="params">        ChannelPromise promise)</span> &#123;</span><br><span class="line">    unsafe.connect(remoteAddress, localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 connect 方法很简单, 仅仅调用了 unsafe 的 connect 方法. 而 unsafe 又是什么呢?<br>回顾一下 HeadContext 的构造器, 我们发现 unsafe 是 pipeline.channel().unsafe() 返回的, 而 Channel 的 unsafe 的值, 在这个例子中, 我们已经知道了, 其实是 AbstractNioByteChannel.NioByteUnsafe 内部类. 兜兜转转了一大圈, 我们找到了创建 Socket 连接的关键代码.</p>
<blockquote>
<p>NioSocketChannel的unsafe的类型实际上是NioSocketChannelUnsafe，下面列出类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427478.png" alt="image-20211027022736291"></p>
</blockquote>
<p>进行跟踪 NioByteUnsafe -&gt; AbstractNioUnsafe.connect:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">   <span class="comment">//去掉了非关键代码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">    <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">        fulfillConnectPromise(promise, wasActive);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractNioUnsafe.connect 的实现如上代码所示, 在这个 connect 方法中, 调用了 doConnect 方法, <code>注意, 这个方法并不是 AbstractNioUnsafe 的方法, 而是 AbstractNioChannel 的抽象方法.</code> （AbstractNioUnsafe是AbstractNioChannel的抽象内部类）doConnect 方法是在 NioSocketChannel 中实现的, 因此进入到<strong>NioSocketChannel.doConnect</strong> 中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">          <span class="comment">//如果连接没有马上成功，则注册一个OP_CONNECT事件</span></span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SocketUtils.connect:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">connect</span><span class="params">(<span class="keyword">final</span> SocketChannel socketChannel, <span class="keyword">final</span> SocketAddress remoteAddress)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">              <span class="comment">//重点代码</span></span><br><span class="line">                <span class="keyword">return</span> socketChannel.connect(remoteAddress);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException) e.getCause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们终于看到的最关键的部分了, 庆祝一下! 上边的代码就是一个标准的java nio 客户端的启动流程。</p>
<p>最后, 上面的代码流程可以用如下时序图直观地展示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427488.png" alt="image-20210228050925414"></p>
<p>NioEventLoop就是负责处理NioSocketChannel关注的读写事件的通知线程实现类，但上边只是讲了SocketChannel连接。并没有把最重要的OP_READ注册到Selector中。</p>
<h3 id="客户端连接Socket关注OP-READ事件"><a href="#客户端连接Socket关注OP-READ事件" class="headerlink" title="客户端连接Socket关注OP_READ事件"></a>客户端连接Socket关注OP_READ事件</h3><p>上边只是SocketChannel执行了connect方法，但还没完，因为只是执行了socketChannel.connect而已，现在只是问题是还没告诉selector，这个socketChannel关注什么事件。在java NIO中，客户端的连接是要这样处理的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (sc.connect(socketAddress)) &#123;</span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端链接完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在netty也不例外。从上边的doConnect有这样的一段代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427480.png" alt="image-20211031234635716"></p>
<p>在socketChannel.connect执行了不代表TCP链接的三次握手已经成功了，这时有两种情况：</p>
<ol>
<li><p>还没成功时会在关注一个SelectionKey.OP_CONNECT事件，这和java NIO编程时处理方法一样，而一个Channel的所有事件都是在EventLoop中处理的，这种时候就要在NioEventLoop线程中怎么处理链接建立成功的通知的，跟踪NioEventLoop中的run方法，得到调用链如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop.run -&gt; </span><br><span class="line">NioEventLoop.processSelectedKeys() -&gt; </span><br><span class="line">NioEventLoop.processSelectedKeysPlain(Set&lt;SelectionKey&gt; selectedKeys) -&gt; </span><br><span class="line">NioEventLoop.processSelectedKey(SelectionKey k, AbstractNioChannel ch) </span><br></pre></td></tr></table></figure>

<p>看下NioEventLoop.processSelectedKey(SelectionKey k, AbstractNioChannel ch) :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">  <span class="comment">//去掉了非关键代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取这个SocketChannel关注的事件，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到SelectionKey.readyOps();返回了已经就绪的事件。由于开始时这个SocketChannel只关注OP_CONNECT，而如果OP_CONNECT事件已经就绪了，那第一个if的readyOps&amp; SelectionKey.OP_CONNECT肯定不为0的，这时先取消关注OP_CONNECT事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ops = k.interestOps();</span><br><span class="line">ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">k.interestOps(ops);</span><br></pre></td></tr></table></figure>

<p>然后调用了<code>unsafe.finishConnect()</code>，上面已经说明过了，在客户端中unsafe是NioByteUnsafe实例，看下NioByteUnsafe.finishConnect方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finishConnect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">        doFinishConnect();</span><br><span class="line">        fulfillConnectPromise(connectPromise, wasActive);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectTimeoutFuture != <span class="literal">null</span>) &#123;</span><br><span class="line">            connectTimeoutFuture.cancel(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        connectPromise = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查3次握手是否成功</span></span><br><span class="line"><span class="comment">//这里的SocketChannel#isConnected需要注意，这个方法只有在手动调用SocketChannel.finishConnect方法时，才会返回true</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">ch</span> <span class="operator">=</span> javaChannel();</span><br><span class="line">    <span class="keyword">return</span> ch.isOpen() &amp;&amp; ch.isConnected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于一开始时还没把SocketChannel里面的状态state改为ST_CONNECTED，所以wasActive&#x3D;false，执行完doFinishConnect，通过调用SocketChannel.finishConnect方法，把SocketChannel.state改为了ST_CONNECTED了，接着看fulfillConnectPromise源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="type">boolean</span> wasActive)</span> &#123;</span><br><span class="line">    <span class="comment">// 去掉了非关键代码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">active</span> <span class="operator">=</span> isActive();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当再次调用isActive()放回了true，所以条件满足，进入了if语句块，执行了&#96;pipeline().fireChannelActive();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">fireChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> &#123;</span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            invokeExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说实际是调用了HeadContext的channelActive方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HeadContext.channelActive中，先看下ctx.fireChannelActive():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">fireChannelActive</span><span class="params">()</span> &#123;</span><br><span class="line">    invokeChannelActive(findContextInbound(MASK_CHANNEL_ACTIVE));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面在Channel的注册也说过了类似的，这个方法就是找到下一个可以执行channelActive的Inbound，执行完channelActive后，然后重复上面的过程，一直把channelActive事件沿着Inbound链传输，直到最后一个结点，也就是TailContext结点。</p>
<p>HeadContext把事件传递下去后接着执行了readIfIsAutoRead();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、HeadContext#readIfIsAutoRead</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readIfIsAutoRead</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">    channel.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、AbstractChannel#read</span><br><span class="line"><span class="keyword">public</span> Channel <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">  pipeline.read();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>、DefaultChannelPipeline#read</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">  tail.read();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>、TailContext#read</span><br><span class="line"><span class="keyword">public</span> ChannelHandlerContext <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> findContextOutbound(MASK_READ);</span><br><span class="line">  <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">  <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">    next.invokeRead();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">Tasks</span> <span class="variable">tasks</span> <span class="operator">=</span> next.invokeTasks;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="literal">null</span>) &#123;</span><br><span class="line">      next.invokeTasks = tasks = <span class="keyword">new</span> <span class="title class_">Tasks</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.execute(tasks.invokeReadTask);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>、AbstractChannelHandlerContext#invokeRead</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeRead</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ((ChannelOutboundHandler) handler()).read(<span class="built_in">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      invokeExceptionCaught(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这已经明白了吧，从TailContextk开始找前一个可以执行read方法的Outbound，然后调用该Outbound的read方法，直到链表头，也就是HeadContext为止。好了，看下HeadContext.read方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中unsafe是NioByteUnsafe，实际上NioByteUnsafe没有重写这个方法，最终看AbstractUnsafe.beginRead:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">beginRead</span><span class="params">()</span> &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                pipeline.fireExceptionCaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doBeginRead是Channel的方法，该方法需要重写，我们使用了Nio所以最终方法锁定在了AbstractNioChannel.doBeginRead：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line"><span class="comment">//readInterestOp的值是在NioSocketChannel初始化时指定的，值就是OP_READ</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，看到熟悉的方法了，这个方法就是告诉selector，SocketChannel要关注OP_READ事件。</p>
</li>
<li><p>当socket.connect直接链接成功后，就执行了fulfillConnectPromise方法，这个方法刚才已经说过了</p>
</li>
</ol>
<p>在看ChannelPipeline read()方法时后点困惑，就是为什么read是流经outbound链的呢?</p>
<p>比如有一个有个链接事件，一开始由selector通知，然后在NioEventLoop线程中处理，接着channelActive就在从HeadContext开始，流经Inbound，此时数据流向是这样的：<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427481.png" alt="image-20210228213216974"></p>
<p>当写就绪的情况也是一样：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427482.png" alt="image-20210228213632936"></p>
<p>channel.read方法数据流线是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427483.png" alt="image-20210228214618699"></p>
<p>channel.write方法数据流是这样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427484.png" alt="image-20210228215341258"></p>
<blockquote>
<p>最后写就绪，少了一步，也是最后一部，就是写完后会取消订阅write事件，因为在NIO中，只要socket buffer没有写满就会一直触发可写事件，所以如果直接注册*OP_*WRITE而不取消会导致CPU跑满。</p>
</blockquote>
<p>从这些事件处理的流程可以了解一个事实，当系统通知应用程序时，数据是经过Inbound；而当应用程序告诉系统（订阅事件）时，是经过Outbound。</p>
<p>而且也发现了，netty的设计是完全遵循：事件都是在pipeline中传播的，输入事件从head开始，输出事件从tail开始。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>都是基于NioSocketChannel。</p>
<p>在调用了connct方法后开始初始化流程</p>
<ol>
<li><p>一开始会通过ReflectiveChannelFactory#newChannel创建一个Channel对象，这个对象也就是NioSocketChannel对象。初始化这个NioSocketChannel对象时会创建一个SocketChanel和DefaultChannelPipeline对象，并把他们赋值给了NioSocketChannel里的对应属性。</p>
</li>
<li><p>接着会把调用connct前调用的handle传递的ChannelInitializer对象传入到NioSocketChannel中的pipeline中，形成了<img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427500.png" alt="image-20210228031805006"></p>
<p>的结构。</p>
</li>
<li><p>接着就是把EventLoopGroup中的EventLoop分配给Channel的阶段了，在这阶段会在EventLoopGroup中的一个EventLoop数组children中按照规则取到一个EventLoop，这个EventLoop也就是NioEventLoop(继承了SingleThreadEventLoop)，然后调用了NioEventLoop.register，通过AbstractUnsafe.register把Channel和EventLoop绑定，并且把Channel中的SocketChannel注册到了EventLoop的Selector中，最用NioSocketChannel中selectionKey引用指向了返回的selectionKey对象<br>不过这里要注意一点就是注册的代码是这样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javaChannel().register(eventLoop().unwrappedSelector(), 0, NioSocketChannel（对象）)</span><br></pre></td></tr></table></figure>

<p>在这里并不关注任何事件，而且会把NioSocketChannel作为附加对象传递给SelectionKeys。</p>
</li>
<li><p>在注册完后就会执行<code>pipeline.fireChannelRegistered()</code>也就是会触发Channel已经注册完成的事件（说是事件，其实就是一个同步的方法调用）而且这个事件会在pipelin的输入流的头部流入到尾部结束。<br>还记得的我们添加的ChannelInitializer对象吗？在这时就会触发ChannelInitializer的channelRegistered()方法，开始把我们需要的handler包装成ChannelHandlerContext，并把这个ChannelHandlerContext放入到pipeline中（ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联 ）<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427486.png" alt="image-20210228031830905"><br>最终pipeline形成了这样的结构</p>
</li>
<li><p>注册完成了就执行channel.connect方法了，这个操作是交由NioSocketChannel绑定的NioEventloop来完成的，因为：<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427487.png" alt="image-20210228053348988"></p>
<p>NioEventloop线程执行了connect后的时序图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/spring/9079500731129427488.png" alt="image-20210228050925414"><br>channel.connect操作完成后，当NioEventloop线程收到了链接完成通知，最终执行了pipeline().fireChannelActive()，使channelActive事件从pipeline的head开始沿着Inbound链表传播。而且在HeadContext中，还执行了channel.read，使得一个read事件从pipeline的tail开始传播，沿着Outbound链表传播，最终到达head的read方法，执行了订阅OP_READ操作。这个过程可以看到，netty的事件总是在pipeline中传播的。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://sv.pointcut.cc/blog/netty/netty%E6%BA%90%E7%A0%81/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%80%20Bootstrap(%E5%AE%A2%E6%88%B7%E7%AB%AF)/">http://sv.pointcut.cc/blog/netty/netty源码/Netty 源码分析之 一 Bootstrap(客户端)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sv.pointcut.cc" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/netty/">netty</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/netty/netty%E6%BA%90%E7%A0%81/Netty%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%20%E4%B8%80%20Bootstrap(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF)/">Netty 源码分析之 一 Bootstrap(服务器端)</a><a class="next" href="/blog/netty/06netty%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/udp/">udp</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">301</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NioSocketChannel-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">NioSocketChannel 的初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelFactory-%E5%92%8C-Channel-%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.1.</span> <span class="toc-text">ChannelFactory 和 Channel 类型的确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">Channel 实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-unsafe-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">关于 unsafe 字段的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-pipeline-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">关于 pipeline 的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E7%9D%80%E7%9C%8B%E4%B8%80%E4%B8%8B-HeadContext-%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">接着看一下 HeadContext 的构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pipeline%E7%9A%84executionMask%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.2.</span> <span class="toc-text">pipeline的executionMask属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E7%9D%80%E7%9C%8B%E4%B8%80%E4%B8%8B-TailContext-%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">接着看一下 TailContext 的构造器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-EventLoopGroup-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">关于 EventLoopGroup 初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel-%E7%9A%84%E6%B3%A8%E5%86%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">channel 的注册过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#handler-%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">handler 的添加过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelInitializer%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5Pipeline"><span class="toc-number">4.1.</span> <span class="toc-text">ChannelInitializer对象进入Pipeline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline%E9%80%9A%E8%BF%87ChannelInitializer%E5%88%9D%E5%A7%8B%E5%8C%96Handler"><span class="toc-number">4.2.</span> <span class="toc-text">Pipeline通过ChannelInitializer初始化Handler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">客户端连接分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Socket%E5%85%B3%E6%B3%A8OP-READ%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">客户端连接Socket关注OP_READ事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/05-Nacos%E4%B8%AD%E7%9A%84AbstractNacosTaskExecuteEngine/" title="05-Nacos中的AbstractNacosTaskExecuteEngine">05-Nacos中的AbstractNacosTaskExecuteEngine</a><time datetime="2021-11-27T12:00:40.000Z" title="发表于 2021-11-27 20:00:40">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/04-Server%E5%92%8CClient%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96nacos%E5%9C%B0%E5%9D%80/" title="04-Server和Client动态获取nacos地址">04-Server和Client动态获取nacos地址</a><time datetime="2021-11-27T12:00:39.000Z" title="发表于 2021-11-27 20:00:39">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/03-Nacos%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" title="03-Nacos的发布与订阅">03-Nacos的发布与订阅</a><time datetime="2021-11-27T12:00:38.000Z" title="发表于 2021-11-27 20:00:38">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/02-Nacos%20Server%E4%B8%AD%E7%9A%84Secured%E6%B3%A8%E8%A7%A3/" title="02-Nacos Server中的Secured注解">02-Nacos Server中的Secured注解</a><time datetime="2021-11-27T12:00:37.000Z" title="发表于 2021-11-27 20:00:37">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/01-Nacos%20Server%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" title="01-Nacos Server服务注册表的写时复制">01-Nacos Server服务注册表的写时复制</a><time datetime="2021-11-27T12:00:36.000Z" title="发表于 2021-11-27 20:00:36">2021-11-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>