<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>01-Spring中BeanDefinition的创建和注册 | XYZhi's学习笔记</title><meta name="keywords" content="spring"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="以ClassPathXmlApplicationContext为ApplicationContext 1234方法重要程度： 0：不重要，可以不看 1：一般重要，可看可不看 5：非常重要，一定要看 必须读的 ：重要程度 5  12345678910public ClassPathXmlApplicationContext(		String[] configLocations, boolean re">
<meta property="og:type" content="article">
<meta property="og:title" content="01-Spring中BeanDefinition的创建和注册">
<meta property="og:url" content="https://nbobj.github.io/blog/spring/01-Spring%E4%B8%ADBeanDefinition%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="以ClassPathXmlApplicationContext为ApplicationContext 1234方法重要程度： 0：不重要，可以不看 1：一般重要，可看可不看 5：非常重要，一定要看 必须读的 ：重要程度 5  12345678910public ClassPathXmlApplicationContext(		String[] configLocations, boolean re">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg">
<meta property="article:published_time" content="2021-11-25T12:00:07.000Z">
<meta property="article:modified_time" content="2022-03-23T09:03:54.081Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nbobj.github.io/blog/spring/01-Spring%E4%B8%ADBeanDefinition%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '01-Spring中BeanDefinition的创建和注册',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 17:03:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">321</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">01-Spring中BeanDefinition的创建和注册</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T12:00:07.000Z" title="发表于 2021-11-25 20:00:07">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T09:03:54.081Z" title="更新于 2022-03-23 17:03:54">2022-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="01-Spring中BeanDefinition的创建和注册"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>以ClassPathXmlApplicationContext为ApplicationContext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法重要程度：</span><br><span class="line"> 0：不重要，可以不看</span><br><span class="line"> 1：一般重要，可看可不看</span><br><span class="line"> 5：非常重要，一定要看 必须读的 ：重要程度 5</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(</span></span><br><span class="line"><span class="params">		String[] configLocations, <span class="type">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">super</span>(parent);</span><br><span class="line">	setConfigLocations(configLocations);</span><br><span class="line">	<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">		refresh();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refresh()方法是重要方法，ClassPathXmlApplicationContext没有重写该方法所以用的是从父类<code>AbstractApplicationContext</code>继承过来的<code>refresh()</code>，</p>
<p>该方法是spring容器启动的核心方法，该类是一个典型的父类模板设计模式的运用，提供一个钩子方法，通过继承，子类实现对应的钩子方法来完成不同的功能。</p>
<p>根据不同的上下文对象，会调用不同的上下文对象子类方法中</p>
<p>核心上下文子类有：</p>
<ul>
<li>ClassPathXmlApplicationContext</li>
<li>FileSystemXmlApplicationContext</li>
<li>AnnotationConfigApplicationContext</li>
<li>AnnotationConfigWebApplicationContext</li>
<li>EmbeddedWebApplicationContext(springboot)</li>
<li>….</li>
</ul>
<p>这里关注的重点只有两个ClassPathXmlApplicationContext和AnnotationConfigApplicationContext。先看第一<code>ClassPathXmlApplicationContext</code>。ClassPathXmlApplicationContext的类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511958.png" alt="image-20210311213656659"></p>
<p>看回refresh()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">//为容器初始化做准备，重要程度：0</span></span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		*  重要程度：5</span></span><br><span class="line"><span class="comment">		* */</span></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 给beanFactory设置一些属性值，可以不看</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 完成对这两个接口的调用</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 国际化,重要程度2</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//初始化事件管理类</span></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的</span></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 往事件管理类中注册事件类</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 这个方法是spring中最重要的方法，没有之一</span></span><br><span class="line"><span class="comment">			 * 所以这个方法一定要理解要具体看</span></span><br><span class="line"><span class="comment">			 * 1、bean实例化过程</span></span><br><span class="line"><span class="comment">			 * 2、ioc</span></span><br><span class="line"><span class="comment">			 * 3、注解支持</span></span><br><span class="line"><span class="comment">			 * 4、BeanPostProcessor的执行</span></span><br><span class="line"><span class="comment">			 * 5、Aop的入口</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先refresh()方法是AbstractApplicationContext的核心，从上面源码看到，该方法里面定义的Spring整个初始化阶段的操作。而且提供一些钩子方法，让不同的类去重写钩子方法，实现不同的功能。该方法是线程安全的，不过该方法也就掉用哥一次，没谁调用多次 吧。</p>
<p>这一节看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure>

<p>对于<code>ClassPathXmlApplicationContext</code>这个方法的作用：</p>
<ol>
<li><p>创建BeanFactory对象</p>
</li>
<li><p>xml解析</p>
<p>传统标签解析：bean、import等<br>自定义标签解析 如：&lt;context:component-scan base-package&#x3D;”com.xiangxue.jack”&#x2F;&gt;<br>自定义标签解析流程：<br>    a、根据当前解析标签的头信息找到对应的namespaceUri<br>    b、加载spring所有jar中的spring.handlers文件。并建立映射关系<br>    c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类<br>    d、调用类的init方法，init方法是注册了各种自定义标签的解析类<br>    e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析</p>
</li>
<li><p>把解析出来的xml标签封装成BeanDefinition对象</p>
</li>
</ol>
<p>开始看源码，该方法是在AbstractApplicationContext中的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//核心方法，必须读，重要程度：5</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	<span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refreshBeanFactory()方法是一个抽象的钩子方法，它的实现是交由子类来完成的，</p>
<p><code>AbstractRefreshableApplicationContext#refreshBeanFactory</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">//如果BeanFactory不为空，则清除BeanFactory和里面的实例</span></span><br><span class="line">	<span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//BeanFactory 实例工厂</span></span><br><span class="line">		<span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		<span class="comment">//设置是否可以循环依赖 allowCircularReferences</span></span><br><span class="line">		<span class="comment">//是否允许使用相同名称重新注册不同的bean实现.</span></span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		<span class="comment">//解析xml，并把xml中的标签封装成BeanDefinition对象</span></span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		<span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title function_">createBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultListableBeanFactory beanFactory = createBeanFactory();</code>返回的是<code>DefaultListableBeanFactory</code></p>
<p>customizeBeanFactory(beanFactory);这里面主要设置两个参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//设置允许Bean定义覆盖</span></span><br><span class="line">		beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//设置是否可以循环依赖</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">		beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看<code>loadBeanDefinitions(beanFactory)</code>，该方法又是钩子方法，它由<code>AbstractXmlApplicationContext</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	<span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">	<span class="comment">//创建xml的解析器，这里是一个委托模式</span></span><br><span class="line">	<span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">	<span class="comment">// resource loading environment.</span></span><br><span class="line">	beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">	<span class="comment">//这里传一个this进去，因为ApplicationContext是实现了ResourceLoader接口的</span></span><br><span class="line">	beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">	<span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	<span class="comment">//主要看这个方法  重要程度 5</span></span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XmlBeanDefinitionReader是xml的解析器，DefaultListableBeanFactory不完成XML解析的工作，该工作委托给了<code>XmlBeanDefinitionReader</code>来完成，看下类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511959.png" alt="image-20210311220757207"></p>
<h2 id="XmlBeanDefinitionReader"><a href="#XmlBeanDefinitionReader" class="headerlink" title="XmlBeanDefinitionReader"></a>XmlBeanDefinitionReader</h2><p>上面的代码的重点方法是<code>AbstractXmlApplicationContext.loadBeanDefinitions(beanDefinitionReader)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">	Resource[] configResources = getConfigResources();</span><br><span class="line">	<span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取需要加载的xml配置文件</span></span><br><span class="line">	String[] configLocations = getConfigLocations();</span><br><span class="line">	<span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">		reader.loadBeanDefinitions(configLocations);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configLocations就是一个资源数组，里面保存的就是指定解析的xml配置文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511960.png" alt="image-20210311220609281"></p>
<p>经过调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader.loadBeanDefinitions(configLocations) ---&gt;</span><br><span class="line">AbstractBeanDefinitionReader.loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources)</span><br></pre></td></tr></table></figure>

<p>AbstractBeanDefinitionReader.loadBeanDefinitions：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(String location, <span class="meta">@Nullable</span> Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="type">ResourceLoader</span> <span class="variable">resourceLoader</span> <span class="operator">=</span> getResourceLoader();</span><br><span class="line">	<span class="keyword">if</span> (resourceLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">    	......<span class="comment">//不重要代码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">		<span class="comment">// Resource pattern matching available.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//把字符串类型的xml文件路径，形如：classpath*:user/**/*-context.xml,转换成Resource对象类型，其实就是用流</span></span><br><span class="line">			<span class="comment">//的方式加载配置文件，然后封装成Resource对象，不重要，可以不看</span></span><br><span class="line">			Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			<span class="comment">//主要看这个方法 ** 重要程度 5</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> loadBeanDefinitions(resources);</span><br><span class="line">			<span class="keyword">if</span> (actualResources != <span class="literal">null</span>) &#123;</span><br><span class="line">				Collections.addAll(actualResources, resources);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//不重要代码</span></span><br><span class="line">			......</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="comment">//不重要代码</span></span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不重要代码</span></span><br><span class="line">    ......</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数location我们已经知道了，是一个字符串，而且是xml文件名字活匹配串，该方法中调用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br></pre></td></tr></table></figure>

<p>该方法的实际作用就是通过流的方法去获取到xml文件，并且封装成一个Resource对象。而之所以是数组，是应为</p>
<p>可能会是这样的匹配串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath*:user/**/*-context.xml</span><br></pre></td></tr></table></figure>

<p>好了，到重点方法int count &#x3D; loadBeanDefinitions(resources);了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">		<span class="comment">//模板设计模式，调用到子类中的方法</span></span><br><span class="line">		count += loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions又是钩子方法，它的实现由子类XmlBeanDefinitionReader完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="comment">//EncodedResource带编码的对Resource对象的封装</span></span><br><span class="line">	<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions(EncodedResource encodedResource):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">				<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取Resource对象中的xml文件流对象</span></span><br><span class="line">	<span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream()) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//InputSource是jdk中的sax xml文件解析对象</span></span><br><span class="line">		<span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">		<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">			inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//主要看这个方法 **  重要程度 5</span></span><br><span class="line">		<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是开始加载xml文件，为xml文件生成一个InputStream。</p>
<p>重点是<code>doLoadBeanDefinitions(inputSource, encodedResource.getResource());</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//把inputSource 封装成Document文件对象，这是jdk的API</span></span><br><span class="line">		<span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">		<span class="comment">//主要看这个方法，根据解析出来的document对象，拿到里面的标签元素封装成BeanDefinition</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">		<span class="comment">//....log</span></span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">  ..........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	<span class="comment">//又来一记委托模式，BeanDefinitionDocumentReader委托这个类进行document的解析</span></span><br><span class="line">	<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">	<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//主要看这个方法，createReaderContext(resource) XmlReaderContext上下文，封装了XmlBeanDefinitionReader对象</span></span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面兜兜转转，XmlBeanDefinitionReader其实就一个目的，读取xml的内容，并封装成一个Document对象，在 doLoadDocument(inputSource, resource)里完成这一过程。那有了xml文件的信息了，接下来就是去解析xml信息并封装成对象了，从单一职责原则看，XmlBeanDefinitionReader的职责已经完成了，所以它创建了<code>BeanDefinitionDocumentReader</code>类，将解析工作交给它。</p>
<h2 id="BeanDefinitionDocumentReader"><a href="#BeanDefinitionDocumentReader" class="headerlink" title="BeanDefinitionDocumentReader"></a>BeanDefinitionDocumentReader</h2><p>该接口的实现类为<code>DefaultBeanDefinitionDocumentReader</code>，<code>registerBeanDefinitions</code>就是该类的核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">	<span class="comment">//主要看这个方法，把root节点传进去</span></span><br><span class="line">	doRegisterBeanDefinitions(doc.getDocumentElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doc.getDocumentElement()，用来获取XMl的root节点，也就是spring配置文件的beans元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">	<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line">	<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">   ........</span><br><span class="line">	preProcessXml(root);</span><br><span class="line">	<span class="comment">//主要看这个方法，标签具体解析过程</span></span><br><span class="line">	parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line">	postProcessXml(root);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里又是一个委托，看<code>createDelegate</code>，这个方法返回了<code>BeanDefinitionParserDelegate</code>，从名字上看该类是真正将xml的信息封装成BeanDefinition的。往下看，</p>
<p>有两个空方法<code>preProcessXml</code>和<code>postProcessXml</code>，这两个在默认的实现类中什么都不做，这是为了扩展才提供了，看重点方法<code>parseBeanDefinitions(root, this.delegate);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					<span class="comment">//默认标签解析</span></span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//自定义标签解析</span></span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法就是遍历beans里面的元素。而这里又分为默认标签解析和自定义标签解析</p>
<h3 id="默认标签解析"><a href="#默认标签解析" class="headerlink" title="默认标签解析"></a>默认标签解析</h3><p>传统标签解析：bean、beans、import和alias</p>
<p>parseDefaultElement(ele, delegate)，解析默认标签解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="comment">//import标签解析  重要程度 1 ，可看可不看</span></span><br><span class="line">	<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//alias标签解析 别名标签  重要程度 1 ，可看可不看</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//bean标签，重要程度  5，必须看</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 这里是解析beans，其实可以看作是遍历bean而已</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		<span class="comment">// recurse</span></span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们值看bean标签的解析，<code>processBeanDefinition</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="comment">//重点看这个方法，重要程度 5 ，解析document，封装成BeanDefinition</span></span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">bdHolder</span> <span class="operator">=</span> delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//该方法功能不重要，设计模式重点看一下，装饰者设计模式，加上SPI设计思想</span></span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//完成document到BeanDefinition对象转换后，对BeanDefinition对象进行缓存注册</span></span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">     	.........</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> <span class="title class_">BeanComponentDefinition</span>(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经有xml的bean标签的对应的对象了，如果是我做的会解析该xml的bean标签的信息并把这些信息封装到一个对象中，而spring也是这样做的，spring会把信息封装成<code>BeanDefinition</code></p>
<p>重点看BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);，这个方法就是去解析document，封装成<code>BeanDefinition</code>的，跟踪代码到BeanDefinitionParserDelegate.parseBeanDefinitionElement：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">	<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">	List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">		String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">		aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">		........</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查beanName是否重复</span></span><br><span class="line">	<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">		checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//&lt;bean&gt;标签解析的核心方法，重要程度5</span></span><br><span class="line">	<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">	<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">					beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">							beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">					<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">					<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">							beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">							!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">						aliases.add(beanClassName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				error(ex.getMessage(), ele);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取id和name（也就是bean的别名），别名逗号切割，放入List&lt;String&gt; aliases中</p>
<p>而id会赋值给beanName引用，这也是bean的名字，而name会作为bean的别名，一直到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br></pre></td></tr></table></figure>

<p>该方法是&lt;bean&gt;标签解析的核心方法，会创建一个BeanDefinition对象，这个BeanDefinition的类型为<code>GenericBeanDefinition</code></p>
<p>parseBeanDefinitionElement：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> AbstractBeanDefinition <span class="title function_">parseBeanDefinitionElement</span><span class="params">(</span></span><br><span class="line"><span class="params">			Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.parseState.push(<span class="keyword">new</span> <span class="title class_">BeanEntry</span>(beanName));</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">			parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建GenericBeanDefinition对象</span></span><br><span class="line">			<span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//解析bean标签的属性，并把解析出来的属性设置到BeanDefinition对象中</span></span><br><span class="line">			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">			<span class="comment">//解析bean中的meta标签</span></span><br><span class="line">			parseMetaElements(ele, bd);</span><br><span class="line">			<span class="comment">//解析bean中的lookup-method标签  重要程度：2，可看可不看</span></span><br><span class="line">			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">			<span class="comment">//解析bean中的replaced-method标签  重要程度：2，可看可不看</span></span><br><span class="line">			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">			<span class="comment">//解析bean中的constructor-arg标签  重要程度：2，可看可不看</span></span><br><span class="line">			parseConstructorArgElements(ele, bd);</span><br><span class="line">			<span class="comment">//解析bean中的property标签  重要程度：2，可看可不看</span></span><br><span class="line">			parsePropertyElements(ele, bd);</span><br><span class="line">			<span class="comment">//可以不看，用不到</span></span><br><span class="line">			parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">			bd.setResource(<span class="built_in">this</span>.readerContext.getResource());</span><br><span class="line">			bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> bd;</span><br><span class="line">		&#125;</span><br><span class="line">    ......</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.parseState.pop();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//createBeanDefinition(className, parent)</span></span><br><span class="line">	<span class="keyword">protected</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(<span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> String parentName)</span></span><br><span class="line">			<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">				parentName, className, <span class="built_in">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanDefinitionReaderUtils.createBeanDefinition(</span></span><br><span class="line"><span class="comment">//				parentName, className, this.readerContext.getBeanClassLoader());</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title function_">createBeanDefinition</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> String parentName, <span class="meta">@Nullable</span> String className, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">GenericBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericBeanDefinition</span>();</span><br><span class="line">		bd.setParentName(parentName);</span><br><span class="line">		<span class="keyword">if</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">				bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				bd.setBeanClassName(className);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bd;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>好了，终于看到<code>GenericBeanDefinition bd = new GenericBeanDefinition()</code>了</p>
<p>下图是<code>GenericBeanDefinition</code>的重要属性属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511961.png" alt="image-20210311225701841"></p>
<p>好了，现在已经获取到了BeanDefinition，并把BeanDefinition在封装成了BeanDefinitionHolder了，那最后就是注册了吧，这步放到自定义标签（包扫描）上讲。</p>
<h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><p>自定义标签解析 如：&lt;context:component-scan base-package&#x3D;”com.xiangxue.jack”&#x2F;&gt;<br>自定义标签解析流程：<br>        a、根据当前解析标签的头信息找到对应的namespaceUri<br>        b、加载spring所有jar中的spring.handlers文件。并建立映射关系<br>        c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类<br>        d、调用NamespaceHandler类的init方法，init方法是注册了各种自定义标签的解析类<br>        e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析</p>
<p>回到DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">			<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">				<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">				<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					<span class="comment">//默认标签解析</span></span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//自定义标签解析</span></span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看delegate.parseCustomElement(ele)，该方法就是去解析自定义标签的。</p>
<p>可以看到自定义标签的解析是交给了BeanDefinitionParserDelegate完成，看</p>
<p>BeanDefinitionParserDelegate#parseCustomElement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> parseCustomElement(ele, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">namespaceUri</span> <span class="operator">=</span> getNamespaceURI(ele);</span><br><span class="line">	<span class="keyword">if</span> (namespaceUri == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">    .......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> <span class="title class_">ParserContext</span>(<span class="built_in">this</span>.readerContext, <span class="built_in">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个namespaceUri，这个就是这些值</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511962.png" alt="image-20210312003549186"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511963.png" alt="image-20210503224046557"></p>
<p>看下方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NamespaceHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br></pre></td></tr></table></figure>

<p><code>NamespaceHandlerResolver</code>的默认实现是<code>DefaultNamespaceHandlerResolver</code></p>
<p>DefaultNamespaceHandlerResolver#resolve：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> NamespaceHandler <span class="title function_">resolve</span><span class="params">(String namespaceUri)</span> &#123;</span><br><span class="line">	<span class="comment">//获取spring中所有jar包里面的 &quot;META-INF/spring.handlers&quot;文件，并且建立映射关系</span></span><br><span class="line">	Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">	<span class="comment">//根据namespaceUri：http://www.springframework.org/schema/context，获取到这个命名空间的处理类</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">handlerOrClassName</span> <span class="operator">=</span> handlerMappings.get(namespaceUri);</span><br><span class="line">   ........</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String) handlerOrClassName;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="built_in">this</span>.classLoader);</span><br><span class="line">			<span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">				......</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">NamespaceHandler</span> <span class="variable">namespaceHandler</span> <span class="operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//调用处理类的init方法，在init方法中完成标签元素解析类的注册</span></span><br><span class="line">			namespaceHandler.init();</span><br><span class="line">       <span class="comment">//这里还做了缓存，第一次获取的是clasName，通过className来创建对象，第二次去获取的时候就能直接获取到对应的namespaceHandler对象了</span></span><br><span class="line">			handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">			<span class="keyword">return</span> namespaceHandler;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">       ......</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法：<code>Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</code>该方法会去获所有的”META-INF&#x2F;spring.handlers”文件，并解析，然后建立映射关系(这让我想到java SPI和Dubbo SPI)</p>
<p>看下该方法的返回值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511964.png" alt="image-20210312022433159"></p>
<p>好了这就是Spring的SPI了，和dubbo一样，都是使用key，value的方式</p>
<p>看下spring.handlers:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511965.png" alt="image-20210312023838005"></p>
<p>这些类都是继承了NamespaceHandlerSupport</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511970.png" alt="image-20210312023927138"></p>
<p>方法<code>registerBeanDefinitionParser</code>的定义</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511967.png" alt="image-20210312023949703"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511968.png" alt="image-20210312025359762"></p>
<p>可以看到<code>registerBeanDefinitionParser</code>其实就是把BeanDefinitionParser放入到了一个parsers的Map中。这些解析类是什么时候调用的呢？往下看。</p>
<p>上面已经获取了得到了对应关系&lt;自定义标签名,NamespaceHandler&gt;，接着执行了方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br></pre></td></tr></table></figure>

<p>就可以根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类，一开始时，返回值是类的全限定名，这时就需要创建并缓存了。</p>
<p>接着就会创建该NamespaceHandler对象并执行到了NamespaceHandler的init方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="built_in">this</span>.classLoader);</span><br><span class="line">	<span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">NamespaceHandler</span> <span class="variable">namespaceHandler</span> <span class="operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用处理类的init方法，在init方法中完成标签元素解析类的注册</span></span><br><span class="line">	namespaceHandler.init();</span><br><span class="line">	handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">	<span class="keyword">return</span> namespaceHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边的介绍可知init方法是注册了各种自定义标签的解析类，把这些标签的解析类入了一个Map中。</p>
<p>好了，现在已经获取了自定义标签的NamespaceHandler，而且已经把对应的解析类都注册了，也就是说，比如xml文件这样写了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--自定义标签--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.enjoy.jack&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/context:component-scan&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:application.properties&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>经过上面的步骤，我通过context，得到了uri，也就是这个</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511969.png" alt="image-20210312030255546"></p>
<p>然后根据URI，并使用了SPI获取到了这个URI对应的<code>NamespaceHandlerSupport</code>，也就是<code>ContextNamespaceHandler</code>，而<code>ContextNamespaceHandler</code>的定义也很简单，就是重写了init方法，<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511970.png" alt="image-20210312023927138"></p>
<p>接着就创建<code>ContextNamespaceHandler</code>对象并调用了这个init方法，把<code>component-scan</code>、<code>property-placeholder</code>等这些对应的<code>BeanDefinitionParser</code>做了一个对应关系，并放入了一个Map中。</p>
<p>最后就只剩下解析了，回到<code>BeanDefinitionParserDelegate#parseCustomElement</code>方法。该方法最后执行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br></pre></td></tr></table></figure>

<p>handler就是之前获取的<code>ContextNamespaceHandler</code>，也就是<code>ContextNamespaceHandler</code>。上面介绍了<code>ContextNamespaceHandler</code>的定义，他是没有重写parse方法的，所以这方法是从父类NamespaceHandlerSupport中继承过来的</p>
<p>看NamespaceHandlerSupport#parse</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511971.png" alt="image-20210312031352326"></p>
<p>也就是根据标签获取对应的BeanDefinitionParser，接着执行了parse方法。</p>
<p>我们最关注的肯定是扫描标签:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511972.png" alt="image-20210312031532777"></p>
<p>所以根据上面的介绍可知<code>component-scan</code>对应的解析类是<code>ComponentScanBeanDefinitionParser</code></p>
<p><code>ComponentScanBeanDefinitionParser#parse</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line">	<span class="comment">//获取basePackage属性</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">basePackage</span> <span class="operator">=</span> element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">	basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">	<span class="comment">//可以用逗号分开</span></span><br><span class="line">	String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建注解扫描器</span></span><br><span class="line">	<span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">	<span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> configureScanner(parserContext, element);</span><br><span class="line">	<span class="comment">//扫描并把扫描的类封装成beanDefinition对象  核心方法，重要程度 5</span></span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">	registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取basePackage属性，就是包路径，然后调用configureScanner，创建注解扫描器<code>ClassPathBeanDefinitionScanner</code>。</p>
<h4 id="包扫描——ClassPathBeanDefinitionScanner"><a href="#包扫描——ClassPathBeanDefinitionScanner" class="headerlink" title="包扫描——ClassPathBeanDefinitionScanner"></a>包扫描——ClassPathBeanDefinitionScanner</h4><p>看下该类的类图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511973.png" alt="image-20210312234104974"></p>
<p>该类会去扫描有这些注解的类：</p>
<ul>
<li>@Component</li>
<li>@Service</li>
<li>@Repository</li>
<li>@Configuration</li>
</ul>
<p>看下<code>ClassPathBeanDefinitionScanner</code>的创建，useDefaultFilters默认就是true，不信自己看源码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">		Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">	<span class="built_in">this</span>.registry = registry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">		registerDefaultFilters();</span><br><span class="line">	&#125;</span><br><span class="line">	setEnvironment(environment);</span><br><span class="line">	setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>useDefaultFilters默认情况下为true，重点看下registerDefaultFilters：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">	<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">  <span class="comment">//不重要的方法</span></span><br><span class="line">  .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，就是把需要扫描的注解的class对象封装成<code>AnnotationTypeFilter</code>，然后放到了一个内部的集合<code>includeFilters</code>中</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511974.png" alt="image-20210312235056985"></p>
<p>回到代码，这里就放了Component.class这个注解！和上面说的不同，那我们就看下其他注解的定义</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511975.png" alt="image-20210312235253681"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511976.png" alt="image-20210312235304693"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511977.png" alt="image-20210312235312487"></p>
<p>其他3个注解都加了Component注解！也就是这些注解都能被识别</p>
<p>回到 <code>ComponentScanBeanDefinitionParser.parse</code>(Element element, ParserContext parserContext)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建注解扫描器</span></span><br><span class="line"><span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line"><span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> configureScanner(parserContext, element);</span><br><span class="line"><span class="comment">//扫描并把扫描的类封装成beanDefinition对象  核心方法，重要程度 5</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br></pre></td></tr></table></figure>

<p>创建完了<code>ClassPathBeanDefinitionScanner</code>后就执行了doScan，方法，看下该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">	Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">		<span class="comment">//扫描到有注解的类并封装成BeanDefinition对象</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">//还有其他代码，放在后面讲</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看<code>findCandidateComponents</code>，该方法会扫描到有Component注解的类并封装成BeanDefinition对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511978.png" alt="image-20210313000000565"></p>
<p>好，看scanCandidateComponents方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511979.png" alt="image-20210313000230205"></p>
<p>先创建了一个<code>Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;&gt;();</code></p>
<p>作用猜都猜到了，就是放包含注解的BeanDefintition的，看下resources有什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511980.png" alt="image-20210313000805963"></p>
<p>可以看到，resources就是指向一个类文件的对象。接着就是去遍历这些文件，并检查是否有<code>Component</code>注解。</p>
<p>看for循环的代码主要代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line"><span class="comment">//如果类上面有includeFilters注解</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">	<span class="type">ScannedGenericBeanDefinition</span> <span class="variable">sbd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScannedGenericBeanDefinition</span>(metadataReader);</span><br><span class="line">	sbd.setSource(resource);</span><br><span class="line">	<span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Identified candidate component class: &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">		candidates.add(sbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很好理解，就是把类的的信息封装成MetadataReader对象，然后检查是否有对应的注解，有就创建一个<code>ScannedGenericBeanDefinition</code>对象。</p>
<p>这里先重点说下这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> getMetadataReaderFactory().getMetadataReader(resource);</span><br></pre></td></tr></table></figure>

<p>getMetadataReaderFactory()返回的是<code>CachingMetadataReaderFactory</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511981.png" alt="image-20210313002413453"></p>
<p>接着getMetadataReader方法，这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511982.png" alt="image-20210313002508509"></p>
<blockquote>
<p>里面的源码不说，不过这里有个疑问，spring会不会去触发类的加载，如果有触发，那传个ClassLoader进去是可以理解的，因为一个类的最终确定，是要类加载器和类的全限定名来确定的，而如果有触发，那就会把类的静态存储结构转化为方法区的运行时数据结构，也就是说会占用内存，如果有大量的类是不使用的，那就浪费资源了。</p>
<p>我稍微看了这个getMetadataReader，没细看，而且之前生产BeanDefinition的时候是没触发类的加载的。所以猜测是用了和javap类似的技术，去解析类的静态存储结构里的数据。</p>
</blockquote>
<p>回到遍历的代码，现在看下MetadataReader对象的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511983.png" alt="image-20210313005118501"></p>
<p>回到代码， isCandidateComponent(metadataReader)这个方法匹配会匹配是否有对应的注解，有就会去创建<code>ScannedGenericBeanDefinition</code></p>
<p>看下<code>ScannedGenericBeanDefinition</code>的类图:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511984.png" alt="image-20210313005738915"></p>
<p>它是继承了<code>GenericBeanDefinition</code>，里面就多了个AnnotationMetadata属性，也就是保存了注解的属性</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511985.png" alt="image-20210313005841981"></p>
<p>注意在这一步只是传入AnnotationMetadata属性后就放入之前创建的集合中了，类中注解里面的属性值和其他注解信息还没设置。</p>
<p>回到ClassPathBeanDefinitionScanner#doScan方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">  <span class="comment">//省略了部分代码</span></span><br><span class="line">  .....</span><br><span class="line">		<span class="comment">//扫描到有注解的类并封装成BeanDefinition对象</span></span><br><span class="line">		Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">		<span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">//bean的范围</span></span><br><span class="line">			<span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">			candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">			<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">				postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 用注解的信息来完善BeanDefinition</span></span><br><span class="line">			<span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">				<span class="comment">//支持了@Lazy @DependOn注解</span></span><br><span class="line">				AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//省略的部分代码</span></span><br><span class="line">      ....</span><br><span class="line">      代码<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">//省略了部分代码</span></span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511986.png" alt="image-20210313010543195"></p>
<blockquote>
<p>可以看到，之前讲bean标签的时候没说，String中bean的范围默认是<code>singleton</code>也就是单例。</p>
</blockquote>
<p>上面的代码就是解析注解，然后对BeanDefinition的属性数据填充，bean的范围啊、是否懒加载。具体看<a href="00Spring%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%9B%BE">BeanDefinition的信息图</a></p>
<p>好了，BeanDefinition的初始化就完成了，现在还差个注册。</p>
<h3 id="beanDefinition注册到BeanFactory对象中"><a href="#beanDefinition注册到BeanFactory对象中" class="headerlink" title="beanDefinition注册到BeanFactory对象中"></a>beanDefinition注册到BeanFactory对象中</h3><blockquote>
<p>这里的BeanFactory真实类型就是一开始创建测DefaultListableBeanFactory，而该类又实现了BeanDefinitionRegistry接口，所以这里涉及到的BeanDefinitionRegistry的对应引用都是<code>DefaultListableBeanFactory</code>类型的对象</p>
</blockquote>
<p>默认标签的BeanDefinition和自定义标签的BeanDefinition在创建完后都要注册器BeanFactory中。</p>
<p>这里以自定义标签的BeanDefinition的注册来讲。</p>
<p>代码接着上面doScan代码</p>
<p>最后检查BeanDefinition是否已经已经注册了，没有就去注册。执行<em>代码1</em>(是在doScan的for循环里面的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否已经注册过了</span></span><br><span class="line"><span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">	<span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">	definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">	beanDefinitions.add(definitionHolder);</span><br><span class="line">	<span class="comment">//BeanDefinition注册</span></span><br><span class="line">	registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是包装，这里会把把<code>BeanDefinition</code>，包装成了一个<code>BeanDefinitionHolder</code>，然后执行了</p>
<p><code>registerBeanDefinition(definitionHolder, this.registry);</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511992.png" alt="image-20210313012431590"></p>
<p>这个<code>BeanDefinitionRegistry</code>的实现是<code>DefaultListableBeanFactory</code>！终于看到BeanFactory了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511988.png" alt="image-20210313012814381"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511989.png" alt="image-20210313013001342"></p>
<p><code>DefaultListableBeanFactory</code>实现了<code>BeanDefinitionRegistry</code>这个接口，看名字就知道作用是什么了。</p>
<p>看<code>DefaultListableBeanFactory#registerBeanDefinition</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="comment">//省略校验代码</span></span><br><span class="line">   .....</span><br><span class="line">	<span class="comment">//先判断BeanDefinition是否已经注册</span></span><br><span class="line">	<span class="type">BeanDefinition</span> <span class="variable">existingDefinition</span> <span class="operator">=</span> <span class="built_in">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">     <span class="comment">//是否允许覆盖</span></span><br><span class="line">		<span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionOverrideException</span>(beanName, beanDefinition, existingDefinition);</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="comment">//只是打印信息而已</span></span><br><span class="line">     .....</span><br><span class="line">		<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">			<span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">				updatedDefinitions.addAll(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				<span class="built_in">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">				removeManualSingletonName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//把beanDefinition缓存到map中</span></span><br><span class="line">			<span class="comment">// Still in startup registration phase</span></span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			<span class="comment">//把beanName放到beanDefinitionNames list中，这个list着重记住，bean实例化的时候需要用到</span></span><br><span class="line">			<span class="built_in">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">			removeManualSingletonName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (existingDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册实际上就是放入<code>DefaultListableBeanFactory</code>中的beanDefinitionMap中，并且把beanDefinition对应的名字放入<code>DefaultListableBeanFactory</code>的beanDefinitionNames的集合中。而这个beanName，默认规则是类的名字，头字母小写。</p>
<p>这里涉及到两个集合<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>，看下这两个属性的定义</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511990.png" alt="image-20210313014132169"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511991.png" alt="image-20210313014149903"></p>
<p>好了，现在BeanDefinition已经注册到beanFactory中了，看下之后的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511992.png" alt="image-20210313012431590"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511993.png" alt="image-20210313014738775"></p>
<p>别名也去注册了，不过别名是和beanName做映射的。(这让我想起了Innodb中聚集索引和非聚集索引的关系)</p>
<p>也就是说，通过别名找bean，实际上是找到了bean的beanName，然后才找到bean的</p>
<p>现在已经完成了BeanDefinition的注册了，回到调用的地方<code>ComponentScanBeanDefinitionParser#parse</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511994.png" alt="image-20210313015034077"></p>
<p>注册完BeanDefinition后，还执行了一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br></pre></td></tr></table></figure>

<p>这代码的核心是在</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511995.png" alt="image-20210313022033540"></p>
<p>由于这是扫描注解的，annotationConfig是为true的，所以会执行<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code>添加各种的PostProcessor，而重点的PostProcessor如下：</p>
<ol>
<li><p>添加ConfigurationClassPostProcessor<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511996.png" alt="image-20210313015518043"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511997.png" alt="image-20210313015504990"></p>
</li>
<li><p>添加AutowiredAnnotationBeanPostProcessor</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511998.png" alt="image-20210313020415219"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569511999.png" alt="image-20210313020431890"></p>
</li>
<li><p>添加CommonAnnotationBeanPostProcessor<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512000.png" alt="image-20210313020511410"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512001.png" alt="image-20210313020522342"></p>
</li>
</ol>
<p>上面的3处代码都会检查下刚刚注册的beanDefinition中有没有名字为下面的：</p>
<ul>
<li><code>org.springframework.context.annotation.internalConfigurationBeanNameGenerator</code></li>
<li><code>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</code></li>
<li><code>org.springframework.context.annotation.internalCommonAnnotationProcessor</code></li>
</ul>
<p>这些的<code>BeanDefinition</code>如果没有就创建对应的<code>RootBeanDefinition</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br></pre></td></tr></table></figure>

<p>然后把创建好的<code>RootBeanDefinition</code>作为后置处理器（BeanDefinitionRegistryPostProcessor）注册到注册器beanFactory中。</p>
<p>这三个类很重要，和之后的流程有关，这里就记下是在什么时候到把这些PostProcessor注册到beanFactory中的：</p>
<ul>
<li><code>CommonAnnotationBeanPostProcessor.class</code></li>
<li><code>AutowiredAnnotationBeanPostProcessor.class</code></li>
<li><code>ConfigurationClassPostProcessor.class</code></li>
</ul>
<p>看下各个类的类图</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512022.png" alt="image-20210313023954299"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512023.png" alt="image-20210313024038039"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512163.png" alt="image-20210313024104673"></p>
<h2 id="xml解析和BeanDefinition封装核心方法"><a href="#xml解析和BeanDefinition封装核心方法" class="headerlink" title="xml解析和BeanDefinition封装核心方法"></a>xml解析和BeanDefinition封装核心方法</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/3305883018996076545.jpg" alt="xml解析和BeanDefinition封装核心方法 refreshBeanFactory()"></p>
<h2 id="扫描的流程图"><a href="#扫描的流程图" class="headerlink" title="扫描的流程图"></a>扫描的流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512006.jpg" alt="&lt;context_component-scan base-package=&quot;&quot;&gt;解析流程"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nbobj.github.io/blog/spring/01-Spring%E4%B8%ADBeanDefinition%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C/">https://nbobj.github.io/blog/spring/01-Spring中BeanDefinition的创建和注册/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nbobj.github.io" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/spring/02-Spinrg%E7%9A%84%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8-BeanDefinitionRegistryPostProcessor%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/">02-Spinrg的后置处理器-BeanDefinitionRegistryPostProcessor调用时机</a><a class="next" href="/blog/spring/00%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84WebMvcConfigurer%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84/">00在SpringBoot项目中实现自己的WebMvcConfigurer需要注意的</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">321</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#XmlBeanDefinitionReader"><span class="toc-number">1.</span> <span class="toc-text">XmlBeanDefinitionReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanDefinitionDocumentReader"><span class="toc-number">2.</span> <span class="toc-text">BeanDefinitionDocumentReader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%A0%87%E7%AD%BE%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">默认标签解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.</span> <span class="toc-text">自定义标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E6%89%AB%E6%8F%8F%E2%80%94%E2%80%94ClassPathBeanDefinitionScanner"><span class="toc-number">2.2.1.</span> <span class="toc-text">包扫描——ClassPathBeanDefinitionScanner</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beanDefinition%E6%B3%A8%E5%86%8C%E5%88%B0BeanFactory%E5%AF%B9%E8%B1%A1%E4%B8%AD"><span class="toc-number">2.3.</span> <span class="toc-text">beanDefinition注册到BeanFactory对象中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E8%A7%A3%E6%9E%90%E5%92%8CBeanDefinition%E5%B0%81%E8%A3%85%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">xml解析和BeanDefinition封装核心方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.</span> <span class="toc-text">扫描的流程图</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/05-Nacos%E4%B8%AD%E7%9A%84AbstractNacosTaskExecuteEngine/" title="05-Nacos中的AbstractNacosTaskExecuteEngine">05-Nacos中的AbstractNacosTaskExecuteEngine</a><time datetime="2021-11-27T12:00:40.000Z" title="发表于 2021-11-27 20:00:40">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/04-Server%E5%92%8CClient%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96nacos%E5%9C%B0%E5%9D%80/" title="04-Server和Client动态获取nacos地址">04-Server和Client动态获取nacos地址</a><time datetime="2021-11-27T12:00:39.000Z" title="发表于 2021-11-27 20:00:39">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/03-Nacos%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" title="03-Nacos的发布与订阅">03-Nacos的发布与订阅</a><time datetime="2021-11-27T12:00:38.000Z" title="发表于 2021-11-27 20:00:38">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/02-Nacos%20Server%E4%B8%AD%E7%9A%84Secured%E6%B3%A8%E8%A7%A3/" title="02-Nacos Server中的Secured注解">02-Nacos Server中的Secured注解</a><time datetime="2021-11-27T12:00:37.000Z" title="发表于 2021-11-27 20:00:37">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/01-Nacos%20Server%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" title="01-Nacos Server服务注册表的写时复制">01-Nacos Server服务注册表的写时复制</a><time datetime="2021-11-27T12:00:36.000Z" title="发表于 2021-11-27 20:00:36">2021-11-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>