<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>04-Spring的Bean实例化 | XYZhi's学习笔记</title><meta name="keywords" content="spring"><meta name="author" content="xyz"><meta name="copyright" content="xyz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实例化也是在refresh()方法中完成的。上refresh()源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868">
<meta property="og:type" content="article">
<meta property="og:title" content="04-Spring的Bean实例化">
<meta property="og:url" content="https://nbobj.github.io/blog/spring/04-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96/index.html">
<meta property="og:site_name" content="XYZhi&#39;s学习笔记">
<meta property="og:description" content="实例化也是在refresh()方法中完成的。上refresh()源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg">
<meta property="article:published_time" content="2021-11-25T12:00:10.000Z">
<meta property="article:modified_time" content="2022-03-23T09:03:54.612Z">
<meta property="article:author" content="xyz">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nbobj.github.io/blog/spring/04-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: xyz","link":"链接: ","source":"来源: XYZhi's学习笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '04-Spring的Bean实例化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 17:03:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">321</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">XYZhi's学习笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">04-Spring的Bean实例化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-25T12:00:10.000Z" title="发表于 2021-11-25 20:00:10">2021-11-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T09:03:54.612Z" title="更新于 2022-03-23 17:03:54">2022-03-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/">开源框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="04-Spring的Bean实例化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>实例化也是在refresh()方法中完成的。上refresh()源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">		<span class="comment">//为容器初始化做准备，重要程度：0</span></span><br><span class="line">		<span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		   重要程度：5</span></span><br><span class="line"><span class="comment">		  1、创建BeanFactory对象</span></span><br><span class="line"><span class="comment">		* 2、xml解析</span></span><br><span class="line"><span class="comment">		* 	传统标签解析：bean、import等</span></span><br><span class="line"><span class="comment">		* 	自定义标签解析 如：&lt;context:component-scan base-package=&quot;com.xiangxue.jack&quot;/&gt;</span></span><br><span class="line"><span class="comment">		* 	自定义标签解析流程：</span></span><br><span class="line"><span class="comment">		* 		a、根据当前解析标签的头信息找到对应的namespaceUri</span></span><br><span class="line"><span class="comment">		* 		b、加载spring所有jar中的spring.handlers文件。并建立映射关系</span></span><br><span class="line"><span class="comment">		* 		c、根据namespaceUri从映射关系中找到对应的实现了NamespaceHandler接口的类</span></span><br><span class="line"><span class="comment">		* 		d、调用类的init方法，init方法是注册了各种自定义标签的解析类</span></span><br><span class="line"><span class="comment">		* 		e、根据namespaceUri找到对应的解析类，然后调用paser方法完成标签解析</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		* 3、把解析出来的xml标签封装成BeanDefinition对象</span></span><br><span class="line"><span class="comment">		* */</span></span><br><span class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">		<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 给beanFactory设置一些属性值，可以不看</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * BeanDefinitionRegistryPostProcessor</span></span><br><span class="line"><span class="comment">			 * BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">			 * 完成对这两个接口的调用</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 把实现了BeanPostProcessor接口的类实例化，并且加入到BeanFactory中</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 国际化,重要程度2</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//初始化事件管理类</span></span><br><span class="line">			<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这个方法着重理解模板设计模式，因为在springboot中，这个方法是用来做内嵌tomcat启动的</span></span><br><span class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 往事件管理类中注册事件类</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 这个方法是spring中最重要的方法，没有之一</span></span><br><span class="line"><span class="comment">			 * 所以这个方法一定要理解要具体看</span></span><br><span class="line"><span class="comment">			 * 1、bean实例化过程</span></span><br><span class="line"><span class="comment">			 * 2、ioc</span></span><br><span class="line"><span class="comment">			 * 3、注解支持</span></span><br><span class="line"><span class="comment">			 * 4、BeanPostProcessor的执行</span></span><br><span class="line"><span class="comment">			 * 5、Aop的入口</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">						<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Propagate exception to caller.</span></span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean的实例话时在<code>finishBeanFactoryInitialization(beanFactory);</code>方法中完成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">  <span class="comment">//省略不重要的方法</span></span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">	beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">	beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重点看这个方法，重要程度：5</span></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看最后的方法<code>beanFactory.preInstantiateSingletons();</code>（beanFactory终于不只是注册和查找了，终于有一个与它的名字相匹配的操作了）。方法翻译是<code>实例化单例</code>，那看看是怎么实例化Bean的吧。</p>
<h2 id="DefaultListableBeanFactory-preInstantiateSingletons"><a href="#DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="DefaultListableBeanFactory#preInstantiateSingletons"></a>DefaultListableBeanFactory#preInstantiateSingletons</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 具体实例化过程</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">	<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">	<span class="comment">// 把所有beanName都缓存到beanDefinitionNames了，这时这个BeanName所对应的是BeanDefinition</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		<span class="comment">//把父BeanDefinition里面的属性拿到子BeanDefinition中</span></span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		<span class="comment">//如果不是抽象的，单例的，非懒加载的就实例化</span></span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">			<span class="comment">//判断bean是否实现了FactoryBean接口，这里可以不看  &amp;factoryBeanDemo</span></span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">					FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">					<span class="type">boolean</span> isEagerInit;</span><br><span class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(</span><br><span class="line">								(PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">								getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//主要从这里进入，看看实例化过程</span></span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">			<span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">			<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步就是</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512039.png" alt="image-20210313232407987"></p>
<p>这个<code>beanDefinitionNames</code>就是BeanDefinition放入beanFactory的Map中后，还会把beanName放入到到beanFactory的一个list列表中，这个列表就是<code>beanDefinitionNames</code>。</p>
<p>然后就是遍历这个列表了。在for循环中第一行代码</p>
<p><code>RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</code>，它是把父BeanDefinition里面的属性拿到子BeanDefinition中，这是一个深度拷贝的过程，而且会返回一个RootBeanDefinition，表示该BeanDefinition需要实例化了</p>
<p>比如是这样定义</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512040.png" alt="image-20210313232853060"></p>
<p>比如在多数据源时，有一个父的bean保存一个共有的信息，而一些独有的信息就放在自己的bean中，那这时是要这样定义就好了。</p>
<p>继续看代码，如果不是抽象的，是单例的，非懒加载的就实例化，那会进入到if中，</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512041.png" alt="image-20211201014139041"></p>
<p>这里主要看else吧，if的话是对那些实现<code>FactoryBean</code>接口的类实例化的，这里之后再看。</p>
<h2 id="AbstractBeanFactory-getBean"><a href="#AbstractBeanFactory-getBean" class="headerlink" title="AbstractBeanFactory#getBean"></a>AbstractBeanFactory#getBean</h2><p>getBean方法是由父类<code>AbstractBeanFactory</code>实现，跟踪代码，最后看AbstractBeanFactory#doGetBean</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">		String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="comment">// 这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&amp;这个符号</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从缓存中拿实例</span></span><br><span class="line">	<span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="comment">//如果缓存里面能拿到实例</span></span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//该方法是FactoryBean接口的调用入口</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果singletonObjects缓存里面没有，则走下来</span></span><br><span class="line">		<span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">		<span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">		<span class="comment">//如果是scope 是Prototype的，校验是否有出现循环依赖，如果有则直接报错</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">				<span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">						nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//父子BeanDefinition合并</span></span><br><span class="line">			<span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//获取依赖对象属性，依赖对象要先实例化</span></span><br><span class="line">			<span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">//实例化</span></span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//着重看，大部分是单例的情况</span></span><br><span class="line">			<span class="comment">// Create bean instance.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">						<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">						<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">						<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">						destroySingleton(beanName);</span><br><span class="line">						<span class="keyword">throw</span> ex;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="comment">//该方法是FactoryBean接口的调用入口</span></span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//该方法是FactoryBean接口的调用入口</span></span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">						beforePrototypeCreation(beanName);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">finally</span> &#123;</span><br><span class="line">							afterPrototypeCreation(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">							<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">			<span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> convertedBean;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br></pre></td></tr></table></figure>

<p>这里会解析出真实的beanName，对于实现了FactoryBean的接口，在进入这个方法时会在beanName前加上&amp;这个符号。经过这个方法后，会去掉&amp;符号，所以进入了方法后对于FactoryBean的接口的BeanDefinition，会有两个名字，一个是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&amp;beanName</span><br><span class="line">beanName=beanName</span><br></pre></td></tr></table></figure>

<p>接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>

<p><code>getSingleton</code>方法是从<code>DefaultSingletonBeanRegistry</code>继承过来的，该方法会根据beanName从缓存中拿实例，进去看看<code>getSingleton</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">	<span class="comment">//根据beanName从缓存中拿实例</span></span><br><span class="line">	<span class="comment">//先从一级缓存拿</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="comment">//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">//从二级缓存中拿</span></span><br><span class="line">			singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">//如果还拿不到，并且允许bean提前暴露</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">//从三级缓存中拿到对象工厂</span></span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">//从工厂中拿到对象</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="comment">//升级到二级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="comment">//删除三级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是从缓存一级一级找。回到开始的，看没拿到的情况，也就是else代码块的代码。</p>
<h3 id="通过父BeanFactory获取bean"><a href="#通过父BeanFactory获取bean" class="headerlink" title="通过父BeanFactory获取bean"></a>通过父BeanFactory获取bean</h3><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512042.png" alt="image-20211211022135215"></p>
<p>可以看到，这段代码先通过<code>getParentBeanFactory()</code>父BeanFactory，如果存在，并且当前的BeanFactory不存在对应beanName的BeanDefinition，那么就会尝试使用父BeanFactory获取Bean。</p>
<h3 id="DefaultSingletonBeanRegistry-getSingleton"><a href="#DefaultSingletonBeanRegistry-getSingleton" class="headerlink" title="DefaultSingletonBeanRegistry#getSingleton"></a>DefaultSingletonBeanRegistry#getSingleton</h3><p>先看下面的代码段：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512043.png" alt="image-20210313235308007"></p>
<p><code>RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</code>上面讲过了，看下面处理dependsOn的</p>
<p>比如这样定义一个bean</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512044.png" alt="image-20210313235418803"></p>
<p>那这个student的实例化是要依赖james13的，也就是说james13要先实例话，student才能实例话。回到源码，逻辑就是上面的逻辑，也就是先去getBean(‘james13’)，然后在往下实例化student</p>
<p>接着看代码块：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512045.png" alt="image-20210313235741114"></p>
<p>从if就知道，这代码块就是创建单例的Bean，也就是默认的情况。</p>
<p><code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>方法又是从<code>DefaultSingletonBeanRegistry</code>继承过来的</p>
<p>看<code>DefaultSingletonBeanRegistry#getSingleton</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">	Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="comment">//如果缓存中有，则直接返回</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//打印日志</span></span><br><span class="line">			......</span><br><span class="line">			<span class="comment">//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean</span></span><br><span class="line">			beforeSingletonCreation(beanName);</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">				<span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//如果这里有返回值，就代表这个bean已经结束创建了，已经完全创建成功</span></span><br><span class="line">				singletonObject = singletonFactory.getObject();</span><br><span class="line">				newSingleton = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">				<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">				<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">				singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">						ex.addRelatedCause(suppressedException);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//bean创建完成后singletonsCurrentlyInCreation要删除该bean</span></span><br><span class="line">				afterSingletonCreation(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">				<span class="comment">//创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存</span></span><br><span class="line">				addSingleton(beanName, singletonObject);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注这里的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory&lt;?&gt; singletonFactory = &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      .....</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>先从一级缓<code>singletonObjects集合</code>中存拿对象，看没拿到的情况就会进行创建逻辑</p>
<p><code>beforeSingletonCreation(beanName);</code>，该方法的作用就是把beanName添加到singletonsCurrentlyInCreation容器中，在这个集合里面的bean都是正在实例化的bean。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512046.png" alt="image-20210314000930688"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512047.png" alt="image-20210314000953492"></p>
<p>接着到</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512048.png" alt="image-20210314001122568"></p>
<p>这个singletonFactory是在进入方法时传的一个匿名对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512049.png" alt="image-20210314001302269"></p>
<p>也就是说，调用getObject时，实际上时调用了createBean(beanName, mbd, args)方法。注意</p>
<ol>
<li><p>getObject调用完成后，就意味着bean已经完成了创建</p>
</li>
<li><p>上面的<code>createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</code>方法是在<code>AbstractBeanFactory</code>中定义的，它是一个抽象方法，这个方法的实现由<code>AbstractAutowireCapableBeanFactory</code>实现。</p>
</li>
</ol>
<p>看<code>AbstractAutowireCapableBeanFactory#createBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">	<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">	<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	<span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">		mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare method overrides.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//去掉了catch语句块</span></span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * TargetSource接口的运用，可以在用改一个类实现该接口，然后在里面定义实例化对象的方式，然后返回</span></span><br><span class="line"><span class="comment">		 * 也就是说不需要spring帮助我们实例化对象</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 这里可以直接返回实例本身</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 这个代码不用看，实际开发过程中用不到，我会做为一个甜点分享</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//去掉了catch语句块</span></span><br><span class="line">  .......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//主要看这个方法，重要程度 5</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//去掉了catch语句块</span></span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点看这段代码块：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512050.png" alt="image-20210314002619078"></p>
<h3 id="AbstractAutowireCapableBeanFactory-doCreateBean"><a href="#AbstractAutowireCapableBeanFactory-doCreateBean" class="headerlink" title="AbstractAutowireCapableBeanFactory#doCreateBean"></a>AbstractAutowireCapableBeanFactory#doCreateBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	<span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">		instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">//创建实例,,重点看，重要程度：5</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//CommonAnnotationBeanPostProcessor  支持了@PostConstruct，@PreDestroy,@Resource注解</span></span><br><span class="line">				<span class="comment">//AutowiredAnnotationBeanPostProcessor 支持 @Autowired,@Value注解</span></span><br><span class="line">				<span class="comment">//BeanPostProcessor接口的典型运用，这里要理解这个接口</span></span><br><span class="line">				<span class="comment">//对类中注解的装配过程</span></span><br><span class="line">				<span class="comment">//重要程度5，必须看</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="comment">//打印日志</span></span><br><span class="line">        .......</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">	<span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">	<span class="comment">//是否	单例bean提前暴露</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			<span class="comment">//打印日志</span></span><br><span class="line">      ......</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存</span></span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//ioc di，依赖注入的核心方法，该方法必须看，重要程度：5</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		<span class="comment">//bean 实例化+ioc依赖注入完以后的调用，非常重要，重要程度：5</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">//抛出BeanCreationException错误</span></span><br><span class="line">    .......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">//抛出BeanCurrentlyInCreationException错误</span></span><br><span class="line">        	.......</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//注册bean销毁时的类DisposableBeanAdapter</span></span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">    <span class="comment">//抛出BeanCreationException错误</span></span><br><span class="line">    .......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个<em>非常非常重要</em>的方法，这里包含一个Spring bean的整个初始化流程，重要的方法</p>
<ol>
<li><code>BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</code></li>
<li><code>void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</code></li>
<li><code>void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code></li>
<li><code>void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</code></li>
<li><code>Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd)</code></li>
<li><code>void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd)</code></li>
</ol>
<p>下面我们一个个方法</p>
<h4 id="createBeanInstance—-Bean-的实例化过程（控制反转IOC）"><a href="#createBeanInstance—-Bean-的实例化过程（控制反转IOC）" class="headerlink" title="createBeanInstance—-Bean 的实例化过程（控制反转IOC）"></a><code>createBeanInstance</code>—-Bean 的实例化过程（控制反转IOC）</h4><p>先看这段代码，也就是开头的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512051.png" alt="image-20210314003020512"></p>
<p>真正是实例就是在这段代码里完成的。</p>
<p>先总结这个方法的作用：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512052.png" alt="image-20210314003604150"></p>
<p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">	<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">	Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">    <span class="comment">//抛出BeanCreationException错误</span></span><br><span class="line">    .......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">	<span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果有FactoryMethodName属性 @Bean</span></span><br><span class="line">	<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">				resolved = <span class="literal">true</span>;</span><br><span class="line">				autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">		<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">	<span class="comment">//寻找当前正在实例化的bean中有@Autowired注解的构造函数</span></span><br><span class="line">	Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">	<span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">			mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">		<span class="comment">//如果ctors不为空，就说明构造函数上有@Autowired注解</span></span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">	ctors = mbd.getPreferredConstructors();</span><br><span class="line">	<span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造函数的实例化,大部分的实例是采用的无参构造函数的方式实例化</span></span><br><span class="line">	<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">	<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="lt-bean-gt-标签里面。配置了factory-method属性的情况"><a href="#lt-bean-gt-标签里面。配置了factory-method属性的情况" class="headerlink" title="&lt;bean&gt;标签里面。配置了factory-method属性的情况"></a>&lt;bean&gt;标签里面。配置了factory-method属性的情况</h5><p>先执行这里：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512053.png" alt="image-20210314004115677"></p>
<p>这段代码的if只有在下面的情况才会进去。</p>
<ul>
<li><bean>标签里面。配置了factory-method属性<br>  <img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512056.png" alt="image-20210314004547189"></li>
<li>或者方法上面加上@Bean注解</li>
</ul>
<p>看下<code>AbstractAutowireCapableBeanFactory#instantiateUsingFactoryMethod</code>方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512055.png" alt="image-20210314005401023"></p>
<p><code>ConstructorResolver#instantiateUsingFactoryMethod</code>方法:(不弄完整的代码了，只看核心的)</p>
<p>这样配置的情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512056.png" alt="image-20210314004547189"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512057.png" alt="image-20210314005636142"></p>
<p>创建好了<code>BeanWrapperImpl</code>包装类后，调用<code>beanFactory.getBean(factoryBeanName)</code>，也就是说先去获取factoryBean(没有就执行创建流程)，获取到了方法所对应的对象，并且isStatic &#x3D; false。接着走</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512058.png" alt="image-20210314010407818"></p>
<p>从所有factoryBean对应的类中拿到全部方法，并找到匹配的方法，而且由于isStatic &#x3D; false，所以不能拿到静态的方法。接着走</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512059.png" alt="image-20210314010731964"></p>
<p>instantiate方法不用看了，就是用反射调用这种形式的api：<code>Method.invoke(Object object, Object... args)</code></p>
<p>方法调用完后就按定义实力化bean了，并返回了。接着会把放回的bean放入到之前创建的<code>BeanWrapperImpl</code>的对象中。后面还有多个方法，不过我不想看了，最后还是只有一个方法会被调用。</p>
<p>不过除了上面的情况还，还可以这样配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512060.png" alt="image-20210314011825277"></p>
<p>不过这就要求方法factoryMethod是静态的方法了。这种情况就会走到一开始的else情况，后面都一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512061.png" alt="image-20210314011933372"></p>
<p>factory-method的处理结束了。</p>
<h5 id="方法上面加上-Bean注解"><a href="#方法上面加上-Bean注解" class="headerlink" title="方法上面加上@Bean注解"></a>方法上面加上@Bean注解</h5><p>@Bean的方式是使用了factory-method的方式来实现的，它使用的是非静态方法的那种方式。</p>
<p>比如有这样的配置类</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512062.png" alt="image-20210314012415407"></p>
<p>其实就是相当于</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512063.png" alt="image-20210314012618777"></p>
<h5 id="实例化带有-Autowired注解的构造函数"><a href="#实例化带有-Autowired注解的构造函数" class="headerlink" title="实例化带有@Autowired注解的构造函数"></a>实例化带有@Autowired注解的构造函数</h5><p>回到<code>AbstractAutowireCapableBeanFactory#createBeanInstance</code>，代码一直走</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512064.png" alt="image-20210314013048372"></p>
<p>这个方法的作用就是通过构造方法注入值，比如有这样一个类</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512065.png" alt="image-20210314013331498"></p>
<p>那Spring会把sc对象，和cq对象传入AutowiredConsturctorBean对象中。看回源码。</p>
<p>代码<code>determineConstructorsFromBeanPostProcessors</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512066.png" alt="image-20210314013940526"></p>
<p>getBeanPostProcessors()回获取<code>BeanPostProcessor</code>的实例，这些实例是在refresh()方法中，执行了<code>BeanDefinitionRegistryPostProcessor</code>这种后置处理器的方法后，调用了<code>registryBeanPostProcessor</code>方法去实例化对应的<code>BeanPostProcessor</code>的实例，并且注册到beanFacotry的beanPostProcessors中</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512067.png" alt="image-20210314014426024"></p>
<p>回到for代码。这里会有多个<code>BeanPostProcessor</code>会被调用到，不过我们关注的是这个</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512068.png" alt="image-20210314014728053"></p>
<p><code>AutowireAnnotationBeanPostProcessor</code>，进去看<code>determineCandidateConstructors</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512069.png" alt="image-20210314015210347"></p>
<p>代码接着走</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512070.png" alt="image-20210314015307522"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512071.png" alt="image-20210314015354758"></p>
<p>遍历构造函数，获取到构造函数上的@Autowired注解信息，接着</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512072.png" alt="image-20210314015628822"></p>
<p>获取@Autowired的required的值，默认为true。这个值的作用就是为true时，如果注入的对象不存在就报错，为false的时候，如果如果注入的对象不存在，不报错(对应引用，还是使用默认值null)。</p>
<p>最后<img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512073.png" alt="image-20210314020016027"></p>
<p>放入<code>candidateConstructorsCache</code>后就返回了</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512074.png" alt="image-20210314020031833"></p>
<p>回到<code>AbstractAutowireCapableBeanFactory#createBeanInstance</code>，假如返回的不为null，那看方法</p>
<p><code>autowireConstructor(beanName, mbd, ctors, args)</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512075.png" alt="image-20210314020226016"></p>
<p>看<code>ConstructorResolver#autowireConstructor</code>方法</p>
<p>该方法其实是更具构造方法创建对象的过程，不过有个问题，就是构造方法的参数怎么获取。其实我猜测和factoryMethod一样。跟踪源码一直到</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512076.png" alt="image-20210314022410320"></p>
<p>这方法的流程太长了，代码不看了，最后都会调用<code>beanFactory.getBean</code>方法。</p>
<p>有一种情况，多个构造函数上有@Autowire，默认情况下会报错，因为源码中</p>
<p>回到<code>AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors</code>方法，在</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512077.png" alt="image-20210314024535945"></p>
<p>只要required&#x3D;false就不报错了。如果有多个构造函数，会根据构造函数参数个数排序，而且只会用一个构造函数。</p>
<h5 id="实例化没有-Autowired的有参构造函数"><a href="#实例化没有-Autowired的有参构造函数" class="headerlink" title="实例化没有@Autowired的有参构造函数"></a>实例化没有@Autowired的有参构造函数</h5><p><code>AutowireAnnotationBeanPostProcessor#determineConstructorsFromBeanPostProcessors</code>方法在没有@Autowired是会根据情况返回构造函数的。之后都是调用autowireConstructor方法的。不过对于这种情况要注意一点，如果想这种情况走通，一定只能有一个带参数的构造函数。</p>
<h5 id="实例化无参构造函数"><a href="#实例化无参构造函数" class="headerlink" title="实例化无参构造函数"></a>实例化无参构造函数</h5><p>上面的情况都不符合的才会走到这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512078.png" alt="image-20210314031529751"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实就是如果有依赖别的bean的，先去创建别的bean。而且这里只是分配的内存空间，对象的属性还没有处理，也就是还没到依赖注入这阶段。</p>
<h4 id="applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程"><a href="#applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程" class="headerlink" title="applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程"></a>applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程</h4><p>createBeanInstance方法只是实例化对象(控制反转)，并没有处理依赖注入的问题。而applyMergedBeanDefinitionPostProcessors会对类中注解执行收集过程</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512079.png" alt="image-20210314033015562"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512080.png" alt="image-20210314033030615"></p>
<p>又是getBeanPostProcessors()，在这里Spring会帮我们放入一些<code>BeanPostProcessor</code>，这里还有个要求，就是要实现的是<code>MergedBeanDefinitionPostProcessor</code>这个接口，看会<a href="./01-Spring%E4%B8%ADBeanDefinition%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B3%A8%E5%86%8C">01-Spring中BeanDefinition的创建和注册</a>最后的3张类图，我们关注的3个<code>BeanPostProcessor</code>只有两个是实现这个接口的。这两个就是</p>
<ul>
<li><code>CommonAnnotationBeanPostProcessor</code></li>
<li><code>AutowiredAnnotationBeanPostProcessor</code></li>
</ul>
<p>下面看这个两个类的<code>postProcessMergedBeanDefinition</code>方法</p>
<h5 id="AutowiredAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><a href="#AutowiredAnnotationBeanPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition"></a><code>AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</code></h5><p>跟踪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">	<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, beanType, <span class="literal">null</span>);</span><br><span class="line">	metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, <span class="meta">@Nullable</span> PropertyValues pvs)</span> &#123;</span><br><span class="line">	<span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">	<span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">	<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">	<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">			metadata = <span class="built_in">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">			<span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">					metadata.clear(pvs);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//主要看这个方法</span></span><br><span class="line">				metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">				<span class="built_in">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br><span class="line"> ---&gt;</span><br><span class="line">AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata</span><br></pre></td></tr></table></figure>

<p><code>findAutowiringMetadata</code>的作用就是缓存和从缓存中拿<code>InjectionMetadata</code>对象，其核心就是调用了<code>buildAutowiringMetadata</code>。</p>
<p>看<code>AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> InjectionMetadata <span class="title function_">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, <span class="built_in">this</span>.autowiredAnnotationTypes)) &#123;</span><br><span class="line">		<span class="keyword">return</span> InjectionMetadata.EMPTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> List&lt;InjectionMetadata.InjectedElement&gt; currElements = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//寻找field上面的@Autowired注解并封装成对象</span></span><br><span class="line">		ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">        	<span class="comment">//去掉一些打印日志的</span></span><br><span class="line">        	.....</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">				currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredFieldElement</span>(field, required));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//寻找Method上面的@Autowired注解并封装成对象</span></span><br><span class="line">		ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">			<span class="type">Method</span> <span class="variable">bridgedMethod</span> <span class="operator">=</span> BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">			<span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">			<span class="keyword">if</span> (ann != <span class="literal">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">        <span class="comment">//去掉一些打印日志的</span></span><br><span class="line">        .....</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">required</span> <span class="operator">=</span> determineRequiredStatus(ann);</span><br><span class="line">				<span class="type">PropertyDescriptor</span> <span class="variable">pd</span> <span class="operator">=</span> BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">				currElements.add(<span class="keyword">new</span> <span class="title class_">AutowiredMethodElement</span>(method, required, pd));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">		targetClass = targetClass.getSuperclass();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (targetClass != <span class="literal">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> InjectionMetadata.forElements(elements, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512081.png" alt="image-20211201034115280"></p>
<p>这里就是收集这个类上，有某些注解的属性，而判断的的方法就是在<code>findAutowiredAnnotation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AutowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.autowiredAnnotationTypes.add(Autowired.class);</span><br><span class="line">	<span class="built_in">this</span>.autowiredAnnotationTypes.add(Value.class);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.autowiredAnnotationTypes.add((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;)</span><br><span class="line">				ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));</span><br><span class="line">		logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">		<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> MergedAnnotation&lt;?&gt; findAutowiredAnnotation(AccessibleObject ao) &#123;</span><br><span class="line">	<span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(ao);</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type : <span class="built_in">this</span>.autowiredAnnotationTypes) &#123;</span><br><span class="line">		MergedAnnotation&lt;?&gt; annotation = annotations.get(type);</span><br><span class="line">		<span class="keyword">if</span> (annotation.isPresent()) &#123;</span><br><span class="line">			<span class="keyword">return</span> annotation;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里有3个注解。其中就有<code>@Autowired</code>和<code>@Value</code></p>
<p>而且，会把有这些注解的Field（属性）和 required（是否必须，默认为true）值包装成一个<code>AutowiredFieldElement</code>对象。</p>
<p>后面一个doWithLocalMethods是找方法上有@Autowire的，把必要信息封装成<code>AutowiredMethodElement</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512082.png" alt="image-20210504034041835"></p>
<p>也就是说，只要有@Value和@Autowire的注解的方法或属性，就会创建一个<code>AutowiredMethodElement</code>对象，然后放到一个集合中。</p>
<p>最后，将上边创建的<code>AutowiredMethodElement</code>对象集合封装成<code>InjectionMetadata</code>并返回：</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512083.png" alt="image-20211201035152364"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512084.png" alt="image-20210504034257011"></p>
<p>该方法返回后，会把<code>InjectionMetadata</code>对象放到一个injectionMetadataCache缓存中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512085.png" alt="image-20210314035243562"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512086.png" alt="image-20210314035312540"></p>
<h5 id="CommonAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><a href="#CommonAnnotationBeanPostProcessor-postProcessMergedBeanDefinition" class="headerlink" title="CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition"></a><code>CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</code></h5><p>CommonAnnotationBeanPostProcessor的过程和上面基本一样，就是关注的注解不同。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512087.png" alt="image-20210314040313420"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512088.png" alt="image-20210314040627917"></p>
<p>不过这个类实际上只是处理了@Resource注解而已，真实的处理<code>@PostConstruct</code>和<code>@PreDestroy</code>注解的是在其父类<code>InitDestroyAnnotationBeanPostProcessor</code>上处理的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">	<span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findResourceMetadata(beanName, beanType, <span class="literal">null</span>);</span><br><span class="line">	metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过处理的逻辑都是一样，<code>@PostConstruct</code>和<code>@PreDestroy</code>只能在方法上。而<code>@Resource</code>能在属性和方法上。不过，对应注解封装成的对象不同而已，对于<code>@PostConstruct</code>和<code>@PreDestroy</code>的方法封装成<code>LifecycleElement</code>，对于<code>@Resource</code>，会封装成<code>ResourceElement</code>。</p>
<blockquote>
<p>CommonAnnotationBeanPostProcessor其实还有其他注解的</p>
<ul>
<li><code>WebServiceRef</code></li>
<li><code>EJB</code></li>
</ul>
<p>不过这些用都没用过，就不管了</p>
</blockquote>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>这个方法就是去收集注解的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CommonAnnotationBeanPostProcessor  收集了@PostConstruct，@PreDestroy,@Resource注解</span><br><span class="line">AutowiredAnnotationBeanPostProcessor 收集了 @Autowired,@Value注解</span><br></pre></td></tr></table></figure>



<h4 id="addSingletonFactory—对理解循环依赖帮助非常大"><a href="#addSingletonFactory—对理解循环依赖帮助非常大" class="headerlink" title="addSingletonFactory—对理解循环依赖帮助非常大"></a>addSingletonFactory—对理解循环依赖帮助非常大</h4><blockquote>
<p>这里着重理解，对理解循环依赖帮助非常大，重要程度 5   添加三级缓存</p>
</blockquote>
<p>这个方法在<code>doCreateBean</code>方法中的代码段是:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512089.png" alt="image-20210314174541428"></p>
<p>执行的前提是这个Bean的作用域是<code>Singleton</code>、beanFactory的allowCircularReferences为true（也就是开启循环依赖，默认开启）最后要<code>isSingletonCurrentlyInCreation(beanName)</code>。</p>
<p>这个<code>isSingletonCurrentlyInCreation(beanName)</code>是什么意识呢？<a href="#DefaultSingletonBeanRegistry#getSingleton"><code>DefaultSingletonBeanRegistry#getSingleton</code></a>代码的（也就是<code>doCreateBean</code>的外层方法），调用了下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beforeSingletonCreation(beanName);</span><br></pre></td></tr></table></figure>

<p>把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean</p>
<p>而<code>isSingletonCurrentlyInCreation(beanName)</code>就是判断这个beanName是否在singletonsCurrentlyInCreation Set容器的，也就是判断是否在创建中。正常情况会这个方法会返回true</p>
<p>条件都满足了就调用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>

<p>这里先记下这个<code>ObjectFactory&lt;?&gt; singletonFactory = () -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>对象记下，看<code>addSingletonFactory</code>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">	Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="comment">//如果一级缓存不存在</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">			<span class="comment">//设置三级缓存</span></span><br><span class="line">			<span class="built_in">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">			<span class="comment">//删除二级缓存</span></span><br><span class="line">			<span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">			<span class="built_in">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，重要的一个作用就是设置三级缓存。</p>
<p>首先<code>singletonObjects</code>如果存在，就表示这个对象已经创建完成了，没有的话就会去设置三级缓存，并删除二级缓存。</p>
<p>看下三级缓存的定义<img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512090.png" alt="image-20210314180005128"></p>
<p>也就是说设置三级缓存的意义就是建立beanName和这个对象——<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>的映射关系。</p>
<p>这个方法的作用就是这个，没别的了。</p>
<h4 id="populateBean—依赖注入（DI）的核心方法"><a href="#populateBean—依赖注入（DI）的核心方法" class="headerlink" title="populateBean—依赖注入（DI）的核心方法"></a>populateBean—依赖注入（DI）的核心方法</h4><p>依赖注入的核心方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line">  <span class="comment">//去掉不重要的方法</span></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里很有意思，写接口可以让所有类都不能依赖注入</span></span><br><span class="line">	<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				<span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">PropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">resolvedAutowireMode</span> <span class="operator">=</span> mbd.getResolvedAutowireMode();</span><br><span class="line">	<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">		<span class="type">MutablePropertyValues</span> <span class="variable">newPvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>(pvs);</span><br><span class="line">		<span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">			autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">		<span class="keyword">if</span> (resolvedAutowireMode == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">			autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">		&#125;</span><br><span class="line">		pvs = newPvs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasInstAwareBpps</span> <span class="operator">=</span> hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">needsDepCheck</span> <span class="operator">=</span> (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">	PropertyDescriptor[] filteredPds = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//重点看这个if代码块，重要程度 5</span></span><br><span class="line">	<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">			pvs = mbd.getPropertyValues();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				<span class="comment">//依赖注入过程，@Autowired的支持</span></span><br><span class="line">				<span class="type">PropertyValues</span> <span class="variable">pvsToUse</span> <span class="operator">=</span> ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);</span><br><span class="line">				<span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">						filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//老版本用这个完成依赖注入过程，@Autowired的支持</span></span><br><span class="line">					pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">					<span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				pvs = pvsToUse;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">		<span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">			filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">		&#125;</span><br><span class="line">		checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个方法很鸡肋了，建议不看，是老版本用&lt;property name=&quot;username&quot; value=&quot;Jack&quot;/&gt;</span></span><br><span class="line">	<span class="comment">//标签做依赖注入的代码实现，复杂且无用</span></span><br><span class="line">	<span class="keyword">if</span> (pvs != <span class="literal">null</span>) &#123;</span><br><span class="line">		applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们按功能来分析代码，先看下面代码块。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512091.png" alt="image-20210504035606488"></p>
<p>这里又是BeanPostProcessor接口的应用。</p>
<p>这里我们可以自己写个类实现InstantiationAwareBeanPostProcessor接口，<code>postProcessAfterInstantiation</code>方法返回一个false，就可以不走依赖注入了。比如弄个有条件的依赖注入，类似这样</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512092.png" alt="image-20210314043239159"></p>
<p>感觉这个扩展没什么用，只是用来坑人用的。接着后面的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512093.png" alt="image-20210314043904779"></p>
<p>又是BeanPostProcessor接口的应用，虽然实现<code>InstantiationAwareBeanPostProcessor</code>的类比较多，不过我们还是只关注两个</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512094.png" alt="image-20211201045510424"></p>
<h5 id="AutowiredAnnotationBeanPostProcessor-postProcessProperties"><a href="#AutowiredAnnotationBeanPostProcessor-postProcessProperties" class="headerlink" title="AutowiredAnnotationBeanPostProcessor#postProcessProperties"></a><code>AutowiredAnnotationBeanPostProcessor#postProcessProperties</code></h5><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512095.png" alt="image-20210314044321531"></p>
<p>这个方法之前已经说过了。</p>
<p>之前在<code>applyMergedBeanDefinitionPostProcessors</code>已经收集好了注解了，而且，做了一个beanName和<code>InjectionMetadata</code>的映射。所以这里只需要用beanName就可以获取到<code>InjectionMetadata</code>对象了，这个对象就包含了beanName中，对应的注解信息（@Autowite，@Value等）。之后执行<code>metadata.inject</code>，这个方法就是依赖注入的核心。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512096.png" alt="image-20210314045622236"></p>
<p>先看<code>AutowiredFieldElement#inject</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512101.png" alt="image-20210314045731539"></p>
<p>重点是这个方法，这个方法会触发<code>beanFactory.getBean</code>方法的，也就是说如果A-&gt;B-&gt;C。</p>
<p>A在这个方法中会触发beanFactory.getBean(B)。接着B又在这个方法中会触发beanFactory.getBean(C)</p>
<p>最后调用</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512098.png" alt="image-20210314050130390"></p>
<p>第一个就是调用<code>field.setAccessible(true);</code>，然后通过反射向字段设置值，也就是说依赖的属性现在经过这样的处理后就完成了值的设置了。</p>
<p>DI已经完成了，原理是真的简单，重点只是在收集注解上而已。</p>
<p>方法的依赖注入都一样的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512099.png" alt="image-20210314050610943"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512100.png" alt="image-20210314050619244"></p>
<h5 id="CommonAnnotationBeanPostProcessor-postProcessProperties"><a href="#CommonAnnotationBeanPostProcessor-postProcessProperties" class="headerlink" title="CommonAnnotationBeanPostProcessor#postProcessProperties"></a><code>CommonAnnotationBeanPostProcessor#postProcessProperties</code></h5><p>对于@Resource注解，和上面都是一样的。</p>
<h4 id="引用循环依赖的解决过程"><a href="#引用循环依赖的解决过程" class="headerlink" title="引用循环依赖的解决过程"></a>引用循环依赖的解决过程</h4><p>在<code>AutowiredFieldElement#inject</code>的</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512101.png" alt="image-20210314045731539"></p>
<p>这里会触发依赖对象的beanFactory.getBean，上面说的情况是没有循环依赖的。</p>
<p>不过如果有这样的一种依赖情况—— A-&gt;B-&gt;A，这种也就是循环依赖的情况。</p>
<p>依赖情况—— A-&gt;B-&gt;A</p>
<p>一开始调用了A的<code>doGetBean</code>方法，接着又触发了B的<code>doGetBean</code>，由于循环依赖的关系，B的<code>doGetBean</code>又触发了A的<code>doGetBean</code>。这个流程看上去是一个死循环。但是如果在最后的A的<code>doGetBean</code>时，直接返回A的对象，而不去触发创建操作那当B拿到A对象，方法就返回了，并完成了Spring Bean的初始化流程，那么当B的<code>doGetBean</code>返回后，A也就会继续走其他流程了。下面看Spring源码是怎么实现这一步骤的。</p>
<p>我建立如下的调用顺序：</p>
<ol>
<li>A的<code>doGetBean</code></li>
<li>B的<code>doGetBean</code></li>
<li>B的<code>doGetBean</code>又触发了A的<code>doGetBean</code></li>
</ol>
<p>由于1在执行<code>populateBean</code>方法之前已经创建A这个对象，而且还会调用方法<a href="#addSingletonFactory---%E5%AF%B9%E7%90%86%E8%A7%A3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%B8%AE%E5%8A%A9%E9%9D%9E%E5%B8%B8%E5%A4%A7"><code>addSingletonFactory</code></a>，建立了Map&lt;A,<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>&gt;这种映射关系。2步骤没问题，看3步骤：</p>
<p><a href="#AbstractBeanFactory#getBean">A的<code>doGetBean</code></a>时，会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从缓存中拿实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>

<p>前面简单的讲过这个方法，现在看回这个方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">	<span class="comment">//根据beanName从缓存中拿实例</span></span><br><span class="line">	<span class="comment">//先从一级缓存拿</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">	<span class="comment">//如果bean还正在创建，还没创建完成，其实就是堆内存有了，属性还没有DI依赖注入</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">			<span class="comment">//从二级缓存中拿</span></span><br><span class="line">			singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">			<span class="comment">//如果还拿不到，并且允许bean提前暴露</span></span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">				<span class="comment">//从三级缓存中拿到对象工厂</span></span><br><span class="line">				ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">//从工厂中拿到对象</span></span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					<span class="comment">//升级到二级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">					<span class="comment">//删除三级缓存</span></span><br><span class="line">					<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在1步骤中，A已经在三级缓存有这样一个对象了——<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>。</p>
<blockquote>
<p>注意，这里的bean的对象就是目标对象，也就是A对象。</p>
</blockquote>
<p>也就是说，到这一步时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br></pre></td></tr></table></figure>

<p>得到的结果是singletonFactory &#x3D; <code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code></p>
<p>接着就执行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">singletonObject = singletonFactory.getObject();</span><br></pre></td></tr></table></figure>

<p>也就是说，这里实际执行的<code>getEarlyBeanReference(beanName, mbd, bean)</code>方法，这个方法是在类<code>AbstractAutowireCapableBeanFactory</code>中的。看这个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">				<span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">				exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是BeanPostProcessor的应用，而之所以这样，是因为返回的对象不一定是对象本身，比如AOP，它就需要返回一个代理对象了，所以在这才又使用 了这种BeanPostProcessor的应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512102.png" alt="image-20210314184717848"></p>
<p>这里会返回A对象，那么回到<code>getSingleton()</code>方法，这时会把该对象放入到二级缓存中，并删除三级缓存。<code>getSingleton()</code>的流程结束了，看拿到A的对象后做了什么。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512103.png" alt="image-20210314190913084"></p>
<p>最后还调用了<code>getObjectForBeanInstance</code>方法，这个方法就是FactoryBean接口的调用入口，暂时不看。else 不进入的话就不会去创建了，所以这里返回了，整个流程就和我一开始说的一样。只要在3这步切断A的createBean步骤就可以切断这个闭环了。</p>
<h4 id="构造函数的循环依赖"><a href="#构造函数的循环依赖" class="headerlink" title="构造函数的循环依赖"></a>构造函数的循环依赖</h4><p>Spring是解决不了这种循环依赖的，对于引用的情况，是先创建了对象后才设置引用的。而构造函数的循环依赖是因为这时对象还在创建中，依赖的对象又在创建中。</p>
<p>所以Spring对于构造函数的循环依赖，会直接在启动的时候报错。</p>
<p>不过如果在构造函数上加上@Lazy就可以，因为实例化时获取到的依赖对象是一个代理对象，所以不存在循环依赖。</p>
<p>不过如果@Lazy加载两个类上还会有问题。</p>
<h4 id="Bean范围为Pototype的时候的循环依赖"><a href="#Bean范围为Pototype的时候的循环依赖" class="headerlink" title="Bean范围为Pototype的时候的循环依赖"></a>Bean范围为Pototype的时候的循环依赖</h4><p>这时bean是不会使用到3级缓存的，在源码<a href="#AbstractBeanFactory#getBean"><code>AbstractBeanFactory#getBean</code></a>中是没有调用到<code>DefaultSingletonBeanRegistry#getSingleton</code>方法的，这个方法就是使用3级缓存的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512104.png" alt="image-20210314201326971"></p>
<p>该代码块直接调用了<code>createBean</code>，那只会触发bean的创建流程。但出现循环依赖，对同一对象的第二次调用<code>doGetBean</code>时，会进入到这段代码块:</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512105.png" alt="image-20210314202306023"></p>
<p>会直接报错。</p>
<h4 id="initializeBean—-依赖注入完以后的调用"><a href="#initializeBean—-依赖注入完以后的调用" class="headerlink" title="initializeBean—-依赖注入完以后的调用"></a>initializeBean—-依赖注入完以后的调用</h4><p>bean 实例化+ioc依赖注入完以后，会调用某些接口的方法。而<code>initializeBean</code>就是处理这个逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">		AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;, getAccessControlContext());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//调用Aware方法</span></span><br><span class="line">		invokeAwareMethods(beanName, bean);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">wrappedBean</span> <span class="operator">=</span> bean;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		<span class="comment">//对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5</span></span><br><span class="line">		<span class="comment">//ApplicationContextAwareProcessor 对Aware接口的调用如：</span></span><br><span class="line">		<span class="comment">//EnvironmentAware EmbeddedValueResolverAware  ResourceLoaderAware ApplicationEventPublisherAware MessageSourceAware  ApplicationContextAware</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//ImportAwareBeanPostProcessor 对ImportAware的支持</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5</span></span><br><span class="line">		invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">				(mbd != <span class="literal">null</span> ? mbd.getResourceDescription() : <span class="literal">null</span>),</span><br><span class="line">				beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="literal">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">		<span class="comment">//这个地方可能生出代理实例，是aop的入口</span></span><br><span class="line">		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个一个方法看。</p>
<h5 id="invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware"><a href="#invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware" class="headerlink" title="invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware"></a>invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">			((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">			<span class="type">ClassLoader</span> <span class="variable">bcl</span> <span class="operator">=</span> getBeanClassLoader();</span><br><span class="line">			<span class="keyword">if</span> (bcl != <span class="literal">null</span>) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">			((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="built_in">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是对实现了这些接口的类的方法调用。</p>
<ul>
<li>BeanNameAware</li>
<li>BeanClassLoaderAware</li>
<li>BeanFactoryAware</li>
</ul>
<h5 id="applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法"><a href="#applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法" class="headerlink" title="applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法"></a>applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法</h5><p>对类中某些特殊方法的调用，比如@PostConstruct，Aware接口，非常重要 重要程度 ：5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line">	<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		result = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又是<code>BeanPostProcessor</code>的运用，会调用<code>BeanPostProcessor#postProcessBeforeInitialization</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512106.png" alt="image-20210314052249704"></p>
<p>有很多，我们只关注一些类</p>
<ul>
<li><p>InitDestroyAnnotationBeanPostProcessor——@PostConstruct</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512107.png" alt="image-20210314052448907"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512108.png" alt="image-20210504043518624"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512109.png" alt="image-20210504043526915"></p>
<p>这里会去调用加了这个@PostConstruct的方法。</p>
<p>该类是CommonAnnotationBeanPostProcessor的父类，CommonAnnotationBeanPostProcessor会在<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code>方法中，加入到Spring中，也就是在创建BeanDefinition阶段。</p>
</li>
<li><p>ApplicationContextAwareProcessor——又是Aware接口调用<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512110.png" alt="image-20210314052924616"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">		((EnvironmentAware) bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">		((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="built_in">this</span>.embeddedValueResolver);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">		((ResourceLoaderAware) bean).setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">		((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">		((MessageSourceAware) bean).setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">		((ApplicationContextAware) bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挺简单的，就是会去调用这些接口的方法</p>
<ol>
<li>EnvironmentAware</li>
<li>EmbeddedValueResolverAware</li>
<li>ResourceLoaderAware</li>
<li>ApplicationEventPublisherAware</li>
<li>MessageSourceAware</li>
<li>ApplicationContextAware</li>
</ol>
<p>这个是在AbstractApplicationContext.refresh方法中调用的<code>prepareBeanFactory</code>方法中添加进去的</p>
</li>
<li><p>ImportAwareBeanPostProcessor</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512111.png" alt="image-20210314053429338"><br>调用了ImportAware的方法</p>
<p>比如这样写了一个类<img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512112.png" alt="image-20210314055756895"></p>
<p>是触发不到<img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512113.png" alt="image-20210314055919519"><br>这段代码的，需要这样写<br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512114.png" alt="image-20210314060042187"><br><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512115.png" alt="image-20210314060057865"><br>也就是说只有通过@Import()注解注入的类才能调用到<code>ImportAware#setImportMetadata</code>方法。为什么会这样，这就涉及到这个类<code>ConfigurationClassPostProcessor</code>。这个类在之后会说。</p>
<p>这个是类是通过<code>ConfigurationClassPostProcessor</code>的<code>postProcessBeanFactory</code>方法加入进来的，也就是在Spring bean初始化之前。而<code>ConfigurationClassPostProcessor</code>又是通过<code>AnnotationConfigUtils#registerAnnotationConfigProcessors</code>加入进来的。</p>
</li>
<li><p>ServletContextAwareProcessor——ServletContextAware，ServletConfigAware</p>
<p>这是使用在使用Spring MVC的时候才会被加入到Spring中。</p>
</li>
</ul>
<h5 id="invokeInitMethods—-InitializingBean"><a href="#invokeInitMethods—-InitializingBean" class="headerlink" title="invokeInitMethods—-InitializingBean"></a>invokeInitMethods—-InitializingBean</h5><p>InitializingBean接口，afterPropertiesSet，init-method属性调用,非常重要，重要程度：5</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span><br><span class="line">		<span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">isInitializingBean</span> <span class="operator">=</span> (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">	<span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="literal">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">		......</span><br><span class="line">		<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">					((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;, getAccessControlContext());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">				<span class="keyword">throw</span> pae.getException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//调用实现了InitializingBean接口的方法</span></span><br><span class="line">			((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mbd != <span class="literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">initMethodName</span> <span class="operator">=</span> mbd.getInitMethodName();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">				!(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">				!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">			<span class="comment">//调用init-method配置的方法</span></span><br><span class="line">			invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看到，会调用<code>InitializingBean</code>接口的方法和bean标签的init-method方法。</p>
<h5 id="applyBeanPostProcessorsAfterInitialization—-是aop的入口"><a href="#applyBeanPostProcessorsAfterInitialization—-是aop的入口" class="headerlink" title="applyBeanPostProcessorsAfterInitialization—-是aop的入口"></a>applyBeanPostProcessorsAfterInitialization—-是aop的入口</h5><p>这个地方可能生出代理实例，是aop的入口</p>
<p>前面有个<code>applyBeanPostProcessorsBeforeInitialization</code>方法，这个叫AfterI，很明显又是<code>BeanPostProcessor</code>接口的应用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512116.png" alt="image-20210314061917247"></p>
<p>看了这么多<code>BeanPostProcessor</code>了，都是在循环中的，而且都是对一个Bean循环的，可以看到，如果某个类对对应的方法感兴趣了，就在对应的方法了做一些对类的操作，不感兴趣了就直接返回就好了。而且，<code>BeanPostProcessor</code>这种使用方式感觉就是使用了装饰器模式，虽然没有装饰器模式的形，但有装饰器模式模式的魂—-给原始类添加增强功能</p>
<p>这里先讲一个类<code>ApplicationListenerDetector</code>。</p>
<p>我们之前讲过</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512117.png" alt="image-20210314063047133"></p>
<p><code>ApplicationListener</code>接口的，也就是监听类。这个监听类就是在<code>ApplicationListenerDetector#postProcessAfterInitialization</code>方法添加到applicationContext的事件管理类中的。（注意这里是实现接口，但注解的情况在这里没有处理，注解的情况后面会说）</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512118.png" alt="image-20210314063353992"></p>
<p>还有一个<code>AnnotationAwareAspectJAutoProxyCreator</code>这个是AOP的入口方法，详情看这两节</p>
<ol>
<li><a href="./08-Spring-AOP%E6%A6%82%E5%BF%B5">08-Spring-AOP概念</a></li>
<li><a href="./09-Spring-AOP%E8%A7%A3%E6%9E%90">09-Spring-AOP解析</a></li>
</ol>
<h4 id="registerDisposableBeanIfNecessary—注册DisposableBeanAdapter"><a href="#registerDisposableBeanIfNecessary—注册DisposableBeanAdapter" class="headerlink" title="registerDisposableBeanIfNecessary—注册DisposableBeanAdapter"></a>registerDisposableBeanIfNecessary—注册DisposableBeanAdapter</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注册bean销毁时的类DisposableBeanAdapter</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512119.png" alt="image-20210314204615965"></p>
<p>代码很简单<code>registerDisposableBean</code>就是在下面的Map中建立&lt;beanName, DisposableBeanAdapter&gt;这种映射关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512120.png" alt="image-20210314204640118"></p>
<p>DisposableBeanAdapter就是用于bean销毁（这里的销毁不是触发GC，而是Spring结束前对bean做的一些操作）的实例</p>
<p><code>DisposableBeanAdapter</code>的构造函数做如下操作</p>
<ol>
<li>是否有实现了接口<code>DisposableBean</code>和AutoCloseable</li>
<li>在bean标签中是否定义了destroy-method属性</li>
<li>获取到对象中有@PreDestory注解的方法。</li>
</ol>
<p>什么时候触发的？手动这样触发的</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512121.png" alt="image-20210314210742910"></p>
<p>Tomcat启动时，<code>AbstractReactiveWebInitializer</code>这个类里面会为Tomcat添加一个<code>ServletContextListener</code>，当tomcat触发close方法时，会调用<code>contextDestroyed</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.applicationContext.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// 这里会调用getBeanFactory().destroySingletons();</span></span><br><span class="line">    <span class="comment">// destroySingletonsa会去触发DisposableBeanAdapter的destroy方法</span></span><br><span class="line">		doClose();</span><br><span class="line">		<span class="comment">// If we registered a JVM shutdown hook, we don&#x27;t need it anymore now:</span></span><br><span class="line">		<span class="comment">// We&#x27;ve already explicitly closed the context.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.shutdownHook != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Runtime.getRuntime().removeShutdownHook(<span class="built_in">this</span>.shutdownHook);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">				<span class="comment">// ignore - VM is already shutting down</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="DefaultSingletonBeanRegistry-getSingleton-—-Bean创建完成后"><a href="#DefaultSingletonBeanRegistry-getSingleton-—-Bean创建完成后" class="headerlink" title="DefaultSingletonBeanRegistry#getSingleton —-Bean创建完成后"></a>DefaultSingletonBeanRegistry#getSingleton —-Bean创建完成后</h3><p>看<a href="#DefaultSingletonBeanRegistry#getSingleton"><code>DefaultSingletonBeanRegistry#getSingleton</code></a>代码，上面的都只是这个调用的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把beanName添加到singletonsCurrentlyInCreation Set容器中，在这个集合里面的bean都是正在实例化的bean</span></span><br><span class="line">beforeSingletonCreation(beanName);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512122.png" alt="image-20210314171229160"></p>
<p>接着调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">afterSingletonCreation(beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterSingletonCreation</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="built_in">this</span>.singletonsCurrentlyInCreation.remove(beanName)) &#123;</span><br><span class="line">    <span class="comment">//抛出IllegalStateException</span></span><br><span class="line">    .....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的<code>beforeSingletonCreation</code>是把beanName添加到singletonsCurrentlyInCreation Set容器中，表示这个Bean正在创建；而创建完成后，就调用了<code>afterSingletonCreation</code>方法，把beanName在singletonsCurrentlyInCreation Set容器中移除，表示Bean已经创建完成了。</p>
<p>最后调用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">   <span class="comment">//创建对象成功时，把对象缓存到singletonObjects缓存中,bean创建完成时放入一级缓存</span></span><br><span class="line">   addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="comment">//一级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">		<span class="comment">//三级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">		<span class="comment">//二级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">		<span class="built_in">this</span>.registeredSingletons.add(beanName); <span class="comment">//这是设计到统计的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把创建好的Bean放入到一级缓存singletonObjects中，并把二、三级缓存删掉。</p>
<p>总结下这个方法的作用，就是在缓存中没有对象的时候会去调用jvm的对象创建流程，创建完成成后，封装一个ObjectFactory并放入三级缓存中，在三级缓存建立&lt;beanName, ObjectFactory&gt;这样的对应关系，当处理IOC和DI时，如果出现循环依赖就通过三级缓存的ObjectFactory获取到之前已经创建好的jvm对象，并移出三级缓存进入二级缓存。最后IOC和DI处理完，并且对应接口的调用也调用完了，就把bean放入到一级缓存中，并移除二级、三级缓存对应的值。而对象创建的流程时通过方法createBean实现的，并不是<code>getSingleton</code>的逻辑。<code>getSingleton</code>的核心逻辑就是只是使用了singletonObjects 这个一级缓存。</p>
<h2 id="放入一级缓存"><a href="#放入一级缓存" class="headerlink" title="放入一级缓存"></a>放入一级缓存</h2><p>Bean初始化完成后，也就是<code>AbstractBeanFactory#createBean</code>方法调用完成后，</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512123.png" alt="image-20211201225853366"></p>
<p>这时会返回对象，也就是DefaultSingletonBeanRegistry的getSingleton方法中</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512124.png" alt="image-20211201230116104"></p>
<p>这代码执行完成了。最后就是执行了这些方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512125.png" alt="image-20211201230203586"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="comment">//一级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">		<span class="comment">//三级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">		<span class="comment">//二级缓存</span></span><br><span class="line">		<span class="built_in">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">		<span class="built_in">this</span>.registeredSingletons.add(beanName); <span class="comment">//这是设计到统计的</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上边的是只有scope&#x3D;”Singleton”时才会执行到，也就是说只有时单例模式，spring才会缓存对象。如果是<code>prototype</code>，也就是多例的时候，是不会用到缓存的。看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanFactory#doGetBean</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">	<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		beforePrototypeCreation(beanName);</span><br><span class="line">		prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		afterPrototypeCreation(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//该方法是FactoryBean接口的调用入口</span></span><br><span class="line">	bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于多例它是直接createBean的，没有通过getSingleton方法，来缓存。</p>
<h2 id="实现FactoryBean接口的类的实例化"><a href="#实现FactoryBean接口的类的实例化" class="headerlink" title="实现FactoryBean接口的类的实例化"></a>实现<code>FactoryBean</code>接口的类的实例化</h2><p>这个和<code>FactoryBean</code>接口有关</p>
<p><code>FactoryBean</code>接口的<code>getObject</code>在这个类实例化过程中是不会调用<code>getObject</code>方法的，只有在需要使用<code>getObject</code>返回对象时才会去调用这个方法。</p>
<p>回到refresh()方法。跟踪代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractApplicationContext#refresh --&gt;</span><br><span class="line">AbstractApplicationContext#finishBeanFactoryInitialization --&gt; </span><br><span class="line">DefaultListableBeanFactory#preInstantiateSingletons</span><br></pre></td></tr></table></figure>

<p>看<code>DefaultListableBeanFactory#preInstantiateSingletons</code>部分源码</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512126.png" alt="image-20210315002901061"></p>
<p>这个if就是判断是否实现了FactoryBean接口，这里就看if代码块的代码，先看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br></pre></td></tr></table></figure>

<p>也就是说，对于FactoryBean类，在调用getBean时会使用<code>&amp;beanName</code>这种形式去找bean</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512127.png" alt="image-20210315003728277"></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512128.png" alt="image-20210315003844685"></p>
<p>这时，经过<code>transformedBeanName</code>又去掉了&amp;符号，并把这个值赋给了新引用。</p>
<p>我们找的目标bean的名字就是beanName引用的指向的字符串。而且这个beanName是有对应的BeanDefinition，这个BeanDefinition指向的类是实现了FactoryBean接口的。所以如果走完Bean的初始化流程，那初始化出来的对象的类型肯定不是我们的目标类型。而是实现了FactoryBean接口类的类型</p>
<blockquote>
<p>下图返回的是一个代理对象，之所以是代理是因为如果不是代理对象的情况下，直接返回FactoryBean接口对象，那么如果程序通过&amp;baenName获取到该FactoryBean对象，接着通过这个对象调用getObject()方法，那么就会产生一个新的目标对象，这和Spring中bean的范围为singleton相矛盾了，所以这里返回的代理对象，就算程序通过&amp;baenName获取FactoryBean对象，由于这个FactoryBean对象是代理对象，那么在调用getObject()时就能做一些前置处理，比如检查目标对象是否在缓存中存在，如果存在就直接返回就行了。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512129.png" alt="image-20210315005300496"></p>
<p>也就是说，在这个时候在一级缓存singletonObjects 这个Map中就存在一个这样的关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beanName, FactoryBean接口类（代理）&gt;</span><br></pre></td></tr></table></figure>

<p>接着会执行这个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractBeanFactory.getObjectForBeanInstance(sharedInstance, name, beanName, mbd)</span><br></pre></td></tr></table></figure>

<p>调用这个方法的时候name&#x3D;&amp;beanName， beanName&#x3D;beanName的，这从上图就已经证明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">  <span class="comment">// 检查是否以&amp;开头</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在上边的情况这时&#96;if (BeanFactoryUtils.isFactoryDereference(name)) 为true，就直接放回了。所以当通过&amp;beanName获取到的对象为FactoryBean的对象。此时，这个bean的初始化就已经结束了。下面看FactoryBean.getObject方法是什么时候调用的。</p>
<p>假如某个类的定义如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AFactoryBean <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;BObject&gt; &#123;</span><br><span class="line">  	.....</span><br><span class="line">    <span class="keyword">public</span> BObject <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      renturn <span class="keyword">new</span> <span class="title class_">BObject</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  	....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> C &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowire</span></span><br><span class="line">  <span class="keyword">private</span> BObject bObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在该类C的DI阶段，就会调用beanFactory.getBean(“bObject”)，那么此时</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512130.png" alt="image-20211201223800480"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(<span class="string">&quot;bObject&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这代码会返回一个对象，而且这个对象是AFactoryBean，此时进入到<code>getObjectForBeanInstance</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getObjectForBeanInstance</span><span class="params">(</span></span><br><span class="line"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">	<span class="comment">// 检查是否以&amp;开头</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanIsNotAFactoryException</span>(beanName, beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">	<span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">	<span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">	<span class="comment">//如果实例不是FactoryBean类型的</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果代码能走下来，则说明 beanName不是以&amp;开头，并且beanInstance是FactoryBean类型的</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd != <span class="literal">null</span>) &#123;</span><br><span class="line">		mbd.isFactoryBean = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//从缓存里面拿FactoryBean类型的实例</span></span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">synthetic</span> <span class="operator">=</span> (mbd != <span class="literal">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		<span class="comment">//重点看</span></span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于beanName是bObject，所以不会进入到if代码，那么此时最后会走到这代码块</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512131.png" alt="image-20211201225111140"></p>
<p>重点看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512132.png" alt="image-20210315011643696"></p>
<p>先从缓存<code>factoryBeanObjectCache</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512133.png" alt="image-20210315011722171"></p>
<p>中拿，没有就执行下边的<code>doGetObjectFromFactoryBean</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512134.png" alt="image-20210315011757025"></p>
<p>这个方法放回后，想都不用想，就是把拿到的目标对象放到缓存<code>factoryBeanObjectCache</code>中。下次再通过beanName就可以直接在缓存<code>factoryBeanObjectCache</code>中获取了。</p>
<p>而如果这时时通过&amp;beanName去获取bean，那么进入<code>doGetBean</code>时会把&amp;去掉后获取到一个实现FactoryBean类型类的对象，之后进入getObjectForBeanInstance(sharedInstance, name, beanName, mbd)时由于BeanFactoryUtils.isFactoryDereference(name)为true，所以就直接返回了实现FactoryBean类型类的对象了（注意，这个是代理对象）。</p>
<h3 id="FactoryBean的应用场景"><a href="#FactoryBean的应用场景" class="headerlink" title="FactoryBean的应用场景"></a>FactoryBean的应用场景</h3><p>可以提供用户自己定义实例化</p>
<h2 id="在Spring中如果你想创建一个对象，对象能被Spring管理"><a href="#在Spring中如果你想创建一个对象，对象能被Spring管理" class="headerlink" title="在Spring中如果你想创建一个对象，对象能被Spring管理"></a>在Spring中如果你想创建一个对象，对象能被Spring管理</h2><ol>
<li>自定义BeanDefination，通过BeanDefinitionRegistryPostProcessor接口</li>
<li><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512135.png" alt="image-20210315013433388"></li>
<li>实现FactoryBean</li>
<li>@Bean</li>
</ol>
<h2 id="Spring-bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口"><a href="#Spring-bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口" class="headerlink" title="Spring bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口"></a>Spring bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口</h2><p>回到<code>DefaultListableBeanFactory#preInstantiateSingletons()</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512136.png" alt="image-20210504052036554"></p>
<p>在这里会调用接口SmartInitializingSingleton的方法。</p>
<p>这里说一个类就是<code>EventListenerMethodProcessor</code>。</p>
<h3 id="EventListenerMethodProcessor——-EventListener注解的解析"><a href="#EventListenerMethodProcessor——-EventListener注解的解析" class="headerlink" title="EventListenerMethodProcessor——@EventListener注解的解析"></a>EventListenerMethodProcessor——@EventListener注解的解析</h3><p>[Spring Event事件通知机制](.&#x2F;Spring Event事件通知机制)</p>
<h2 id="Spring初始化流程中的三级缓存"><a href="#Spring初始化流程中的三级缓存" class="headerlink" title="Spring初始化流程中的三级缓存"></a>Spring初始化流程中的三级缓存</h2><p>在Spring的初始化流程会使用到三级缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>其中<code>singletonObjects</code>就是最缓存最终的对象的。而<code>earlySingletonObjects</code>和<code>singletonFactories</code>相互配合使用，完成了Bean的初始化流程</p>
<p>比如：存在这样一个类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">	@Autowrite</span><br><span class="line">  A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先一个，在beanFactory.getBean(A)的时候，</p>
<ol>
<li><p>new A</p>
</li>
<li><p>收集A中的注解信息（@Autowrite、@Resource、@Value和@PostConstruct等注解信息）</p>
</li>
<li><p>创建一个包含A对象引用的ObjectFactory对象，并把这个对象放入3级缓存中。</p>
</li>
<li><p><code>populateBean</code>，完成Bean的填充（DI依赖注入）和<code>@PostConstruct</code>等注解的处理</p>
<p>在处理依赖注入时，本质上就是进行beanFactory#getBean，所以对于A对象的依赖注入，会进行beanFactory.getBean(a)</p>
<ol>
<li>从三级缓存中一级一级的拿对象，最终在第三级<code>singletonFactories</code>中获取到一个ObjectFactory对象。然后会执行ObjectFactory#getObject。</li>
<li>会对ObjectFactory对象中的A对象进行<code>AbstractAutoProxyCreator#getEarlyBeanReference</code>，也就是进行切面的匹配，匹配到的话就生成代理对象。</li>
<li>把第二步中返回的A对象（或A对像的代理对象）放入二级缓存，并移除3级缓存（这时二级缓存已经是最终的对象了）</li>
<li>把第3步的对象返回，作为A对象中a属性引用的对象。</li>
</ol>
</li>
<li><p>对A对象进行<code>initializeBean</code>，并返回A对象（或A对像的代理对象）</p>
<ol>
<li><p>BeanPostProcessor#postProcessBeforeInitialization的执行，包括对<code>ApplicationEventPublisherAware</code>、<code>ApplicationContextAware</code>等接口的处理和<code>@PostConstruct</code>的等注解的处理</p>
</li>
<li><p>执行<code>InitializingBean#afterPropertiesSet</code></p>
</li>
<li><p>BeanPostProcessor#postProcessAfterInitialization的执行，并返回A对象（或A对像的代理对象）</p>
<p>最重要的就是<code>AbstractAutoProxyCreator</code>，完成切面匹配和代理类生成。对于A对象，由于在4.2中已经执行过这一步了，所以这里不会重复执行，会直接返回A对象。</p>
</li>
</ol>
</li>
<li><p>会从二级缓存拿对象，如果没有就直接返回A对象。如果有就返回二级缓存对象（A对象或者A对像的代理对象）</p>
<p>对于没有的情况，是不存在循环依赖才会出现这种情况，而对于有的情况，就意味着有循环引用。</p>
<p>对于A对象，由于在第4步中提前完成了切面匹配和代理对象的生成，所以这里会返回A对象（或A对像的代理对象）</p>
</li>
<li><p>把第6步返回的对象（A对象或者A对像的代理对象）放入到一级缓存中，并移除二三级缓存对应的内容。</p>
</li>
</ol>
<p>从这个过程可以看出，三级缓存<code>singletonFactories</code>就是用来避免循环依赖时，重复触发creaetBean的问题，并且会对Bean提交进行包装（AOP）。而二级缓存<code>earlySingletonObjects</code>存放提前完成包装的对象（AOP），并负责提前暴露给其他bean。</p>
<h2 id="Spring-Bean初始化流程图"><a href="#Spring-Bean初始化流程图" class="headerlink" title="Spring Bean初始化流程图"></a>Spring Bean初始化流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512137.jpg" alt="Bean实例化过程"></p>
<h2 id="Spring-Bean-循环依赖的流程图"><a href="#Spring-Bean-循环依赖的流程图" class="headerlink" title="Spring Bean 循环依赖的流程图"></a>Spring Bean 循环依赖的流程图</h2><p><img src="https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/blog/1414371176569512138.jpg" alt="spring中单例实例的循环依赖"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">xyz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nbobj.github.io/blog/spring/04-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96/">https://nbobj.github.io/blog/spring/04-Spring的Bean实例化/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nbobj.github.io" target="_blank">XYZhi's学习笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring/">spring</a></div><div class="post_share"></div></div><div class="post-nav"><a class="pre" href="/blog/spring/05-Spring%E9%85%8D%E7%BD%AE%E7%9A%84%E8%A7%A3%E6%9E%90/">05-Spring配置的解析</a><a class="next" href="/blog/spring/03-Spring%E7%9A%84Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%89%8D%E7%9A%84%E6%96%B9%E6%B3%95/">03-Spring的Bean实例化前的方法</a></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xyz</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">321</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#DefaultListableBeanFactory-preInstantiateSingletons"><span class="toc-number">1.</span> <span class="toc-text">DefaultListableBeanFactory#preInstantiateSingletons</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractBeanFactory-getBean"><span class="toc-number">2.</span> <span class="toc-text">AbstractBeanFactory#getBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%88%B6BeanFactory%E8%8E%B7%E5%8F%96bean"><span class="toc-number">2.1.</span> <span class="toc-text">通过父BeanFactory获取bean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultSingletonBeanRegistry-getSingleton"><span class="toc-number">2.2.</span> <span class="toc-text">DefaultSingletonBeanRegistry#getSingleton</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractAutowireCapableBeanFactory-doCreateBean"><span class="toc-number">2.3.</span> <span class="toc-text">AbstractAutowireCapableBeanFactory#doCreateBean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createBeanInstance%E2%80%94-Bean-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACIOC%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">createBeanInstance—-Bean 的实例化过程（控制反转IOC）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lt-bean-gt-%E6%A0%87%E7%AD%BE%E9%87%8C%E9%9D%A2%E3%80%82%E9%85%8D%E7%BD%AE%E4%BA%86factory-method%E5%B1%9E%E6%80%A7%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">&lt;bean&gt;标签里面。配置了factory-method属性的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E9%9D%A2%E5%8A%A0%E4%B8%8A-Bean%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">方法上面加上@Bean注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B8%A6%E6%9C%89-Autowired%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">实例化带有@Autowired注解的构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%B2%A1%E6%9C%89-Autowired%E7%9A%84%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">实例化没有@Autowired的有参构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">实例化无参构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applyMergedBeanDefinitionPostProcessors%E2%80%94%E5%AF%B9%E7%B1%BB%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E8%A3%85%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">applyMergedBeanDefinitionPostProcessors—对类中注解的收集和装配过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">AutowiredAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CommonAnnotationBeanPostProcessor-postProcessMergedBeanDefinition"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addSingletonFactory%E2%80%94%E5%AF%B9%E7%90%86%E8%A7%A3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%B8%AE%E5%8A%A9%E9%9D%9E%E5%B8%B8%E5%A4%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">addSingletonFactory—对理解循环依赖帮助非常大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#populateBean%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.4.</span> <span class="toc-text">populateBean—依赖注入（DI）的核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AutowiredAnnotationBeanPostProcessor-postProcessProperties"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">AutowiredAnnotationBeanPostProcessor#postProcessProperties</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CommonAnnotationBeanPostProcessor-postProcessProperties"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">CommonAnnotationBeanPostProcessor#postProcessProperties</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.5.</span> <span class="toc-text">引用循环依赖的解决过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.6.</span> <span class="toc-text">构造函数的循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E8%8C%83%E5%9B%B4%E4%B8%BAPototype%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.7.</span> <span class="toc-text">Bean范围为Pototype的时候的循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initializeBean%E2%80%94-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%8C%E4%BB%A5%E5%90%8E%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.8.</span> <span class="toc-text">initializeBean—-依赖注入完以后的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeAwareMethods%E2%80%94-BeanNameAware%E3%80%81BeanClassLoaderAware%E5%92%8CBeanFactoryAware"><span class="toc-number">2.3.8.1.</span> <span class="toc-text">invokeAwareMethods—-BeanNameAware、BeanClassLoaderAware和BeanFactoryAware</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#applyBeanPostProcessorsBeforeInitialization%E2%80%94%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.8.2.</span> <span class="toc-text">applyBeanPostProcessorsBeforeInitialization—非常重要的一个方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeInitMethods%E2%80%94-InitializingBean"><span class="toc-number">2.3.8.3.</span> <span class="toc-text">invokeInitMethods—-InitializingBean</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#applyBeanPostProcessorsAfterInitialization%E2%80%94-%E6%98%AFaop%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-number">2.3.8.4.</span> <span class="toc-text">applyBeanPostProcessorsAfterInitialization—-是aop的入口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerDisposableBeanIfNecessary%E2%80%94%E6%B3%A8%E5%86%8CDisposableBeanAdapter"><span class="toc-number">2.3.9.</span> <span class="toc-text">registerDisposableBeanIfNecessary—注册DisposableBeanAdapter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultSingletonBeanRegistry-getSingleton-%E2%80%94-Bean%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90%E5%90%8E"><span class="toc-number">2.4.</span> <span class="toc-text">DefaultSingletonBeanRegistry#getSingleton —-Bean创建完成后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%BE%E5%85%A5%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">放入一级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0FactoryBean%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.</span> <span class="toc-text">实现FactoryBean接口的类的实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FactoryBean%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.1.</span> <span class="toc-text">FactoryBean的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Spring%E4%B8%AD%E5%A6%82%E6%9E%9C%E4%BD%A0%E6%83%B3%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%B9%E8%B1%A1%E8%83%BD%E8%A2%ABSpring%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">在Spring中如果你想创建一个对象，对象能被Spring管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E5%90%8E%E2%80%94%E2%80%94%E6%94%BE%E5%85%A5%E5%88%B0%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%89%A7%E8%A1%8CSmartInitializingSingleton%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">Spring bean初始化完成后——放入到一级缓存之后，执行SmartInitializingSingleton接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EventListenerMethodProcessor%E2%80%94%E2%80%94-EventListener%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90"><span class="toc-number">6.1.</span> <span class="toc-text">EventListenerMethodProcessor——@EventListener注解的解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">Spring初始化流程中的三级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">Spring Bean初始化流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">Spring Bean 循环依赖的流程图</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/05-Nacos%E4%B8%AD%E7%9A%84AbstractNacosTaskExecuteEngine/" title="05-Nacos中的AbstractNacosTaskExecuteEngine">05-Nacos中的AbstractNacosTaskExecuteEngine</a><time datetime="2021-11-27T12:00:40.000Z" title="发表于 2021-11-27 20:00:40">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/04-Server%E5%92%8CClient%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96nacos%E5%9C%B0%E5%9D%80/" title="04-Server和Client动态获取nacos地址">04-Server和Client动态获取nacos地址</a><time datetime="2021-11-27T12:00:39.000Z" title="发表于 2021-11-27 20:00:39">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/03-Nacos%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/" title="03-Nacos的发布与订阅">03-Nacos的发布与订阅</a><time datetime="2021-11-27T12:00:38.000Z" title="发表于 2021-11-27 20:00:38">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/02-Nacos%20Server%E4%B8%AD%E7%9A%84Secured%E6%B3%A8%E8%A7%A3/" title="02-Nacos Server中的Secured注解">02-Nacos Server中的Secured注解</a><time datetime="2021-11-27T12:00:37.000Z" title="发表于 2021-11-27 20:00:37">2021-11-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/blog/springcloud/nacos%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/01-Nacos%20Server%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" title="01-Nacos Server服务注册表的写时复制">01-Nacos Server服务注册表的写时复制</a><time datetime="2021-11-27T12:00:36.000Z" title="发表于 2021-11-27 20:00:36">2021-11-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/XieYueZhi/cdn/md/1647876373-d1304d.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xyz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>